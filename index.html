<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>üêâ Cronache del Destino v6</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=MedievalSharp&display=swap" rel="stylesheet">
    <style>
        :root {
            --parchment: #f4e4bc;
            --parchment-dark: #d4c4a0;
            --ink: #2c1810;
            --ink-light: #5c4030;
            --gold: #c9a227;
            --gold-dark: #8b6914;
            --blood: #8b0000;
            --emerald: #2e8b57;
            --sapphire: #1e3a5f;
            --shadow: rgba(0,0,0,0.4);
            --orange: #ff8c00;
            --purple: #6b2e9b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Crimson Text', Georgia, serif;
            background: linear-gradient(135deg, #1a0f0a 0%, #2c1810 50%, #1a0f0a 100%);
            min-height: 100vh;
            min-height: 100dvh;
            color: var(--ink);
            overflow-x: hidden;
        }

        /* ==================== SCREENS ==================== */
        .screen {
            display: none;
            min-height: 100vh;
            min-height: 100dvh;
        }

        .screen.active {
            display: flex;
            flex-direction: column;
        }

        /* ==================== HOMEPAGE ==================== */
        #home-screen {
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: 
                radial-gradient(ellipse at center, rgba(201, 162, 39, 0.1) 0%, transparent 70%),
                linear-gradient(135deg, #1a0f0a 0%, #2c1810 50%, #1a0f0a 100%);
        }

        .home-container {
            text-align: center;
            max-width: 500px;
            width: 100%;
        }

        .home-logo {
            font-size: 5em;
            margin-bottom: 10px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .home-title {
            font-family: 'Cinzel', serif;
            font-size: 2.5em;
            color: var(--gold);
            text-shadow: 2px 2px 8px rgba(0,0,0,0.8);
            margin-bottom: 5px;
        }

        .home-subtitle {
            font-family: 'MedievalSharp', cursive;
            font-size: 1.1em;
            color: var(--parchment-dark);
            margin-bottom: 40px;
        }

        .home-menu {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .home-btn {
            padding: 18px 30px;
            font-family: 'Cinzel', serif;
            font-size: 1.2em;
            background: linear-gradient(180deg, var(--parchment), var(--parchment-dark));
            border: 3px solid var(--gold-dark);
            border-radius: 12px;
            color: var(--ink);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px var(--shadow);
        }

        .home-btn:hover, .home-btn:active {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px var(--shadow);
            border-color: var(--gold);
        }

        .home-btn.primary {
            background: linear-gradient(180deg, var(--gold), var(--gold-dark));
            color: white;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
        }

        .home-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .home-section {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 1px solid var(--gold-dark);
        }

        .home-section-title {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            margin-bottom: 15px;
        }

        /* ==================== GAME SCREEN ==================== */
        #game-screen {
            background: var(--parchment);
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
        }

        #game-screen.active {
            display: flex;
            flex-direction: column;
        }

        /* TOPBAR - STICKY */
        .game-topbar {
            position: sticky;
            top: 0;
            z-index: 100;
            background: linear-gradient(180deg, var(--ink), #1a0f08);
            padding: 6px 10px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            flex-shrink: 0;
            border-bottom: 2px solid var(--gold);
        }

        .topbar-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .topbar-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .topbar-btn {
            padding: 8px 12px;
            font-size: 1.1em;
            background: linear-gradient(180deg, #f7d37a, var(--gold-dark));
            border: 1px solid rgba(0,0,0,0.35);
            border-radius: 12px;
            color: #1f130b;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 38px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 14px rgba(0,0,0,0.35);
        }

        .topbar-btn:hover, .topbar-btn:active {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 10px 18px rgba(0,0,0,0.4);
        }

        .topbar-btn.danger {
            background: linear-gradient(180deg, var(--blood), #5a0000);
            border-color: var(--blood);
        }

        .topbar-btn.special {
            background: linear-gradient(180deg, var(--purple), #4a1e6b);
            border-color: var(--purple);
        }

        /* Time Display */
        .time-display {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 14px;
            background: rgba(0,0,0,0.55);
            border-radius: 18px;
            font-family: 'Cinzel', serif;
            color: var(--parchment);
            box-shadow: 0 6px 18px rgba(0,0,0,0.35);
            border: 1px solid rgba(201, 162, 39, 0.35);
        }

        .time-icon {
            font-size: 1.3em;
        }

        .time-block {
            display: flex;
            flex-direction: column;
            line-height: 1.2;
        }

        .time-main {
            font-size: 0.95em;
            letter-spacing: 0.03em;
        }

        .time-sub {
            font-size: 0.75em;
            color: var(--parchment-dark);
        }

        /* Mini Stats */
        .mini-stats {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .mini-bar {
            width: 74px;
            height: 12px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.45), rgba(0, 0, 0, 0.65));
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.6);
        }

        .mini-bar::before {
            content: attr(data-label);
            position: absolute;
            left: 50%;
            top: -18px;
            transform: translateX(-50%);
            font-size: 0.7em;
            color: rgba(255,255,255,0.9);
            letter-spacing: 0.03em;
        }

        .mini-bar::after {
            content: attr(data-value);
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.65em;
            color: rgba(255,255,255,0.92);
            text-shadow: 0 1px 2px rgba(0,0,0,0.7);
            letter-spacing: 0.02em;
        }

        .mini-bar-fill {
            height: 100%;
            border-radius: 6px;
            transition: width 0.3s ease;
            box-shadow: inset 0 0 4px rgba(255,255,255,0.25);
        }

        .mini-bar-fill.health { background: linear-gradient(90deg, #c62828, #ef5350); }
        .mini-bar-fill.stamina { background: linear-gradient(90deg, #1565c0, #42a5f5); }
        .mini-bar-fill.hunger { background: linear-gradient(90deg, #f57c00, #ffb74d); }

        /* Info Panels (Finanze, Famiglia, Dipendenti) */
        .topbar-info-panels {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .info-panel {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: rgba(255,255,255,0.9);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(0,0,0,0.1);
            min-width: 90px;
        }
        .info-panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .info-panel.finances { border-left: 3px solid #f4a100; }
        .info-panel.family { border-left: 3px solid #e91e63; }
        .info-panel.employees { border-left: 3px solid #2196f3; }
        .info-panel .info-icon { font-size: 1.3em; }
        .info-panel .info-content { display: flex; flex-direction: column; }
        .info-panel .info-label { font-size: 0.65em; color: var(--ink-light); text-transform: uppercase; letter-spacing: 0.5px; }
        .info-panel .info-value { font-size: 0.85em; font-weight: 600; color: var(--ink); font-family: 'Cinzel', serif; }
        .info-panel.negative .info-value { color: #c00; }
        .info-panel.positive .info-value { color: #2e7d32; }
        
        /* Quick Modal Styles */
        .quick-modal-content { margin: 15px 0; }
        .finances-detail h4, .finances-detail h5 { margin: 12px 0 8px; color: var(--ink); }
        .fin-section { background: rgba(0,0,0,0.03); padding: 8px; border-radius: 6px; margin-bottom: 8px; }
        .fin-row { display: flex; justify-content: space-between; padding: 4px 0; font-size: 0.9em; }
        .fin-row.total { border-top: 1px solid var(--ink-light); margin-top: 6px; padding-top: 8px; font-weight: 600; }
        .fin-row .positive { color: #2e7d32; }
        .fin-row .negative { color: #c00; }
        .fin-section.net { background: var(--parchment-dark); }
        .family-member, .employee { background: rgba(0,0,0,0.03); padding: 10px; border-radius: 6px; margin-bottom: 8px; }
        .member-header { font-size: 1em; margin-bottom: 5px; }
        .member-info, .member-desc { font-size: 0.85em; color: var(--ink-light); }
        .member-income { color: #2e7d32; font-size: 0.85em; }
        .member-expense { color: #c00; font-size: 0.85em; }
        .emp-property h5 { margin: 10px 0 5px; color: var(--ink); }
        .employee { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
        .emp-name { font-weight: 600; }
        .emp-role { color: var(--ink-light); }
        .emp-comp { font-size: 0.85em; }
        .emp-salary { font-size: 0.85em; color: #c00; }
        
        /* Chronicle View */
        .chronicle-view { padding: 10px; max-height: 400px; overflow-y: auto; }
        .chronicle-header { 
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(135deg, var(--parchment-dark), var(--parchment));
            padding: 12px 15px; border-radius: 8px; margin-bottom: 15px;
            border: 1px solid var(--gold);
        }
        .chronicle-protagonist { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
        .chronicle-protagonist strong { font-size: 1.1em; color: var(--ink); font-family: 'Cinzel', serif; }
        .chr-origin, .chr-archetype { font-size: 0.8em; color: var(--ink-light); }
        .chr-level { background: var(--gold); color: #fff; padding: 2px 8px; border-radius: 10px; font-size: 0.75em; font-weight: 600; }
        .chronicle-turn { font-size: 0.85em; color: var(--ink-light); }
        .chronicle-content { line-height: 1.6; }
        .chronicle-section { 
            background: rgba(0,0,0,0.02); padding: 12px; border-radius: 6px; 
            margin-bottom: 10px; border-left: 3px solid var(--gold);
        }
        .chronicle-section-title { font-weight: 600; color: var(--ink); margin-bottom: 6px; font-size: 0.95em; }
        .chronicle-section-content { font-size: 0.85em; color: var(--ink-light); }
        .chronicle-empty { text-align: center; padding: 30px; color: var(--ink-light); }
        .chronicle-empty p { margin: 8px 0; }

        /* Story Area */
        .story-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .story-scroll {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            background: 
                radial-gradient(ellipse at top, rgba(201, 162, 39, 0.05) 0%, transparent 50%),
                var(--parchment);
        }

        .story-entry {
            position: relative;
            margin-bottom: 15px;
            padding: 14px 16px 12px;
            border-radius: 12px;
            line-height: 1.6;
            background: rgba(255,255,255,0.82);
            border-left: 4px solid var(--ink);
            box-shadow: 0 10px 30px rgba(0,0,0,0.18);
            overflow: hidden;
            animation: entryPop 0.35s ease;
        }

        .story-entry::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 15% 20%, rgba(201, 162, 39, 0.12), transparent 40%);
            pointer-events: none;
        }

        .story-entry-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 8px;
        }

        .story-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            border-radius: 20px;
            font-family: 'Cinzel', serif;
            font-size: 0.85em;
            letter-spacing: 0.3px;
            border: 1px solid rgba(0,0,0,0.08);
            background: rgba(0,0,0,0.04);
        }

        .story-time {
            font-size: 0.82em;
            color: var(--ink-light);
            letter-spacing: 0.3px;
            white-space: nowrap;
        }

        .story-entry-text p {
            margin-bottom: 8px;
        }

        .story-entry-text p:last-child {
            margin-bottom: 0;
        }

        .story-entry.narrator {
            background: linear-gradient(135deg, rgba(255,255,255,0.7), rgba(255,255,255,0.35));
            border-left-color: var(--gold);
            font-size: 1.05em;
        }
        .story-entry.narrator .story-badge { background: rgba(201,162,39,0.15); border-color: rgba(201,162,39,0.3); color: var(--gold-dark); }

        .story-entry.player {
            background: linear-gradient(135deg, rgba(30, 58, 95, 0.18), rgba(30, 58, 95, 0.08));
            border-left-color: var(--sapphire);
            font-weight: 600;
        }
        .story-entry.player .story-badge { background: rgba(30,58,95,0.15); border-color: rgba(30,58,95,0.25); color: var(--sapphire); }

        .story-entry.system {
            background: linear-gradient(135deg, rgba(255,255,255,0.95), rgba(222,215,201,0.94));
            border-left-color: #5a4a3c;
            border-left-width: 5px;
            font-style: normal;
            color: #2f241d;
            font-size: 0.97em;
            box-shadow: 0 10px 26px rgba(0,0,0,0.18);
        }
        .story-entry.system .story-badge {
            background: rgba(90,74,60,0.14);
            border-color: rgba(90,74,60,0.35);
            color: #3f2f25;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 700;
        }

        .story-entry.mechanic {
            background: linear-gradient(135deg, rgba(46, 139, 87, 0.18), rgba(46, 139, 87, 0.08));
            border-left-color: var(--emerald);
            font-family: 'Cinzel', serif;
            font-size: 0.95em;
        }
        .story-entry.mechanic .story-badge { background: rgba(46,139,87,0.18); border-color: rgba(46,139,87,0.35); color: var(--emerald); }

        /* Stile per i messaggi di Analisi/Controllo */
        .story-entry.analysis {
            background: #f4f4f4;
            border-left-color: #7f8c8d; /* Grigio */
            color: #555;
            font-family: 'Courier New', monospace; /* Font tecnico */
            font-size: 0.85em;
            padding: 8px 12px;
            margin-bottom: 5px; /* Pi√π compatto */
            box-shadow: none; /* Meno invasivo */
        }
        .story-entry.analysis .story-badge {
            background: #e0e0e0;
            border-color: #ccc;
            color: #555;
        }
        /* Se vuoi NASCONDERLI completamente, togli il commento alla riga sotto: */
        /* .story-entry.analysis { display: none; } */

        .story-entry.dice-roll {
            background: linear-gradient(135deg, rgba(201, 162, 39, 0.22), rgba(201, 162, 39, 0.1));
            border-left-color: var(--gold);
            font-family: 'Cinzel', serif;
        }
        .story-entry.dice-roll .story-badge { background: rgba(201,162,39,0.18); border-color: rgba(201,162,39,0.35); color: var(--gold-dark); }

        .story-entry.memory-update {
            background: linear-gradient(135deg, rgba(107, 46, 155, 0.18), rgba(107, 46, 155, 0.08));
            border-left-color: var(--purple);
            font-size: 0.85em;
        }
        .story-entry.memory-update .story-badge { background: rgba(107,46,155,0.16); border-color: rgba(107,46,155,0.32); color: var(--purple); }

        /* Stile per eventi del mondo - colore teal/ciano distintivo */
        .story-entry.world-event {
            background: linear-gradient(135deg, rgba(0, 139, 139, 0.2), rgba(0, 191, 179, 0.12));
            border-left-color: #008b8b;
            border-left-width: 5px;
            font-style: normal;
            color: #0e3f3f;
            box-shadow: 0 12px 30px rgba(0, 139, 139, 0.18);
            font-weight: 600;
        }
        .story-entry.world-event .story-badge {
            background: rgba(0, 139, 139, 0.18);
            border-color: rgba(0, 139, 139, 0.32);
            color: #0f4e4e;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            font-weight: 700;
        }
        .story-entry.world-event::before {
            content: 'üåç';
            margin-right: 8px;
        }

        /* Stile per azioni NPC autonome */
        .story-entry.npc-action {
            background: linear-gradient(135deg, rgba(255, 165, 0, 0.12), rgba(255, 140, 0, 0.06));
            border-left-color: #ff8c00;
            border-left-width: 3px;
            font-size: 0.9em;
        }
        .story-entry.npc-action .story-badge {
            background: rgba(255, 140, 0, 0.18);
            border-color: rgba(255, 140, 0, 0.35);
            color: #cc7000;
        }

        .story-entry em {
            font-style: italic;
            color: var(--ink-light);
        }

        @keyframes entryPop {
            from { transform: translateY(10px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Suggestions */
        .suggestions-area {
            display: none;
            padding: 10px 15px;
            background: rgba(0,0,0,0.05);
            border-top: 1px solid var(--parchment-dark);
        }

        .suggestions-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .suggestion-btn {
            padding: 8px 14px;
            font-family: 'Crimson Text', serif;
            font-size: 0.9em;
            background: white;
            border: 2px solid var(--gold-dark);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .suggestion-btn:hover {
            background: var(--gold);
            color: white;
            border-color: var(--gold);
        }

        .suggestion-type {
            font-weight: 600;
            margin-right: 5px;
        }

        /* Input Area */
        .input-area {
            padding: 10px 15px;
            background: linear-gradient(180deg, var(--parchment-dark), #c4b490);
            border-top: 2px solid var(--gold-dark);
            flex-shrink: 0;
            box-shadow: 0 -6px 16px rgba(0,0,0,0.18);
        }

        .quick-actions {
            display: flex;
            gap: 6px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .quick-btn {
            padding: 6px 12px;
            font-family: 'Cinzel', serif;
            font-size: 0.85em;
            background: white;
            border: 2px solid var(--ink-light);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .quick-btn:hover, .quick-btn:active {
            background: var(--ink);
            color: white;
        }

        /* Action Buttons Bar */
        .action-bar {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
            flex-wrap: nowrap;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding-bottom: 2px;
        }
        .action-bar::-webkit-scrollbar { display: none; }

        .action-btn {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 8px 14px;
            font-family: 'Cinzel', serif;
            font-size: 0.8em;
            background: linear-gradient(180deg, #fff, #f0ead6);
            border: 2px solid var(--gold-dark);
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
            flex-shrink: 0;
            color: var(--ink);
            font-weight: 600;
        }
        .action-btn:active {
            transform: scale(0.95);
            background: var(--gold);
            color: white;
        }
        .action-btn:disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        .action-btn .action-cost {
            font-size: 0.75em;
            opacity: 0.7;
            font-weight: 400;
        }
        .action-btn.rest { border-color: #1565c0; }
        .action-btn.rest:active { background: #1565c0; }
        .action-btn.eat { border-color: #f57c00; }
        .action-btn.eat:active { background: #f57c00; }
        .action-btn.heal { border-color: #c62828; }
        .action-btn.heal:active { background: #c62828; }
        .action-btn.wait { border-color: #7b1fa2; }
        .action-btn.wait:active { background: #7b1fa2; }
        .action-btn.train { border-color: #2e7d32; }
        .action-btn.train:active { background: #2e7d32; }

        .input-row {
            display: flex;
            gap: 10px;
        }

        .input-row input {
            flex: 1;
            padding: 12px 15px;
            font-family: 'Crimson Text', serif;
            font-size: 1em;
            border: 2px solid var(--ink-light);
            border-radius: 25px;
            background: white;
            color: var(--ink);
        }

        .input-row input:focus {
            outline: none;
            border-color: var(--gold);
        }

        .input-row button {
            padding: 12px 20px;
            font-family: 'Cinzel', serif;
            font-size: 1em;
            background: linear-gradient(180deg, var(--gold), var(--gold-dark));
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .input-row button:hover:not(:disabled) {
            transform: scale(1.05);
        }

        .input-row button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ==================== MODALS ==================== */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 200;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--parchment);
            border-radius: 15px;
            max-width: 500px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 10px 50px rgba(0,0,0,0.5);
            border: 3px solid var(--gold);
        }

        .modal-header {
            padding: 15px 20px;
            background: linear-gradient(180deg, var(--ink), #1a0f08);
            color: var(--gold);
            font-family: 'Cinzel', serif;
            font-size: 1.3em;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--parchment);
            font-size: 1.5em;
            cursor: pointer;
            padding: 5px;
            line-height: 1;
        }

        .modal-body {
            padding: 20px;
        }

        /* Forms */
        .form-group {
            margin-bottom: 15px;
        }

        .form-label {
            display: block;
            font-family: 'Cinzel', serif;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--ink);
        }

        .form-input, .form-select, .form-textarea {
            width: 100%;
            padding: 10px 12px;
            font-family: 'Crimson Text', serif;
            font-size: 1em;
            border: 2px solid var(--ink-light);
            border-radius: 8px;
            background: white;
        }

        .form-textarea {
            min-height: 100px;
            resize: vertical;
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            font-family: 'Cinzel', serif;
            font-size: 1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn.primary {
            background: linear-gradient(180deg, var(--gold), var(--gold-dark));
            color: white;
        }

        .btn.secondary {
            background: linear-gradient(180deg, var(--sapphire), #0f2540);
            color: white;
        }

        .btn.danger {
            background: linear-gradient(180deg, var(--blood), #5a0000);
            color: white;
        }

        .btn.special {
            background: linear-gradient(180deg, var(--purple), #4a1e6b);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
        }

        .btn-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        /* Character */
        .char-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .char-portrait {
            font-size: 4em;
            margin-bottom: 5px;
        }

        .char-name {
            font-family: 'Cinzel', serif;
            font-size: 1.5em;
            color: var(--ink);
        }

        .char-class {
            color: var(--ink-light);
            font-style: italic;
        }

        .stat-group {
            margin-bottom: 15px;
        }

        .stat-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .stat-label {
            width: 80px;
            font-weight: 600;
        }

        .stat-bar {
            flex: 1;
            height: 22px;
            background: rgba(0,0,0,0.18);
            border-radius: 12px;
            overflow: hidden;
            margin-right: 12px;
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.45);
        }

        .stat-bar-fill {
            height: 100%;
            border-radius: 12px;
            transition: width 0.3s ease;
            box-shadow: inset 0 0 6px rgba(255,255,255,0.22);
        }

        .stat-bar-fill.health { background: linear-gradient(90deg, #c62828, #ef5350); }
        .stat-bar-fill.mana { background: linear-gradient(90deg, #6a1b9a, #ab47bc); }
        .stat-bar-fill.stamina { background: linear-gradient(90deg, #1565c0, #42a5f5); }
        .stat-bar-fill.hunger { background: linear-gradient(90deg, #f57c00, #ffb74d); }
        .stat-bar-fill.exp { background: linear-gradient(90deg, #2e7d32, #66bb6a); }
        .stat-bar-fill.reputation { background: linear-gradient(90deg, #fdd835, #f57f17); }
        .stat-bar-fill.morale { background: linear-gradient(90deg, #00897b, #26a69a); }
        .stat-bar-fill.respect { background: linear-gradient(90deg, #5d4037, #8d6e63); }
        .stat-bar-fill.honor { background: linear-gradient(90deg, #8d6e63, #ffab91); }
        .stat-bar-fill.fame { background: linear-gradient(90deg, #3949ab, #7e57c2); }
        .stat-bar-fill.cover { background: linear-gradient(90deg, #4527a0, #7e57c2); }

        .stat-value {
            width: 70px;
            text-align: right;
            font-family: 'Cinzel', serif;
            font-size: 0.9em;
        }

        /* Attributes */
        .attrs-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .attr-box {
            background: rgba(0,0,0,0.05);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .attr-name {
            font-family: 'Cinzel', serif;
            font-size: 0.8em;
            color: var(--ink-light);
        }

        .attr-value {
            font-size: 1.5em;
            font-weight: bold;
        }

        .attr-mod {
            font-size: 0.85em;
            color: var(--emerald);
        }

        /* Skills & Abilities */
        .skills-list, .abilities-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .skill-item, .ability-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: rgba(0,0,0,0.05);
            border-radius: 5px;
        }

        .skill-bonus { color: var(--emerald); }
        .skill-malus { color: var(--blood); }

        .ability-item {
            flex-direction: column;
            gap: 4px;
        }

        .ability-name {
            font-weight: 600;
            color: var(--purple);
        }

        .ability-desc {
            font-size: 0.85em;
            color: var(--ink-light);
        }

        /* Inventory */
        .inv-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .inv-gold {
            font-family: 'Cinzel', serif;
            font-size: 1.2em;
        }

        .inv-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 8px;
            margin-bottom: 15px;
            align-content: start;
        }
        .inv-list {
            margin-top: 8px;
            border-top: 1px solid rgba(0,0,0,0.1);
            padding-top: 8px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .inv-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95em;
            padding: 6px 8px;
            background: rgba(0,0,0,0.03);
            border-radius: 6px;
        }
        .inv-row-name {
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
        }
        .inv-row-count {
            color: var(--ink-light);
            font-weight: 600;
        }

        .inv-slot {
            aspect-ratio: 1;
            background: rgba(0,0,0,0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .inv-slot:hover {
            background: rgba(0,0,0,0.2);
        }

        .inv-slot .count {
            position: absolute;
            bottom: 2px;
            right: 4px;
            font-size: 0.4em;
            background: var(--ink);
            color: white;
            padding: 2px 5px;
            border-radius: 10px;
        }

        /* Special Items */
        .special-items {
            margin-top: 15px;
            border-top: 1px solid var(--parchment-dark);
            padding-top: 15px;
        }

        .special-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: linear-gradient(135deg, rgba(107, 46, 155, 0.1), rgba(107, 46, 155, 0.05));
            border-radius: 8px;
            margin-bottom: 8px;
            border-left: 3px solid var(--purple);
        }

        .special-item-icon {
            font-size: 1.5em;
        }

        .special-item-info {
            flex: 1;
        }

        .special-item-name {
            font-weight: 600;
        }

        .special-item-desc {
            font-size: 0.85em;
            color: var(--ink-light);
        }

        /* Properties & Abilities recap */
        .property-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(201, 162, 39, 0.12), rgba(201, 162, 39, 0.04));
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: 10px;
            margin-bottom: 10px;
        }
        .property-item.ability {
            background: linear-gradient(135deg, rgba(46, 139, 87, 0.12), rgba(46, 139, 87, 0.05));
        }
        .property-header {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .property-icon { font-size: 1.6em; }
        .property-title { flex: 1; }
        .property-name { font-weight: 700; font-family: 'Cinzel', serif; font-size: 1.05em; }
        .property-type { font-size: 0.75em; color: var(--ink-light); text-transform: uppercase; }
        .property-condition-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }
        .property-info { flex: 1; }
        .property-desc { font-size: 0.9em; color: var(--ink); margin-bottom: 8px; }
        .property-meta { font-size: 0.85em; color: var(--ink-light); font-style: italic; margin-top: 8px; }
        
        .property-stats {
            display: flex;
            flex-direction: column;
            gap: 6px;
            background: rgba(0,0,0,0.03);
            padding: 10px;
            border-radius: 8px;
        }
        .property-stat-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85em;
        }
        .property-stat-row .stat-label {
            flex: 1;
            color: var(--ink-light);
        }
        .property-stat-row .stat-value {
            font-weight: 600;
            font-family: 'Cinzel', serif;
        }
        .property-condition-bar {
            flex: 1;
            height: 8px;
            background: rgba(0,0,0,0.1);
            border-radius: 4px;
            overflow: hidden;
            max-width: 100px;
        }
        .property-condition-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .properties-summary {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(201, 162, 39, 0.2), rgba(201, 162, 39, 0.08));
            border-radius: 10px;
            margin-bottom: 12px;
            border: 1px solid rgba(201, 162, 39, 0.3);
        }
        .properties-summary .summary-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
            flex: 1;
            min-width: 120px;
        }
        .properties-summary .summary-item span {
            font-size: 0.75em;
            color: var(--ink-light);
        }
        .properties-summary .summary-item strong {
            font-family: 'Cinzel', serif;
            font-size: 1.1em;
        }

        /* Property Inventory Styles */
        .property-inventory-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px dashed rgba(0,0,0,0.15);
        }
        .property-inventory-header {
            font-family: 'Cinzel', serif;
            font-weight: 600;
            font-size: 0.95em;
            color: var(--ink);
            margin-bottom: 10px;
        }
        .property-category-block {
            margin-bottom: 10px;
        }
        .property-category-heading {
            font-size: 0.85em;
            font-weight: 600;
            color: var(--ink-light);
            margin-bottom: 6px;
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .property-category-count {
            font-weight: normal;
            font-size: 0.9em;
            opacity: 0.8;
        }
        .property-inv-grid {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding-left: 8px;
        }
        .property-inv-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: rgba(255,255,255,0.6);
            border: 1px solid rgba(0,0,0,0.08);
            border-radius: 8px;
            font-size: 0.9em;
        }
        .property-inv-icon {
            font-size: 1.2em;
        }
        .property-inv-info {
            flex: 1;
            min-width: 0;
        }
        .property-inv-name {
            font-weight: 600;
            color: var(--ink);
        }
        .property-inv-meta {
            font-size: 0.8em;
            color: var(--ink-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .property-inv-qty {
            font-family: 'Cinzel', serif;
            font-weight: 600;
            color: var(--purple);
            background: rgba(101, 67, 133, 0.1);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.85em;
        }

        /* World Memory Modal */
        .memory-section {
            margin-bottom: 20px;
        }

        .memory-section-title {
            font-family: 'Cinzel', serif;
            font-size: 1.1em;
            color: var(--purple);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .memory-card {
            background: white;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 3px solid var(--gold);
        }

        .memory-card.npc { border-left-color: var(--sapphire); }
        .memory-card.location { border-left-color: var(--emerald); }
        .memory-card.quest { border-left-color: var(--orange); }
        .memory-card.quest.completed { border-left-color: var(--emerald); opacity: 0.7; }
        .memory-card.event { border-left-color: var(--purple); }

        .memory-card-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .memory-card-desc {
            font-size: 0.9em;
            color: var(--ink-light);
        }

        .memory-card-meta {
            font-size: 0.8em;
            color: var(--ink-light);
            margin-top: 4px;
            font-style: italic;
        }

        .memory-empty {
            color: var(--ink-light);
            font-style: italic;
            text-align: center;
            padding: 20px;
        }

        /* Stories/Saves Cards */
        .story-card, .save-slot {
            padding: 15px;
            background: white;
            border-radius: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .story-card:hover, .save-slot:hover {
            transform: translateY(-2px);
        }

        .story-card.selected, .save-slot.selected {
            border-color: var(--gold);
            background: rgba(201, 162, 39, 0.1);
        }

        .story-card-title, .save-slot-title {
            font-family: 'Cinzel', serif;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .story-card-desc, .save-slot-info {
            font-size: 0.9em;
            color: var(--ink-light);
        }

        /* Creation Grid */
        .creation-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .creation-option {
            background: white;
            border-radius: 10px;
            padding: 15px 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
        }

        .creation-option:hover {
            transform: translateY(-2px);
        }

        .creation-option.selected {
            border-color: var(--gold);
            background: rgba(201, 162, 39, 0.1);
        }

        .creation-icon {
            font-size: 2em;
            margin-bottom: 5px;
        }

        .creation-name {
            font-family: 'Cinzel', serif;
            font-size: 0.85em;
        }

        /* Dice */
        .dice-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .dice-btn {
            padding: 20px;
            font-family: 'Cinzel', serif;
            font-size: 1.3em;
            background: linear-gradient(180deg, white, #f0f0f0);
            border: 3px solid var(--ink);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .dice-btn:hover, .dice-btn:active {
            transform: scale(1.05);
            border-color: var(--gold);
        }

        .dice-result {
            text-align: center;
            font-family: 'Cinzel', serif;
            font-size: 1.5em;
            padding: 20px;
            background: rgba(0,0,0,0.05);
            border-radius: 10px;
        }

        /* Wait Modal */
        .wait-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .wait-btn {
            padding: 15px;
            font-family: 'Cinzel', serif;
            background: white;
            border: 2px solid var(--ink-light);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .wait-btn:hover {
            border-color: var(--gold);
            background: rgba(201, 162, 39, 0.1);
        }

        .wait-custom {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .wait-custom input {
            width: 80px;
            padding: 10px;
            font-size: 1.2em;
            text-align: center;
            border: 2px solid var(--ink-light);
            border-radius: 8px;
        }

        /* Loading */
        .loading-dots::after {
            content: '';
            animation: dots 1.5s infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 25px;
            border-radius: 25px;
            font-family: 'Cinzel', serif;
            z-index: 300;
            animation: notifyIn 0.3s ease, notifyOut 0.3s ease 2.7s;
        }

        .notification.success {
            background: var(--emerald);
            color: white;
        }

        .notification.error {
            background: var(--blood);
            color: white;
        }

        .notification.info {
            background: var(--sapphire);
            color: white;
        }

        @keyframes notifyIn {
            from { opacity: 0; transform: translate(-50%, -20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }

        @keyframes notifyOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Tabs */
        .tabs {
            display: flex;
            border-bottom: 2px solid var(--parchment-dark);
            margin-bottom: 15px;
        }

        .tab {
            padding: 10px 20px;
            font-family: 'Cinzel', serif;
            background: none;
            border: none;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            transition: all 0.2s ease;
        }

        .tab.active {
            border-bottom-color: var(--gold);
            color: var(--gold-dark);
        }

        .tab:hover:not(.active) {
            background: rgba(0,0,0,0.05);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Memory Stats */
        .memory-stats {
            display: flex;
            gap: 15px;
            padding: 10px;
            background: rgba(0,0,0,0.05);
            border-radius: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .memory-stat {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9em;
        }

        .memory-stat-icon {
            font-size: 1.2em;
        }

        /* ==================== IMPROVED INVENTORY CSS ==================== */
        .wide-modal {
            max-width: 700px !important; /* Allarga il modale */
        }

        .inv-container {
            display: flex;
            gap: 20px;
            min-height: 300px;
        }

        .inv-left-col {
            flex: 1;
            border-right: 1px solid rgba(0,0,0,0.1);
            padding-right: 15px;
            max-height: 420px;
            overflow-y: auto;
        }

        .inv-right-col {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Griglia pi√π compatta */
        .inv-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 8px;
            align-content: start;
        }

        .inv-slot {
            aspect-ratio: 1;
            background: rgba(0,0,0,0.05);
            border: 2px solid transparent;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        .inv-slot:hover {
            background: rgba(0,0,0,0.1);
            border-color: var(--gold-dark);
        }

        .inv-slot.selected {
            background: rgba(201, 162, 39, 0.2);
            border-color: var(--gold);
            box-shadow: 0 0 10px rgba(201, 162, 39, 0.3);
            transform: scale(1.05);
        }

        /* Dettagli Oggetto */
        .item-details-empty {
            text-align: center;
            color: var(--ink-light);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-style: italic;
        }
        
        .empty-icon { font-size: 3em; margin-bottom: 10px; opacity: 0.5; }

        .item-card {
            background: white;
            border: 1px solid var(--parchment-dark);
            border-radius: 10px;
            padding: 15px;
            height: 100%;
            display: flex;
            flex-direction: column;
            animation: fadeIn 0.3s ease;
        }

        .item-card-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            border-bottom: 2px solid var(--gold);
            padding-bottom: 10px;
        }

        .item-big-icon {
            font-size: 3em;
            background: var(--parchment);
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            border: 2px solid var(--ink);
        }

        .item-title-block h3 {
            font-family: 'Cinzel', serif;
            font-size: 1.2em;
            color: var(--ink);
            margin-bottom: 4px;
        }

        .item-type-badge {
            font-size: 0.75em;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: white;
            background: var(--ink-light);
            padding: 2px 8px;
            border-radius: 10px;
            display: inline-block;
        }

        .item-type-badge.consumable { background: var(--emerald); }
        .item-type-badge.weapon { background: var(--blood); }
        .item-type-badge.gear { background: var(--sapphire); }

        .item-description {
            font-size: 0.95em;
            line-height: 1.5;
            color: var(--ink);
            flex: 1;
            margin-bottom: 15px;
            font-style: italic;
        }

        .item-value {
            font-size: 0.95em;
            color: var(--ink-light);
            margin: -5px 0 12px 0;
            font-weight: 600;
        }

        .item-stats {
            background: rgba(0,0,0,0.03);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 15px;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            margin-bottom: 4px;
        }

        .item-actions {
            margin-top: auto;
        }

        .btn-use {
            width: 100%;
            padding: 12px;
            font-size: 1.1em;
        }

        /* ==================== MOBILE RESPONSIVE ==================== */
        @media (max-width: 900px) {
            .game-topbar {
                padding: 6px 6px;
                gap: 4px;
            }
            .topbar-row {
                flex-wrap: wrap;
                gap: 4px;
            }
            .topbar-buttons {
                gap: 3px;
            }
            .topbar-btn {
                padding: 6px 10px;
                font-size: 1em;
                min-width: 34px;
                border-radius: 10px;
            }
            .time-display {
                padding: 4px 10px;
                gap: 6px;
                flex: 1;
                min-width: 0;
            }
            .time-icon { font-size: 1.1em; }
            .time-main { font-size: 0.85em; }
            .time-sub { font-size: 0.68em; }
            .time-location { font-size: 0.65em; }
            .mini-stats {
                width: 100%;
                justify-content: space-between;
                gap: 6px;
            }
            .mini-bar {
                flex: 1;
                min-width: 0;
                height: 14px;
            }
            .mini-bar::before { left: 6px; transform: none; font-size: 0.62em; }
            .mini-bar::after { font-size: 0.62em; right: 4px; }
            .topbar-info-panels {
                width: 100%;
                gap: 4px;
            }
            .info-panel {
                padding: 4px 8px;
                min-width: 0;
                flex: 1;
            }
            .info-label { font-size: 0.6em; }
            .info-value { font-size: 0.7em; }
            .info-icon { font-size: 0.9em; }
            .story-container { overflow: visible; }
            .story-scroll {
                padding: 10px 10px 100px;
                -webkit-overflow-scrolling: touch;
            }
            .story-entry {
                padding: 10px 12px 8px;
                font-size: 0.98em;
                line-height: 1.65;
            }
            .input-area {
                padding: 8px 8px calc(8px + env(safe-area-inset-bottom));
                position: sticky;
                bottom: 0;
                left: 0;
                right: 0;
                background: linear-gradient(180deg, rgba(212,196,160,0.97), rgba(196,180,144,0.95));
                border-top-width: 1px;
                backdrop-filter: blur(8px);
                -webkit-backdrop-filter: blur(8px);
                box-shadow: 0 -8px 20px rgba(0,0,0,0.2);
            }
            .action-bar {
                gap: 5px;
                margin-bottom: 6px;
            }
            .action-btn {
                padding: 7px 11px;
                font-size: 0.75em;
            }
            .quick-actions {
                gap: 5px;
                flex-wrap: nowrap;
                overflow-x: auto;
                padding-bottom: 4px;
                margin-bottom: 6px;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .quick-actions::-webkit-scrollbar { display: none; }
            .quick-btn {
                padding: 5px 10px;
                font-size: 0.78em;
            }
            .input-row {
                gap: 6px;
                align-items: center;
                background: rgba(255,255,255,0.94);
                padding: 6px 8px;
                border-radius: 14px;
                border: 1px solid rgba(0,0,0,0.08);
                box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            }
            .input-row input {
                font-size: 1em;
                padding: 10px 12px;
                border-radius: 20px;
            }
            .input-row button {
                min-width: 50px;
                padding: 10px 16px;
                font-size: 0.9em;
            }
            .suggestions-area { padding: 8px 10px; }
            .suggestion-btn { padding: 6px 10px; font-size: 0.85em; }
        }

        @media (max-width: 600px) {
            body { font-size: 14px; }
            .home-container { padding: 0 10px; }
            .home-title { font-size: 1.8em; }
            .home-subtitle { font-size: 0.85em; }
            .home-btn { padding: 12px 18px; font-size: 0.95em; }
            .game-topbar { padding: 4px 4px; gap: 3px; }
            .topbar-btn {
                padding: 5px 8px;
                font-size: 0.9em;
                min-width: 30px;
                border-radius: 8px;
            }
            .time-display {
                padding: 3px 8px;
                border-radius: 12px;
            }
            .time-block { gap: 0; }
            .time-main { font-size: 0.8em; }
            .time-sub { font-size: 0.6em; }
            .time-location { font-size: 0.58em; }
            .mini-bar {
                height: 12px;
            }
            .mini-bar::before { display: none; }
            .mini-bar::after { font-size: 0.58em; }
            .topbar-info-panels { display: none; }
            .story-scroll { padding: 8px 8px 110px; }
            .story-entry {
                padding: 8px 10px 6px;
                font-size: 0.93em;
                line-height: 1.6;
                border-radius: 8px;
            }
            .story-entry-head {
                flex-direction: column;
                align-items: flex-start;
                gap: 2px;
            }
            .story-time { font-size: 0.72em; }
            .action-bar {
                gap: 4px;
                margin-bottom: 5px;
            }
            .action-btn {
                padding: 6px 10px;
                font-size: 0.72em;
                border-width: 1.5px;
                border-radius: 16px;
            }
            .action-btn .action-cost { display: none; }
            .quick-actions { gap: 4px; margin-bottom: 5px; }
            .quick-btn {
                padding: 4px 8px;
                font-size: 0.72em;
                border-radius: 12px;
            }
            .input-area {
                padding: 6px 6px calc(6px + env(safe-area-inset-bottom));
            }
            .input-row {
                padding: 5px 6px;
                gap: 5px;
                border-radius: 12px;
            }
            .input-row input {
                padding: 9px 10px;
                font-size: 0.95em;
                border-radius: 16px;
            }
            .input-row button {
                min-width: 44px;
                padding: 9px 14px;
                font-size: 0.85em;
                border-radius: 16px;
            }
            .modal {
                max-height: 92vh;
                border-radius: 12px;
                border-width: 2px;
            }
            .modal-header { padding: 12px 15px; font-size: 1em; }
            .modal-body { padding: 12px 15px; }
            .inv-container { flex-direction: column; }
            .inv-left-col {
                border-right: none;
                border-bottom: 1px solid rgba(0,0,0,0.1);
                padding-bottom: 12px;
            }
            .inv-grid {
                grid-template-columns: repeat(auto-fill, minmax(52px, 1fr));
                gap: 4px;
            }
            .inv-slot { width: 52px; height: 52px; font-size: 1.3em; }
            .equip-slots { flex-direction: column; }
            .equip-slot { padding: 8px 10px; }
            .status-effects { gap: 4px; }
            .status-effect { padding: 2px 6px; font-size: 0.68em; }
        }

        @media (max-width: 380px) {
            .game-topbar { padding: 3px 3px; gap: 2px; }
            .topbar-btn { padding: 4px 6px; font-size: 0.85em; min-width: 28px; }
            .time-display { padding: 2px 6px; }
            .time-main { font-size: 0.75em; }
            .mini-bar { height: 10px; }
            .action-btn { padding: 5px 8px; font-size: 0.68em; }
            .quick-btn { padding: 3px 6px; font-size: 0.68em; }
            .input-row input { padding: 8px; font-size: 0.9em; }
            .input-row button { padding: 8px 12px; min-width: 40px; }
            .story-entry { font-size: 0.88em; padding: 6px 8px 5px; }
        }

        /* ==================== EQUIPMENT SYSTEM ==================== */
        .equipment-section {
            margin-bottom: 20px;
            padding: 12px;
            background: linear-gradient(135deg, rgba(201,162,39,0.08), rgba(201,162,39,0.03));
            border-radius: 10px;
            border: 1px solid rgba(201,162,39,0.2);
        }
        .equipment-section h4 {
            margin-bottom: 10px;
            font-family: 'Cinzel', serif;
            color: var(--gold-dark);
        }
        .equip-slots {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        .equip-slot {
            background: rgba(255,255,255,0.8);
            border: 2px dashed rgba(0,0,0,0.15);
            border-radius: 10px;
            padding: 10px;
            text-align: center;
            min-height: 90px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.2s;
            cursor: default;
        }
        .equip-slot.filled {
            border-style: solid;
            border-color: var(--gold);
            background: rgba(201,162,39,0.1);
            cursor: pointer;
        }
        .equip-slot.filled:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(201,162,39,0.3);
        }
        .equip-slot-icon { font-size: 1.8em; }
        .equip-slot-label {
            font-family: 'Cinzel', serif;
            font-size: 0.7em;
            text-transform: uppercase;
            color: var(--ink-light);
            letter-spacing: 0.5px;
        }
        .equip-slot-name {
            font-size: 0.8em;
            font-weight: 600;
            color: var(--ink);
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .equip-slot-bonus {
            font-size: 0.7em;
            color: var(--emerald);
        }
        .equip-badge {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 0.35em;
            background: var(--gold);
            color: #fff;
            padding: 1px 4px;
            border-radius: 6px;
            font-weight: 700;
        }

        /* ==================== LEVEL UP MODAL ==================== */
        .levelup-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 400;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .levelup-overlay.active { display: flex; }
        .levelup-content {
            background: linear-gradient(135deg, var(--parchment), #e8d8b8);
            border: 3px solid var(--gold);
            border-radius: 15px;
            max-width: 450px;
            width: 100%;
            padding: 25px;
            text-align: center;
            animation: levelupPop 0.5s ease;
            box-shadow: 0 0 60px rgba(201,162,39,0.4);
        }
        @keyframes levelupPop {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }
        .levelup-title {
            font-family: 'Cinzel', serif;
            font-size: 2em;
            color: var(--gold-dark);
            margin-bottom: 5px;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.2);
        }
        .levelup-subtitle {
            color: var(--ink-light);
            margin-bottom: 20px;
            font-size: 0.95em;
        }
        .levelup-points {
            font-family: 'Cinzel', serif;
            font-size: 1.1em;
            color: var(--gold-dark);
            margin-bottom: 15px;
        }
        .levelup-attrs {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }
        .levelup-attr {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255,255,255,0.6);
            padding: 10px 12px;
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .levelup-attr.boosted {
            border-color: var(--gold);
            background: rgba(201,162,39,0.15);
        }
        .levelup-attr-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .levelup-attr-name {
            font-family: 'Cinzel', serif;
            font-size: 0.85em;
            font-weight: 600;
        }
        .levelup-attr-val {
            font-size: 0.8em;
            color: var(--ink-light);
        }
        .levelup-attr button {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid var(--gold-dark);
            background: white;
            font-size: 1.2em;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .levelup-attr button:hover:not(:disabled) {
            background: var(--gold);
            color: white;
        }
        .levelup-attr button:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* ==================== JOURNAL / DIARIO ==================== */
        .journal-entries {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 12px;
        }
        .journal-entry {
            padding: 10px 12px;
            background: rgba(255,255,255,0.7);
            border-left: 3px solid var(--gold-dark);
            border-radius: 6px;
            margin-bottom: 8px;
            position: relative;
        }
        .journal-entry-meta {
            font-size: 0.75em;
            color: var(--ink-light);
            margin-bottom: 4px;
        }
        .journal-entry-text {
            font-size: 0.9em;
            line-height: 1.5;
        }
        .journal-entry-delete {
            position: absolute;
            top: 5px;
            right: 8px;
            background: none;
            border: none;
            cursor: pointer;
            font-size: 0.8em;
            color: var(--ink-light);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .journal-entry:hover .journal-entry-delete { opacity: 1; }
        .journal-input-area {
            display: flex;
            gap: 8px;
        }
        .journal-input-area textarea {
            flex: 1;
            padding: 10px;
            border: 2px solid var(--ink-light);
            border-radius: 8px;
            font-family: 'Crimson Text', serif;
            font-size: 0.95em;
            resize: none;
            min-height: 60px;
        }
        .journal-input-area textarea:focus {
            outline: none;
            border-color: var(--gold);
        }

        /* ==================== LOCATION INDICATOR ==================== */
        .time-location {
            font-size: 0.7em;
            color: var(--gold);
            display: flex;
            align-items: center;
            gap: 3px;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* ==================== GAME OVER OVERLAY ==================== */
        .gameover-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.92);
            z-index: 500;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        .gameover-overlay.active { display: flex; }
        .gameover-content {
            text-align: center;
            max-width: 400px;
            animation: fadeIn 1s ease;
        }
        .gameover-skull {
            font-size: 5em;
            animation: float 3s ease-in-out infinite;
        }
        .gameover-title {
            font-family: 'Cinzel', serif;
            font-size: 2.5em;
            color: var(--blood);
            text-shadow: 0 0 30px rgba(139,0,0,0.5);
            margin: 15px 0 10px;
        }
        .gameover-text {
            color: var(--parchment-dark);
            font-size: 1.1em;
            margin-bottom: 30px;
            line-height: 1.6;
        }
        .gameover-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* ==================== STATUS EFFECTS ==================== */
        .status-effects {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .status-effect {
            font-size: 0.75em;
            padding: 2px 6px;
            border-radius: 10px;
            animation: statusPulse 2s ease-in-out infinite;
        }
        .status-effect.danger {
            background: rgba(139,0,0,0.2);
            color: #ff4444;
        }
        .status-effect.warning {
            background: rgba(255,140,0,0.2);
            color: #ff8c00;
        }
        @keyframes statusPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* ==================== STAT FLASH ANIMATION ==================== */
        .stat-flash {
            animation: statFlash 0.6s ease;
        }
        @keyframes statFlash {
            0% { filter: brightness(1); }
            30% { filter: brightness(1.5); }
            100% { filter: brightness(1); }
        }
    </style>
</head>
<body>
    <!-- HOME SCREEN -->
    <div class="screen active" id="home-screen">
        <div class="home-container">
            <div class="home-logo">üêâ</div>
            <h1 class="home-title">Cronache del Destino</h1>
            <p class="home-subtitle">Un'avventura narrata dall'IA ‚Ä¢ v7.0</p>

            <div class="home-menu">
                <button class="home-btn primary" id="btn-continue" disabled>‚ñ∂Ô∏è Continua</button>
                <button class="home-btn" id="btn-new-game">üìú Nuova Partita</button>
                <button class="home-btn" id="btn-load-game">üíæ Carica</button>

                <div class="home-section">
                    <h3 class="home-section-title">üìö Gestione</h3>
                    <button class="home-btn" id="btn-stories">‚úèÔ∏è Storie</button>
                    <button class="home-btn" id="btn-settings">‚öôÔ∏è Impostazioni</button>
                </div>
            </div>
        </div>
    </div>

    <!-- GAME SCREEN -->
    <div class="screen" id="game-screen">
        <div class="game-topbar">
            <div class="topbar-row">
                <div class="topbar-buttons">
                    <button class="topbar-btn danger" id="btn-exit" title="Esci">üö™</button>
                    <button class="topbar-btn" id="btn-save-quick" title="Salva">üíæ</button>
                    <button class="topbar-btn" id="btn-dice" title="Dadi">üé≤</button>
                </div>

                <div class="time-display">
                    <span class="time-icon" id="time-icon">?~????</span>
                    <div class="time-block">
                        <span class="time-main" id="time-text">08:00</span>
                        <span class="time-sub" id="time-date">Luned? 1 Marzo (Primavera)</span>
                        <span class="time-location" id="time-location">üìç Sconosciuto</span>
                    </div>
                </div>

                <div class="topbar-buttons">
                    <button class="topbar-btn" id="btn-inventory" title="Inventario">üéí</button>
                    <button class="topbar-btn" id="btn-character" title="Personaggio">üë§</button>
                    <button class="topbar-btn special" id="btn-memory" title="Memoria del Mondo">üß†</button>
                </div>
            </div>

            <div class="topbar-row">
                <div class="mini-stats">
                    <div class="mini-bar" data-label="HP" data-value="--">
                        <div class="mini-bar-fill health" id="mini-health" style="width: 100%"></div>
                    </div>
                    <div class="mini-bar" data-label="EN" data-value="--">
                        <div class="mini-bar-fill stamina" id="mini-stamina" style="width: 100%"></div>
                    </div>
                    <div class="mini-bar" data-label="üçñ" data-value="--">
                        <div class="mini-bar-fill hunger" id="mini-hunger" style="width: 100%"></div>
                    </div>
                    <div class="status-effects" id="status-effects"></div>
                </div>

                <div class="topbar-info-panels">
                    <div class="info-panel finances" id="panel-finances" title="Clicca per dettagli finanziari">
                        <span class="info-icon">üí∞</span>
                        <div class="info-content">
                            <span class="info-label">Finanze</span>
                            <span class="info-value" id="finances-summary">--</span>
                        </div>
                    </div>
                    <div class="info-panel family" id="panel-family" title="Clicca per gestire famiglia">
                        <span class="info-icon">üë®‚Äçüë©‚Äçüëß</span>
                        <div class="info-content">
                            <span class="info-label">Famiglia</span>
                            <span class="info-value" id="family-summary">--</span>
                        </div>
                    </div>
                    <div class="info-panel employees" id="panel-employees" title="Clicca per gestire dipendenti">
                        <span class="info-icon">üë∑</span>
                        <div class="info-content">
                            <span class="info-label">Dipendenti</span>
                            <span class="info-value" id="employees-summary">--</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="story-container">
            <div class="story-scroll" id="story-scroll"></div>

            <div class="suggestions-area" id="suggestions-area">
                <div class="suggestions-list" id="suggestions-list"></div>
            </div>

            <div class="input-area">
                <div class="action-bar" id="action-bar">
                    <button class="action-btn rest" id="btn-rest" title="Riposa 8 ore">üò¥ Riposa</button>
                    <button class="action-btn eat" id="btn-eat" title="Mangia">üçñ Mangia</button>
                    <button class="action-btn heal" id="btn-heal" title="Curati">‚ù§Ô∏è‚Äçü©π Cura</button>
                    <button class="action-btn wait" id="btn-wait" title="Aspetta">‚è∞ Aspetta</button>
                    <button class="action-btn train" id="btn-train" title="Allenati">üí™ Allenati</button>
                </div>
                <div class="quick-actions" id="quick-actions"></div>
                <div class="input-row">
                    <input type="text" id="action-input" placeholder="Cosa fai?" autocomplete="off">
                    <button id="btn-send">‚û§</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Character Modal -->
    <div class="modal-overlay" id="modal-character">
        <div class="modal">
            <div class="modal-header">
                üë§ Personaggio
                <button class="modal-close" data-close="modal-character">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="char-header">
                    <div class="char-portrait" id="char-portrait">‚öîÔ∏è</div>
                    <div class="char-name" id="char-name">Nome</div>
                    <div class="char-class" id="char-class">Classe</div>
                </div>

                <div class="equipment-section">
                    <h4>üó°Ô∏è Equipaggiamento</h4>
                    <div class="equip-slots" id="equip-slots">
                        <div class="equip-slot" id="equip-weapon" onclick="unequipSlot('weapon')">
                            <div class="equip-slot-icon">‚öîÔ∏è</div>
                            <div class="equip-slot-label">Arma</div>
                            <div class="equip-slot-name">Vuoto</div>
                        </div>
                        <div class="equip-slot" id="equip-armor" onclick="unequipSlot('armor')">
                            <div class="equip-slot-icon">üõ°Ô∏è</div>
                            <div class="equip-slot-label">Armatura</div>
                            <div class="equip-slot-name">Vuoto</div>
                        </div>
                        <div class="equip-slot" id="equip-accessory" onclick="unequipSlot('accessory')">
                            <div class="equip-slot-icon">üíç</div>
                            <div class="equip-slot-label">Accessorio</div>
                            <div class="equip-slot-name">Vuoto</div>
                        </div>
                    </div>
                </div>

                <div class="stat-group">
                    <div class="stat-row">
                        <span class="stat-label">‚ù§Ô∏è Salute</span>
                        <div class="stat-bar"><div class="stat-bar-fill health" id="stat-health"></div></div>
                        <span class="stat-value" id="stat-health-text">0/0</span>
                    </div>
                    <div class="stat-row" id="stat-secondary-row">
                        <span class="stat-label" id="stat-secondary-label">üíú Mana</span>
                        <div class="stat-bar"><div class="stat-bar-fill mana" id="stat-secondary"></div></div>
                        <span class="stat-value" id="stat-secondary-text">0/0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">‚ö° Energia</span>
                        <div class="stat-bar"><div class="stat-bar-fill stamina" id="stat-stamina"></div></div>
                        <span class="stat-value" id="stat-stamina-text">0/0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">üçñ Saziet√†</span>
                        <div class="stat-bar"><div class="stat-bar-fill hunger" id="stat-hunger"></div></div>
                        <span class="stat-value" id="stat-hunger-text">0/0</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">‚≠ê Exp</span>
                        <div class="stat-bar"><div class="stat-bar-fill exp" id="stat-exp"></div></div>
                        <span class="stat-value" id="stat-exp-text">0/0</span>
                    </div>
                </div>

                <h4>üìä Attributi</h4>
                <div class="attrs-grid" id="attrs-grid"></div>

                <h4>üéØ Abilit√† Base</h4>
                <div class="skills-list" id="skills-list"></div>

                <h4 style="margin-top: 15px;">‚ú® Abilit√† Acquisite</h4>
                <div class="abilities-list" id="abilities-list"></div>
            </div>
        </div>
    </div>

    <!-- Inventory Modal -->
    <div class="modal-overlay" id="modal-inventory">
        <div class="modal wide-modal"> <div class="modal-header">
                üéí Zaino & Equipaggiamento
                <button class="modal-close" data-close="modal-inventory">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="inv-header">
                    <span class="inv-gold">üí∞ <span id="inv-gold">0</span></span>
                    <span class="inv-weight">üì¶ Spazio: <span id="inv-count">0</span>/<span id="inv-capacity">20</span></span>
                </div>

                <div class="inv-container">
                    <div class="inv-left-col">
                        <div class="inv-grid" id="inv-grid"></div>
                    </div>

                    <div class="inv-right-col">
                        <div id="inv-item-details" class="item-details-empty">
                            <div class="empty-icon">üéí</div>
                            <p>Seleziona un oggetto per vedere i dettagli.</p>
                        </div>
                    </div>
                </div>

                <div class="special-items">
                    <h4>üîÆ Oggetti Chiave & Memoria</h4>
                    <div id="special-items-list"></div>
                </div>

                <div class="special-items">
                    <h4>üè∞ Propriet√† & Beni</h4>
                    <div id="properties-list"></div>
                </div>

                <div class="special-items">
                    <h4>‚ú® Abilit√† Registrate</h4>
                    <div id="inventory-abilities"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- World Memory Modal -->
    <div class="modal-overlay" id="modal-memory">
        <div class="modal">
            <div class="modal-header">
                üß† Memoria del Mondo
                <button class="modal-close" data-close="modal-memory">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="memory-stats">
                    <div class="memory-stat"><span class="memory-stat-icon">üë•</span> NPC: <strong id="mem-npc-count">0</strong></div>
                    <div class="memory-stat"><span class="memory-stat-icon">üìç</span> Luoghi: <strong id="mem-loc-count">0</strong></div>
                    <div class="memory-stat"><span class="memory-stat-icon">üìã</span> Quest: <strong id="mem-quest-count">0</strong></div>
                    <div class="memory-stat"><span class="memory-stat-icon">üìú</span> Eventi: <strong id="mem-event-count">0</strong></div>
                </div>

                <div class="tabs">
                    <button class="tab active" data-tab="chronicle">üìñ Cronaca</button>
                    <button class="tab" data-tab="npcs">üë• NPC</button>
                    <button class="tab" data-tab="locations">üìç Luoghi</button>
                    <button class="tab" data-tab="quests">üìã Quest</button>
                    <button class="tab" data-tab="events">üìú Eventi</button>
                    <button class="tab" data-tab="journal">üìì Diario</button>
                </div>

                <div class="tab-content active" id="tab-chronicle">
                    <div id="memory-chronicle" class="chronicle-view"></div>
                </div>
                <div class="tab-content" id="tab-npcs">
                    <div id="memory-npcs-list"></div>
                </div>
                <div class="tab-content" id="tab-locations">
                    <div id="memory-locations-list"></div>
                </div>
                <div class="tab-content" id="tab-quests">
                    <div id="memory-quests-list"></div>
                </div>
                <div class="tab-content" id="tab-events">
                    <div id="memory-events-list"></div>
                </div>
                <div class="tab-content" id="tab-journal">
                    <div class="journal-entries" id="journal-entries">
                        <div class="memory-empty" id="journal-empty">üìì Il tuo diario √® vuoto. Annota i tuoi pensieri e le tue strategie!</div>
                    </div>
                    <div class="journal-input-area">
                        <textarea id="journal-text" placeholder="Scrivi un appunto nel tuo diario..."></textarea>
                        <button class="btn primary" id="btn-add-journal" style="align-self:flex-end;">üìù</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Level Up Modal -->
    <div class="levelup-overlay" id="levelup-overlay">
        <div class="levelup-content">
            <div style="font-size:3em;margin-bottom:5px;">‚¨ÜÔ∏è</div>
            <div class="levelup-title">Livello <span id="levelup-level">2</span>!</div>
            <div class="levelup-subtitle">Scegli come migliorare il tuo personaggio</div>
            <div class="levelup-points">Punti disponibili: <strong id="levelup-points-count">2</strong></div>
            <div class="levelup-attrs" id="levelup-attrs"></div>
            <button class="btn primary" id="btn-confirm-levelup" style="width:100%;" disabled>‚ú® Conferma Miglioramenti</button>
        </div>
    </div>

    <!-- Game Over Overlay -->
    <div class="gameover-overlay" id="gameover-overlay">
        <div class="gameover-content">
            <div class="gameover-skull">üíÄ</div>
            <div class="gameover-title">Sei Caduto</div>
            <div class="gameover-text" id="gameover-text">La tua avventura finisce qui... ma ogni fine √® un nuovo inizio.</div>
            <div class="gameover-buttons">
                <button class="btn primary" id="btn-gameover-load">üìÇ Carica Salvataggio</button>
                <button class="btn secondary" id="btn-gameover-home">üè† Menu Principale</button>
            </div>
        </div>
    </div>

    <!-- Dice Modal -->
    <div class="modal-overlay" id="modal-dice">
        <div class="modal">
            <div class="modal-header">
                üé≤ Tira i Dadi
                <button class="modal-close" data-close="modal-dice">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="dice-grid">
                    <button class="dice-btn" data-sides="4">D4</button>
                    <button class="dice-btn" data-sides="6">D6</button>
                    <button class="dice-btn" data-sides="8">D8</button>
                    <button class="dice-btn" data-sides="10">D10</button>
                    <button class="dice-btn" data-sides="12">D12</button>
                    <button class="dice-btn" data-sides="20">D20</button>
                </div>
                <div class="dice-result" id="dice-result">üé≤ Tira un dado!</div>
            </div>
        </div>
    </div>

    <!-- Wait Modal -->
    <div class="modal-overlay" id="modal-wait">
        <div class="modal">
            <div class="modal-header">
                ‚è∞ Aspetta
                <button class="modal-close" data-close="modal-wait">‚úï</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 15px; text-align: center;">
                    Ora attuale: <strong id="wait-current-time">00:00</strong>
                </p>
                <div class="wait-grid">
                    <button class="wait-btn" data-minutes="30">30 minuti</button>
                    <button class="wait-btn" data-minutes="60">1 ora</button>
                    <button class="wait-btn" data-minutes="180">3 ore</button>
                    <button class="wait-btn" data-minutes="360">6 ore</button>
                    <button class="wait-btn" data-minutes="720">12 ore</button>
                    <button class="wait-btn" data-minutes="1440">1 giorno</button>
                </div>
                <div class="wait-custom">
                    <span>Aspetta fino alle:</span>
                    <input type="number" id="wait-until-hour" min="0" max="23" value="12">
                    <span>:00</span>
                    <button class="btn secondary" id="btn-wait-until">Vai</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Stories Modal -->
    <div class="modal-overlay" id="modal-stories">
        <div class="modal">
            <div class="modal-header">
                ‚úèÔ∏è Gestione Storie
                <button class="modal-close" data-close="modal-stories">‚úï</button>
            </div>
            <div class="modal-body">
                <div id="stories-list"></div>
                <div class="btn-row">
                    <button class="btn primary" id="btn-create-story">‚ûï Nuova</button>
                    <button class="btn secondary" id="btn-edit-story" disabled>‚úèÔ∏è Modifica</button>
                    <button class="btn danger" id="btn-delete-story" disabled>üóëÔ∏è</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Story Editor Modal -->
    <div class="modal-overlay" id="modal-story-editor">
        <div class="modal">
            <div class="modal-header">
                üìù Editor Storia
                <button class="modal-close" data-close="modal-story-editor">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Titolo</label>
                    <input type="text" class="form-input" id="edit-story-title" placeholder="Titolo della storia">
                </div>
                <div class="form-group">
                    <label class="form-label">Ambientazione</label>
                    <input type="text" class="form-input" id="edit-story-setting" placeholder="es. Fantasy Medievale, Moderno, Sci-Fi">
                </div>
                <div class="form-group">
                    <label class="form-label">Genere</label>
                    <select class="form-select" id="edit-story-genre">
                        <option value="fantasy">Fantasy</option>
                        <option value="contemporary">Contemporaneo</option>
                        <option value="sport">Sport / Calcio</option>
                        <option value="business">Business / Finanza</option>
                        <option value="crime">Crime / Mafia</option>
                        <option value="historical">Storico (Roma/Rinascimento)</option>
                        <option value="military">Militare / Guerra</option>
                        <option value="diplomatic">Diplomatico</option>
                        <option value="rural">Rurale / Agricolo</option>
                        <option value="pirate">Piratesco</option>
                        <option value="spy">Spionaggio</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Difficolt√†</label>
                    <select class="form-select" id="edit-story-difficulty">
                        <option value="easy">Facile</option>
                        <option value="normal" selected>Normale</option>
                        <option value="hard">Difficile</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">Capitale iniziale</label>
                    <input type="number" class="form-input" id="edit-story-gold" placeholder="es. 2000">
                </div>
                <div class="form-group">
                    <label class="form-label">Descrizione Mondo</label>
                    <textarea class="form-textarea" id="edit-story-desc" placeholder="Descrivi il mondo..."></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Personalit√† Narratore</label>
                    <textarea class="form-textarea" id="edit-story-personality" placeholder="Come deve narrare l'IA?"></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Profondit√† (NPC, morale...)</label>
                    <textarea class="form-textarea" id="edit-story-depth" placeholder="Dettagli sulla profondit√† del mondo..."></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Prologo</label>
                    <textarea class="form-textarea" id="edit-story-prologue" placeholder="Il testo iniziale della storia..."></textarea>
                </div>
                <div class="form-group">
                    <label class="form-label">Propriet√† iniziali (una per riga: Nome | Descrizione | Note)</label>
                    <textarea class="form-textarea" id="edit-story-properties" placeholder="Emporio Rossi | Piccolo negozio di famiglia | Puoi investirci o venderlo"></textarea>
                </div>
                <button class="btn primary" id="btn-save-story" style="width: 100%;">üíæ Salva Storia</button>
            </div>
        </div>
    </div>

    <!-- Saves Modal -->
    <div class="modal-overlay" id="modal-saves">
        <div class="modal">
            <div class="modal-header">
                üíæ Salvataggi
                <button class="modal-close" data-close="modal-saves">‚úï</button>
            </div>
            <div class="modal-body">
                <div id="saves-list"></div>
                <div class="btn-row">
                    <button class="btn primary" id="btn-save-to-slot">üíæ Salva</button>
                    <button class="btn secondary" id="btn-load-from-slot">üìÇ Carica</button>
                    <button class="btn danger" id="btn-delete-slot">üóëÔ∏è</button>
                </div>
            </div>
        </div>
    </div>

    <!-- New Game Modal -->
    <div class="modal-overlay" id="modal-new-game">
        <div class="modal">
            <div class="modal-header">
                üìú Nuova Partita
                <button class="modal-close" data-close="modal-new-game">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Scegli una Storia</label>
                    <select class="form-select" id="new-game-story"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Nome Personaggio</label>
                    <input type="text" class="form-input" id="new-game-name" placeholder="Il tuo nome...">
                </div>
                <div class="form-group">
                    <label class="form-label">Origine</label>
                    <div class="creation-grid" id="origin-grid"></div>
                </div>
                <div class="form-group">
                    <label class="form-label">Archetipo</label>
                    <div class="creation-grid" id="archetype-grid"></div>
                </div>
                <button class="btn primary" id="btn-start-game" style="width: 100%;">‚öîÔ∏è Inizia Avventura!</button>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="modal-settings">
        <div class="modal">
            <div class="modal-header">
                üîß Impostazioni
                <button class="modal-close" data-close="modal-settings">‚úï</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">üîë API Key Groq</label>
                    <input type="password" class="form-input" id="set-groq-key" placeholder="Inserisci la tua API key Groq...">
                </div>
                <div class="form-group">
                    <label class="form-label">üîë API Key OpenRouter</label>
                    <input type="password" class="form-input" id="set-openrouter-key" placeholder="Inserisci la tua API key OpenRouter...">
                </div>
                <div class="form-group">
                    <label class="form-label">üîë API Key Kimera (DeepSeek)</label>
                    <input type="password" class="form-input" id="set-kimera-key" placeholder="Inserisci la tua API key Kimera...">
                </div>
                <div class="form-group">
                    <label class="form-label">ü§ñ Modello AI</label>
                    <select class="form-select" id="set-model">
                        <option value="groq">Groq (Llama 3.1 - Veloce)</option>
                        <option value="openrouter">OpenRouter (Gemma 3 27B it Free)</option>
                        <option value="deepseek">OpenRouter (mimo-v2-flash:free)</option>
                        <option value="openrouter-free">OpenRouter (openrouter/free)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label">üìè Lunghezza Risposte</label>
                    <select class="form-select" id="set-length">
                        <option value="short">Breve</option>
                        <option value="medium">Media</option>
                        <option value="long">Lunga</option>
                    </select>
                </div>
                <div class="form-group">
                    <label><input type="checkbox" id="set-autoroll" checked> Tiri automatici</label>
                </div>
                <div class="btn-row">
                    <button class="btn primary" id="btn-save-settings">üíæ Salva</button>
                    <button class="btn danger" id="btn-reset-all">‚ö†Ô∏è Reset</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/@openrouter/sdk"></script>
    <script>
        // ==================== GAME STATE ====================
        const G = {
            currentStory: null,
            character: null,
            storyLog: [],
            history: [],
            time: {
                day: 1,
                month: 1,
                year: 1400,
                hour: 8,
                minute: 0,
                dayName: 'Luned√¨'
            },
            // === NUOVO: World Memory System ===
            worldMemory: {
                npcs: [],           // { id, name, description, relationship, lastSeen, metAt }
                locations: [],      // { id, name, description, discovered, notes }
                quests: [],         // { id, name, description, status, progress }
                events: [],         // { id, summary, turn, importance }
                acquiredItems: [],  // { id, name, description, icon, acquiredAt }
                acquiredAbilities: [], // { id, name, description, acquiredAt }
                properties: [],     // { id, name, description, notes, acquiredAt }
                family: [],         // { id, name, relation, age, status, description, income, expenses }
                employees: [],      // { id, name, role, property, salary, skill, morale, hiredAt }
                storySummary: '',   // Riassunto compresso della storia
                lastSummaryTurn: 0,
                turnCount: 0
            },
            settings: {
                groqKey: '', openrouterKey: '', kimeraKey: '', model: 'groq', length: 'medium', autoRoll: true
            },
            stories: [],
            saves: Array(6).fill(null),
            selectedStory: null,
            selectedSave: null,
            selectedOrigin: null,
            selectedArchetype: null,
            editingStory: null,
            isPlaying: false,
            isProcessing: false,
            currentLocation: 'Sconosciuto',
            levelUpPending: null,
            storyBatchMode: false,
            pendingStoryScroll: false
        };

        const DAYS = ['Luned√¨', 'Marted√¨', 'Mercoled√¨', 'Gioved√¨', 'Venerd√¨', 'Sabato', 'Domenica'];
        const MONTHS = [
            { name: 'Gennaio', days: 31, season: 'Inverno' },
            { name: 'Febbraio', days: 28, season: 'Inverno' },
            { name: 'Marzo', days: 31, season: 'Primavera' },
            { name: 'Aprile', days: 30, season: 'Primavera' },
            { name: 'Maggio', days: 31, season: 'Primavera' },
            { name: 'Giugno', days: 30, season: 'Estate' },
            { name: 'Luglio', days: 31, season: 'Estate' },
            { name: 'Agosto', days: 31, season: 'Estate' },
            { name: 'Settembre', days: 30, season: 'Autunno' },
            { name: 'Ottobre', days: 31, season: 'Autunno' },
            { name: 'Novembre', days: 30, season: 'Autunno' },
            { name: 'Dicembre', days: 31, season: 'Inverno' }
        ];

        const SEASON_ICONS = {
            'Inverno': '‚ùÑÔ∏è',
            'Primavera': 'üå∏',
            'Estate': '‚òÄÔ∏è',
            'Autunno': 'üçÇ'
        };

        const DEFAULT_SECONDARY_RESOURCE = {
            key: 'mana',
            label: 'Mana',
            icon: 'üíú',
            className: 'mana',
            attrPriority: ['int', 'wis', 'cha', 'car'],
            baseField: 'mp',
            includeMod: true,
            modMultiplier: 1,
            scale: 1,
            defaultMax: 10,
            startFull: true,
            levelUpBonus: 3,
            aliases: ['mana']
        };

        const GENRE_ACTIONS = {
            'Fantasy': [
                { icon: '?', label: 'Parla', prefix: 'Dico: "' },
                { icon: '?', label: 'Osserva', prefix: 'Osservo attentamente ' },
                { icon: '?', label: 'Combatti', prefix: 'Attacco ' },
                { icon: '?', label: 'Magia', prefix: 'Uso la magia per ' },
                { icon: '?', label: 'Furtivo', prefix: 'Mi muovo furtivamente verso ' },
                { icon: '?', label: 'Cerca', prefix: 'Cerco ' }
            ],
            'Contemporaneo': [
                { icon: '?', label: 'Parla', prefix: 'Dico: "' },
                { icon: '?', label: 'Osserva', prefix: 'Osservo ' },
                { icon: '?', label: 'Telefona', prefix: 'Chiamo ' },
                { icon: '?', label: 'Cerca', prefix: 'Cerco informazioni su ' },
                { icon: '?', label: 'Vai', prefix: 'Vado a ' },
                { icon: '?', label: 'Pensa', prefix: 'Rifletto su ' }
            ],
            'Business': [
                { icon: '?', label: 'Parla', prefix: 'Dico: "' },
                { icon: '?', label: 'Negozia', prefix: 'Propongo ' },
                { icon: '?', label: 'Analizza', prefix: 'Analizzo ' },
                { icon: '?', label: 'Contatta', prefix: 'Contatto ' },
                { icon: '?', label: 'Compra', prefix: 'Compro ' },
                { icon: '?', label: 'Vendi', prefix: 'Vendo ' }
            ],
            'default': [
                { icon: '?', label: 'Parla', prefix: 'Dico: "' },
                { icon: '?', label: 'Osserva', prefix: 'Osservo ' },
                { icon: '?', label: 'Interagisci', prefix: 'Interagisco con ' },
                { icon: '?', label: 'Chiedi', prefix: 'Chiedo ' },
                { icon: '?', label: 'Vai', prefix: 'Vado verso ' },
                { icon: '?', label: 'Cerca', prefix: 'Cerco ' }
            ]
        };

        const ORIGINS = {
            ordinary: { name: 'Persona Comune', icon: '?', desc: 'Background normale', bonuses: { all: 1 } },
            wealthy: { name: 'Famiglia Ricca', icon: '?', desc: 'Cresciuto negli agi', bonuses: { cha: 2, int: 1 } },
            street: { name: 'Strada', icon: '?', desc: 'Cresciuto per le strade', bonuses: { dex: 2, wis: 1 } },
            academic: { name: 'Accademico', icon: '?', desc: 'Istruzione elevata', bonuses: { int: 3 } },
            military: { name: 'Militare', icon: '?', desc: 'Addestramento e disciplina', bonuses: { str: 2, con: 1 } },
            artistic: { name: 'Artista', icon: '?', desc: 'Anima creativa', bonuses: { cha: 2, wis: 1 } }
        };

        const ARCHETYPES = {
            leader: { name: 'Leader', icon: '?', desc: 'Guida gli altri', stat: 'cha', hp: 10, mp: 6, skills: ['Persuasione', 'Comando'] },
            fighter: { name: 'Combattente', icon: '?', desc: 'Esperto nel combattimento', stat: 'str', hp: 14, mp: 2, skills: ['Combattimento', 'Resistenza'] },
            thinker: { name: 'Pensatore', icon: '?', desc: 'Risolve problemi', stat: 'int', hp: 8, mp: 10, skills: ['Analisi', 'Ricerca'] },
            shadow: { name: 'Ombra', icon: '?', desc: 'Agisce nell\'ombra', stat: 'dex', hp: 10, mp: 4, skills: ['Furtivit√†', 'Agilit√†'] },
            healer: { name: 'Guaritore', icon: '?', desc: 'Cura e supporta', stat: 'wis', hp: 8, mp: 10, skills: ['Medicina', 'Intuizione'] },
            merchant: { name: 'Mercante', icon: '?', desc: 'Compra e vende', stat: 'cha', hp: 8, mp: 6, skills: ['Contrattazione', 'Valutazione'] }
        };

        const ITEMS = {
            healing: { name: 'Kit Pronto Soccorso', icon: '?', type: 'consumable', effect: { health: 30 } },
            energy: { name: 'Energy Drink', icon: '?', type: 'consumable', effect: { stamina: 40 } },
            food: { name: 'Pasto', icon: '?', type: 'consumable', effect: { hunger: 50 } },
            snack: { name: 'Snack', icon: '?', type: 'consumable', effect: { hunger: 20, stamina: 10 } },
            ration: { name: 'Razione', icon: '?', type: 'consumable', effect: { hunger: 35 } },
            potion: { name: 'Pozione Energia', icon: '?', type: 'consumable', effect: { mana: 30 } }
        };

        // ==================== GENERI E CONFIGURAZIONE DINAMICA ====================
        const DEFAULT_ACTIONS = [
            { icon: '?', label: 'Parla', prefix: 'Dico: "' },
            { icon: '?', label: 'Osserva', prefix: 'Osservo ' },
            { icon: '?', label: 'Vai', prefix: 'Vado verso ' },
            { icon: '?', label: 'Chiedi', prefix: 'Chiedo ' },
            { icon: '?', label: 'Cerca', prefix: 'Cerco ' }
        ];

        const GENRES = {
            fantasy: {
                name: 'Fantasy',
                currency: { name: "Monete d'oro", short: 'oro', symbol: 'ü™ô' },
                resolution: 'Tira 1d20 + mod caratteristica contro CD 10/15/20; 1 fallimento critico, 20 successo critico.',
                stats: [
                    { id: 'str', label: 'Forza', short: 'STR', base: 10 },
                    { id: 'dex', label: 'Destrezza', short: 'DEX', base: 10 },
                    { id: 'con', label: 'Costituzione', short: 'CON', base: 10 },
                    { id: 'int', label: 'Intelligenza', short: 'INT', base: 10 },
                    { id: 'wis', label: 'Saggezza', short: 'WIS', base: 10 },
                    { id: 'cha', label: 'Carisma', short: 'CHA', base: 10 }
                ],
                origins: {
                    villager: { name: 'Villano', icon: 'üè°', desc: 'Vita nei campi', bonuses: { con: 1, wis: 1 } },
                    noble: { name: 'Nobile', icon: 'üëë', desc: 'Cresciuto nei privilegi', bonuses: { cha: 2, int: 1 } },
                    outlaw: { name: 'Fuorilegge', icon: 'üó°Ô∏è', desc: 'Vive ai margini', bonuses: { dex: 2, cha: 1 } },
                    scholar: { name: 'Studioso', icon: 'üìú', desc: 'Anni sui tomi', bonuses: { int: 3 } }
                },
                archetypes: {
                    warrior: { name: 'Guerriero', icon: '‚öîÔ∏è', desc: 'Prima linea', stat: 'str', hp: 14, mp: 2, skills: ['Combattimento', 'Resistenza'] },
                    rogue: { name: 'Ladro', icon: 'üóùÔ∏è', desc: 'Agile e furtivo', stat: 'dex', hp: 10, mp: 4, skills: ['Furtivita', 'Agilita'] },
                    mage: { name: 'Mago', icon: '‚ú®', desc: 'Manipola arcani', stat: 'int', hp: 8, mp: 12, skills: ['Magia', 'Analisi'] },
                    cleric: { name: 'Chierico', icon: '‚õ™', desc: 'Fede e cura', stat: 'wis', hp: 10, mp: 10, skills: ['Guarigione', 'Intuizione'] }
                },
                items: {
                    potion_heal: { name: 'Pozione Curativa', icon: 'üß™', type: 'consumable', desc: 'Un liquido rosso brillante in una fiala di vetro. Ha un sapore amaro ma chiude rapidamente le ferite.', effect: { health: 30 } },
                    potion_mana: { name: 'Pozione di Mana', icon: 'üîÆ', type: 'consumable', desc: 'Essenza arcana condensata in forma liquida. Brilla di una luce blu eterea e ripristina le energie mistiche.', effect: { mana: 25 } },
                    ration: { name: 'Razione da Viaggio', icon: 'üçñ', type: 'consumable', desc: 'Carne essiccata e pane duro avvolti in una foglia. Non √® un banchetto, ma ti tiene in piedi.', effect: { hunger: 35, stamina: 10 } },
                    tonic: { name: 'Tonico Energetico', icon: 'ü•§', type: 'consumable', desc: 'Un infuso di erbe montane che rinvigorisce il corpo affaticato. Lascia un retrogusto di menta.', effect: { stamina: 30 } }
                },
                starterInventory: [],
                quickActions: [
                    { icon: 'üí¨', label: 'Parla', prefix: 'Dico: "' },
                    { icon: 'üëÅÔ∏è', label: 'Osserva', prefix: 'Osservo attentamente ' },
                    { icon: '‚öîÔ∏è', label: 'Combatti', prefix: 'Attacco ' },
                    { icon: '‚ú®', label: 'Magia', prefix: 'Uso la magia per ' },
                    { icon: 'üïµÔ∏è', label: 'Furtivo', prefix: 'Mi muovo furtivamente verso ' }
                ],
                secondaryResource: {
                    key: 'mana',
                    label: 'Mana',
                    icon: 'üíú',
                    className: 'mana',
                    attrPriority: ['int', 'wis', 'cha'],
                    baseField: 'mp',
                    includeMod: true,
                    scale: 1,
                    defaultMax: 10,
                    startFull: true,
                    levelUpBonus: 3,
                    aliases: ['mana', 'magia', 'energia']
                }
            },
            contemporary: {
                name: 'Contemporaneo',
                currency: { name: 'Euro', short: 'EUR', symbol: '‚Ç¨' },
                resolution: 'Tira 1d10 + stat (FOR/DEX/INT/CAR) contro 6-12; 1 pessimo, 10 ottimo.',
                stats: [
                    { id: 'for', label: 'Forza', short: 'FOR', base: 10 },
                    { id: 'dex', label: 'Destrezza', short: 'DEX', base: 10 },
                    { id: 'int', label: 'Intelligenza', short: 'INT', base: 10 },
                    { id: 'car', label: 'Carisma', short: 'CAR', base: 10 }
                ],
                origins: {
                    student: { name: 'Studente', icon: 'üìö', desc: 'Vive tra lezioni e appunti', bonuses: { int: 2, car: 1 } },
                    worker: { name: 'Lavoratore', icon: 'üõ†Ô∏è', desc: 'Mani sporche e praticit√†', bonuses: { for: 1, dex: 1, car: 1 } },
                    freelancer: { name: 'Freelancer', icon: 'üíº', desc: 'Creativo indipendente', bonuses: { dex: 1, int: 1, car: 1 } }
                },
                archetypes: {
                    influencer: { name: 'Influencer', icon: 'üì±', desc: 'Vive di attenzione', stat: 'car', hp: 10, mp: 4, skills: ['Persuasione', 'Storytelling'] },
                    coder: { name: 'Sviluppatore', icon: 'üíª', desc: 'Risolve problemi con codice', stat: 'int', hp: 9, mp: 6, skills: ['Debug', 'Automazione'] },
                    driver: { name: 'Autista', icon: 'üöó', desc: 'Sempre in movimento', stat: 'dex', hp: 11, mp: 3, skills: ['Guida', 'Reattivit√†'] }
                },
                items: {
                    snack: { name: 'Snack', icon: 'üç´', type: 'consumable', desc: 'Una barretta di cioccolato e frutta secca. Perfetta per uno spuntino veloce quando il tempo stringe.', effect: { hunger: 20, stamina: 10 } },
                    coffee: { name: 'Caff√®', icon: '‚òï', type: 'consumable', desc: 'Un espresso caldo e intenso. L\'aroma ti risveglia prima ancora di berlo.', effect: { stamina: 20 } },
                    medkit: { name: 'Kit di Pronto Soccorso', icon: 'ü©π', type: 'consumable', desc: 'Una scatola compatta con bende, disinfettante e cerotti. Essenziale per le emergenze.', effect: { health: 20 } }
                },
                starterInventory: [],
                quickActions: [
                    { icon: 'üí¨', label: 'Parla', prefix: 'Dico: "' },
                    { icon: 'üëÅÔ∏è', label: 'Osserva', prefix: 'Osservo ' },
                    { icon: 'üìû', label: 'Chiama', prefix: 'Chiamo ' },
                    { icon: 'üö∂', label: 'Muoviti', prefix: 'Vado verso ' },
                    { icon: 'üîç', label: 'Cerca', prefix: 'Cerco informazioni su ' }
                ],
                secondaryResource: {
                    key: 'reputation',
                    label: 'Reputazione',
                    icon: 'üåü',
                    className: 'reputation',
                    attrPriority: ['car', 'int'],
                    baseField: 'mp',
                    includeMod: true,
                    modMultiplier: 1,
                    scale: 10,
                    defaultMax: 40,
                    startFull: true,
                    levelUpBonus: 4,
                    aliases: ['reputazione', 'prestigio', 'reputation']
                }
            },
            sport: {
                name: 'Sport / Calcio',
                currency: { name: 'Euro', short: 'EUR', symbol: '‚Ç¨' },
                resolution: 'Tira 2d6 + stat (TEC/VEL/RES/TAC/MEN) contro 6-14: 6-7 fallimento, 8-9 parziale, 10-11 successo, 12+ critico.',
                stats: [
                    { id: 'tec', label: 'Tecnica', short: 'TEC', base: 10 },
                    { id: 'vel', label: 'Velocita', short: 'VEL', base: 10 },
                    { id: 'res', label: 'Resistenza', short: 'RES', base: 10 },
                    { id: 'tac', label: 'Tattica', short: 'TAC', base: 10 },
                    { id: 'men', label: 'Mentalita', short: 'MEN', base: 10 }
                ],
                origins: {
                    academy: { name: 'Settore Giovanile', icon: 'üèüÔ∏è', desc: 'Formato in accademia', bonuses: { tec: 2, tac: 1 } },
                    street: { name: 'Strada', icon: 'üöß', desc: 'Partite di quartiere', bonuses: { vel: 2, men: 1 } },
                    amateur: { name: 'Dilettante', icon: '‚öΩ', desc: 'Passione pura', bonuses: { res: 1, men: 1, tec: 1 } }
                },
                archetypes: {
                    striker: { name: 'Attaccante', icon: 'ü•Ö', desc: 'Cerca il gol', stat: 'tec', hp: 12, mp: 6, skills: ['Tiro', 'Smarcamento'] },
                    playmaker: { name: 'Regista', icon: 'üéØ', desc: 'Imposta il gioco', stat: 'tac', hp: 10, mp: 5, skills: ['Visione', 'Passaggi'] },
                    defender: { name: 'Difensore', icon: 'üõ°Ô∏è', desc: 'Blocca', stat: 'res', hp: 14, mp: 5, skills: ['Contrasto', 'Marcatura'] },
                    goalkeeper: { name: 'Portiere', icon: 'üß§', desc: 'Ultimo baluardo', stat: 'men', hp: 12, mp: 6, skills: ['Riflessi', 'Leadership'] }
                },
                items: {
                    energy_gel: { name: 'Gel Energetico', icon: 'ü•§', type: 'consumable', desc: 'Un concentrato di carboidrati in forma gel. Si assume rapidamente e d√† una scarica di energia immediata.', effect: { stamina: 40 } },
                    isotonic: { name: 'Bevanda Isotonica', icon: 'üßÉ', type: 'consumable', desc: 'Acqua arricchita con sali minerali e zuccheri. Perfetta per reidratarti durante lo sforzo.', effect: { stamina: 20, hunger: 10 } },
                    physio: { name: 'Trattamento Fisioterapico', icon: 'ü©π', type: 'consumable', desc: 'Un massaggio e fasciature professionali. Allevia i dolori muscolari e previene infortuni.', effect: { health: 20 } },
                    protein_bar: { name: 'Barretta Proteica', icon: 'üç´', type: 'consumable', desc: 'Una barretta densa ricca di proteine e fibre. Ideale per il recupero post-allenamento.', effect: { hunger: 25, stamina: 10 } }
                },
                starterInventory: [],
                quickActions: [
                    { icon: 'üí¨', label: 'Parla', prefix: 'Dico al compagno: "' },
                    { icon: '‚ö°', label: 'Scatto', prefix: 'Scatto verso ' },
                    { icon: 'ü•Ö', label: 'Tiro', prefix: 'Carico il tiro verso ' },
                    { icon: 'üéØ', label: 'Passaggio', prefix: 'Cerco il passaggio per ' },
                    { icon: 'üõ°Ô∏è', label: 'Contrasto', prefix: 'Entro in contrasto con ' }
                ],
                secondaryResource: {
                    key: 'morale',
                    label: 'Morale',
                    icon: 'üî•',
                    className: 'morale',
                    attrPriority: ['men', 'tac', 'res', 'tec'],
                    baseField: 'mp',
                    includeMod: true,
                    scale: 10,
                    defaultMax: 50,
                    startFull: true,
                    levelUpBonus: 4,
                    aliases: ['morale', 'mentalita', 'focus']
                }
            },
            business: {
                name: 'Business / Finanza',
                currency: { name: 'Euro', short: 'EUR', symbol: '‚Ç¨' },
                resolution: 'Tira 1d10 + stat (CAR/INT/NEG/NET/LCK) contro 6-12; 1 pessimo affare, 10 chiusura brillante.',
                stats: [
                    { id: 'car', label: 'Carisma', short: 'CAR', base: 10 },
                    { id: 'int', label: 'Intelligenza', short: 'INT', base: 10 },
                    { id: 'neg', label: 'Negoziazione', short: 'NEG', base: 10 },
                    { id: 'net', label: 'Network', short: 'NET', base: 10 },
                    { id: 'luck', label: 'Fortuna', short: 'LCK', base: 10 }
                ],
                origins: {
                    startup: { name: 'Startupper', icon: 'üöÄ', desc: 'Vive di pitch', bonuses: { neg: 2, net: 1 } },
                    consultant: { name: 'Consulente', icon: 'üìä', desc: 'Metodo e presentazioni', bonuses: { int: 2, car: 1 } },
                    heir: { name: 'Erede', icon: 'üíº', desc: 'Capitale di famiglia', bonuses: { car: 1, net: 2 } }
                },
                archetypes: {
                    ceo: { name: 'CEO', icon: 'üëî', desc: 'Visione e decisioni', stat: 'car', hp: 10, mp: 5, skills: ['Leadership', 'Persuasione'] },
                    seller: { name: 'Venditore', icon: 'üó£Ô∏è', desc: 'Chiusura di deal', stat: 'neg', hp: 10, mp: 3, skills: ['Pitch', 'Negoziazione'] },
                    analyst: { name: 'Analista', icon: 'üìà', desc: 'Legge i numeri', stat: 'int', hp: 9, mp: 6, skills: ['Analisi', 'Ricerca'] },
                    fixer: { name: 'Fixer', icon: 'ü§ù', desc: 'Apre porte', stat: 'net', hp: 11, mp: 4, skills: ['Contatti', 'Mediazione'] }
                },
                items: {
                    coffee: { name: 'Caff√® Premium', icon: '‚òï', type: 'consumable', desc: 'Un espresso arabica servito in tazza di porcellana. Il carburante dei professionisti.', effect: { stamina: 25 } },
                    snack: { name: 'Biscotti', icon: 'üç™', type: 'consumable', desc: 'Biscotti artigianali dalla sala meeting. Un piccolo lusso durante le pause.', effect: { hunger: 20, stamina: 10 } },
                    energy_drink: { name: 'Energy Drink', icon: '‚ö°', type: 'consumable', desc: 'Una lattina gelata di bevanda energetica. Taurina e caffeina per le notti in ufficio.', effect: { stamina: 35 } }
                },
                starterInventory: [],
                quickActions: [
                    { icon: 'üí¨', label: 'Pitch', prefix: 'Propongo: "' },
                    { icon: 'üìû', label: 'Chiama', prefix: 'Chiamo ' },
                    { icon: 'üìä', label: 'Analizza', prefix: 'Analizzo ' },
                    { icon: 'ü§ù', label: 'Negozia', prefix: 'Negozio con ' },
                    { icon: 'üí°', label: 'Idea', prefix: "Valuto un'idea su " }
                ],
                secondaryResource: {
                    key: 'reputation',
                    label: 'Reputazione',
                    icon: 'üèõÔ∏è',
                    className: 'reputation',
                    attrPriority: ['car', 'neg', 'net'],
                    baseField: 'mp',
                    includeMod: true,
                    scale: 10,
                    defaultMax: 45,
                    startFull: true,
                    levelUpBonus: 4,
                    aliases: ['reputazione', 'prestigio', 'reputation']
                }
            },
            crime: {
                name: 'Criminale / Mafia',
                currency: { name: 'Contanti', short: 'USD', symbol: '$' },
                resolution: 'Tira 1d12 + stat (RSP/VIO/AST/CONN/LEA) contro 7-13; 1 disastro, 12+ colpo magistrale.',
                stats: [
                    { id: 'resp', label: 'Rispetto', short: 'RSP', base: 10 },
                    { id: 'vio', label: 'Violenza', short: 'VIO', base: 10 },
                    { id: 'ast', label: 'Astuzia', short: 'AST', base: 10 },
                    { id: 'conn', label: 'Connessioni', short: 'CONN', base: 10 },
                    { id: 'leal', label: 'Lealta', short: 'LEA', base: 10 }
                ],
                origins: {
                    street: { name: 'Strada', icon: 'üß®', desc: 'Vita nei vicoli', bonuses: { vio: 2, resp: 1 } },
                    insider: { name: 'Insider', icon: 'üóùÔ∏è', desc: 'Informazioni e agganci', bonuses: { conn: 2, ast: 1 } },
                    loyal: { name: 'Leale', icon: 'ü§û', desc: "Codice d'onore", bonuses: { leal: 2, resp: 1 } }
                },
                archetypes: {
                    enforcer: { name: 'Picchiatore', icon: 'ü•ä', desc: 'Mani pesanti', stat: 'vio', hp: 14, mp: 0, skills: ['Intimidire', 'Brutalita'] },
                    strategist: { name: 'Stratega', icon: 'üß†', desc: 'Piani e colpi', stat: 'ast', hp: 10, mp: 2, skills: ['Pianificazione', 'Inganno'] },
                    fixer: { name: 'Facilitatore', icon: 'ü§ù', desc: 'Conosce tutti', stat: 'conn', hp: 11, mp: 2, skills: ['Contatti', 'Mediazione'] },
                    lieutenant: { name: 'Luogotenente', icon: 'üéñÔ∏è', desc: 'Guida la crew', stat: 'resp', hp: 12, mp: 2, skills: ['Comando', 'Reputazione'] }
                },
                items: {
                    bandage: { name: 'Bendaggio', icon: 'ü©π', type: 'consumable', desc: 'Bende pulite e garze. Non sono professionali, ma fermano il sangue quando serve.', effect: { health: 25 } },
                    energy_shot: { name: 'Adrenalina', icon: 'üíâ', type: 'consumable', desc: 'Una fiala di stimolante da iniettare. Illegale, potente, e ti tiene sveglio per ore.', effect: { stamina: 35 } },
                    street_food: { name: 'Street Food', icon: 'üåØ', type: 'consumable', desc: 'Un kebab unto dal chiosco di quartiere. Non chiedere cosa c\'√® dentro, ma √® buono.', effect: { hunger: 25 } }
                },
                starterInventory: [],
                quickActions: [
                    { icon: 'üí¨', label: 'Parla', prefix: 'Dico: "' },
                    { icon: 'üß†', label: 'Astuzia', prefix: 'Studio il colpo su ' },
                    { icon: 'ü•ä', label: 'Minaccia', prefix: 'Minaccio ' },
                    { icon: 'ü§ù', label: 'Contatti', prefix: 'Chiamo un contatto per ' },
                    { icon: 'üöó', label: 'Fuga', prefix: 'Preparo la fuga verso ' }
                ]
            },
            historical: {
                name: 'Storico',
                currency: { name: 'Fiorini', short: 'FIO', symbol: 'ü™ô' },
                resolution: 'Tira 1d12 + stat (FOR/DEX/ERU/RET) contro 7-13, con colore storico.',
                stats: [
                    { id: 'for', label: 'Forza', short: 'FOR', base: 10 },
                    { id: 'dex', label: 'Destrezza', short: 'DEX', base: 10 },
                    { id: 'int', label: 'Erudizione', short: 'ERU', base: 10 },
                    { id: 'car', label: 'Retorica', short: 'RET', base: 10 }
                ],
                origins: {
                    legionnaire: { name: 'Legionario', icon: 'üõ°Ô∏è', desc: 'Disciplina e marce', bonuses: { for: 2, dex: 1 } },
                    artisan: { name: 'Artigiano', icon: '‚öíÔ∏è', desc: 'Mani d‚Äôoro', bonuses: { dex: 2, int: 1 } },
                    scholar: { name: 'Studioso', icon: 'üìú', desc: 'Biblioteca vivente', bonuses: { int: 3 } }
                },
                archetypes: {
                    centurion: { name: 'Centurione', icon: 'üè∫', desc: 'Guida i ranghi', stat: 'for', hp: 13, mp: 2, skills: ['Comando', 'Tattica'] },
                    merchant: { name: 'Mercante', icon: 'üß∫', desc: 'Scambia e persuade', stat: 'car', hp: 10, mp: 4, skills: ['Contratto', 'Valutazione'] },
                    explorer: { name: 'Esploratore', icon: 'üß≠', desc: 'Conosce percorsi', stat: 'dex', hp: 11, mp: 2, skills: ['Orientamento', 'Furtivit√†'] }
                },
                items: {
                    ration: { name: 'Razione', icon: 'üçñ', type: 'consumable', desc: 'Pane nero, formaggio stagionato e olive in salamoia. Il pasto del viaggiatore antico.', effect: { hunger: 30 } },
                    bandage: { name: 'Bendaggio', icon: 'ü©π', type: 'consumable', desc: 'Strisce di lino pulito imbevute di erbe curative. La medicina dei legionari.', effect: { health: 20 } },
                    wine: { name: 'Vino', icon: 'üç∑', type: 'consumable', desc: 'Vino rosso denso in un otre di pelle. Riscalda il corpo e solleva lo spirito.', effect: { stamina: 15 } }
                },
                starterInventory: [],
                quickActions: [
                    { icon: 'üí¨', label: 'Parla', prefix: 'Dico: "' },
                    { icon: 'üß≠', label: 'Esplora', prefix: 'Esploro ' },
                    { icon: 'üõ°Ô∏è', label: 'Difendi', prefix: 'Mi preparo a difendere ' },
                    { icon: '‚öíÔ∏è', label: 'Lavora', prefix: 'Lavoro su ' }
                ]
            },
            military: {
                name: 'Militare / Guerra',
                currency: { name: 'Crediti', short: 'CR', symbol: '¬§' },
                resolution: 'Tira 2d6 + stat (FOR/RES/TAC/MOR) contro 6-14; 2 fallimento critico, 12+ successo totale.',
                stats: [
                    { id: 'for', label: 'Forza', short: 'FOR', base: 10 },
                    { id: 'res', label: 'Resistenza', short: 'RES', base: 10 },
                    { id: 'tac', label: 'Tattica', short: 'TAC', base: 10 },
                    { id: 'mor', label: 'Morale', short: 'MOR', base: 10 }
                ],
                origins: {
                    recruit: { name: 'Recluta', icon: 'üéñÔ∏è', desc: 'Appena arruolato', bonuses: { res: 1, mor: 1, for: 1 } },
                    veteran: { name: 'Veterano', icon: 'ü™ñ', desc: 'Ha visto battaglie', bonuses: { res: 2, tac: 1 } },
                    officer: { name: 'Ufficiale', icon: 'üìê', desc: 'Guida e coordina', bonuses: { tac: 2, mor: 1 } }
                },
                archetypes: {
                    infantry: { name: 'Fante', icon: 'ü™ñ', desc: 'Prima linea', stat: 'for', hp: 14, mp: 0, skills: ['Assalto', 'Resistenza'] },
                    sniper: { name: 'Cecchino', icon: 'üéØ', desc: 'Precisione', stat: 'tac', hp: 11, mp: 0, skills: ['Mira', 'Osservazione'] },
                    medic: { name: 'Medico', icon: '‚õëÔ∏è', desc: 'Cura in campo', stat: 'res', hp: 10, mp: 0, skills: ['Pronto soccorso', 'Calma'] }
                },
                items: {
                    medkit: { name: 'Kit Medico da Campo', icon: 'ü©∫', type: 'consumable', desc: 'Una borsa militare con bende, morfina e strumenti chirurgici base. Pu√≤ salvare una vita.', effect: { health: 25 } },
                    rations: { name: 'Razioni MRE', icon: 'ü•´', type: 'consumable', desc: 'Pasto pronto confezionato dell\'esercito. Dura anni, sa di cartone, ma nutre.', effect: { hunger: 30, stamina: 10 } },
                    stim: { name: 'Stimolante Tattico', icon: 'üíâ', type: 'consumable', desc: 'Un\'iniezione di adrenalina sintetica. Ti tiene all\'erta quando la stanchezza uccide.', effect: { stamina: 30 } }
                },
                starterInventory: [],
                quickActions: [
                    { icon: 'üí¨', label: 'Comando', prefix: 'Ordino: "' },
                    { icon: 'üéØ', label: 'Mirare', prefix: 'Prendo mira su ' },
                    { icon: 'ü™ñ', label: 'Copertura', prefix: 'Prendo copertura presso ' },
                    { icon: 'üèÉ', label: 'Avanza', prefix: 'Avanzo verso ' }
                ]
            },
            diplomatic: {
                name: 'Diplomatico',
                currency: { name: 'Crediti', short: 'CR', symbol: '¬§' },
                resolution: 'Tira 2d6 + CAR/RET/INT contro 6-14; 6-7 fallimento, 8-9 complicazioni, 10-11 successo, 12+ successo pieno.',
                stats: [
                    { id: 'car', label: 'Carisma', short: 'CAR', base: 10 },
                    { id: 'ret', label: 'Retorica', short: 'RET', base: 10 },
                    { id: 'int', label: 'Intelligenza', short: 'INT', base: 10 }
                ],
                origins: {
                    envoy: { name: 'Inviato', icon: 'ü§ù', desc: 'Mandato ufficiale', bonuses: { car: 2, ret: 1 } },
                    scholar: { name: 'Accademico', icon: 'üìö', desc: 'Specialista di culture', bonuses: { int: 2, ret: 1 } },
                    courtier: { name: 'Cortigiano', icon: 'üëë', desc: 'Abituato alle etichette', bonuses: { car: 1, ret: 2 } }
                },
                archetypes: {
                    mediator: { name: 'Mediatore', icon: 'üïäÔ∏è', desc: 'Trova compromessi', stat: 'car', hp: 10, mp: 4, skills: ['Negoziazione', 'Empatia'] },
                    orator: { name: 'Oratore', icon: 'üéôÔ∏è', desc: 'Parola incisiva', stat: 'ret', hp: 9, mp: 5, skills: ['Retorica', 'Ispirazione'] },
                    analyst: { name: 'Analista', icon: 'üìä', desc: 'Legge le mosse', stat: 'int', hp: 9, mp: 6, skills: ['Analisi', 'Previsione'] }
                },
                items: {
                    notes: { name: 'Appunti Riservati', icon: 'üìí', type: 'gear', desc: 'Un taccuino in pelle con annotazioni cifrate. Contiene informazioni sensibili sui negoziati.' },
                    coffee: { name: 'Caff√® Diplomatico', icon: '‚òï', type: 'consumable', desc: 'Un caff√® turco servito durante le pause. Forte, dolce, e perfetto per schiarire le idee.', effect: { stamina: 15 } },
                    badge: { name: 'Tessera Diplomatica', icon: 'üé´', type: 'gear', desc: 'Un documento ufficiale che garantisce immunit√† e accesso a zone riservate.' }
                },
                starterInventory: [],
                quickActions: [
                    { icon: 'üí¨', label: 'Dichiara', prefix: 'Dichiaro: "' },
                    { icon: 'ü§ù', label: 'Negozia', prefix: 'Propongo un accordo su ' },
                    { icon: 'üïäÔ∏è', label: 'Media', prefix: 'Media tra ' },
                    { icon: 'üß†', label: 'Analizza', prefix: 'Analizzo la posizione di ' }
                ]
            },
            rural: {
                name: 'Rurale / Agricolo',
                currency: { name: 'Crediti', short: 'CR', symbol: '¬§' },
                resolution: 'Tira 1d8 + stat (FOR/RES/AGR) contro 5-10; 1 raccolto rovinato, 8+ raccolto ottimo.',
                stats: [
                    { id: 'for', label: 'Forza', short: 'FOR', base: 10 },
                    { id: 'res', label: 'Resistenza', short: 'RES', base: 10 },
                    { id: 'agr', label: 'Agronomia', short: 'AGR', base: 10 }
                ],
                origins: {
                    farmer: { name: 'Contadino', icon: 'üåæ', desc: 'Vive nei campi', bonuses: { agr: 2, res: 1 } },
                    shepherd: { name: 'Pastore', icon: 'üêë', desc: 'Cura il gregge', bonuses: { res: 2, for: 1 } },
                    miller: { name: 'Mugnaio', icon: 'üß∫', desc: 'Macina e commercia', bonuses: { agr: 1, for: 1, res: 1 } }
                },
                archetypes: {
                    harvester: { name: 'Raccoglitore', icon: 'üßë‚Äçüåæ', desc: 'Produce raccolti', stat: 'agr', hp: 11, mp: 0, skills: ['Coltivazione', 'Conservazione'] },
                    hauler: { name: 'Trasportatore', icon: 'üõí', desc: 'Porta il peso', stat: 'for', hp: 12, mp: 0, skills: ['Forza', 'Logistica'] },
                    caretaker: { name: 'Custode', icon: 'üêï', desc: 'Sorveglia e cura', stat: 'res', hp: 12, mp: 0, skills: ['Vigilanza', 'Cura animali'] }
                },
                items: {
                    bread: { name: 'Pane Casereccio', icon: 'üçû', type: 'consumable', desc: 'Una pagnotta croccante appena sfornata. L\'odore riempie la cucina di casa.', effect: { hunger: 20 } },
                    water: { name: 'Acqua di Fonte', icon: 'üíß', type: 'consumable', desc: 'Acqua fresca dalla sorgente del villaggio. Pura e cristallina come sempre.', effect: { stamina: 10 } },
                    herbs: { name: 'Erbe Medicinali', icon: 'üåø', type: 'consumable', desc: 'Un mazzetto di erbe raccolte al mattino. Le nonne sanno come usarle per curare.', effect: { health: 10 } }
                },
                starterInventory: [],
                quickActions: [
                    { icon: 'üåæ', label: 'Coltiva', prefix: 'Coltivo ' },
                    { icon: 'üöú', label: 'Lavora', prefix: 'Lavoro su ' },
                    { icon: 'üß∫', label: 'Raccogli', prefix: 'Raccolgo ' },
                    { icon: 'üêë', label: 'Cura', prefix: 'Curo ' }
                ]
            },
            pirate: {
                name: 'Piratesco',
                currency: { name: 'Dobloni', short: 'DOB', symbol: 'ü™ô' },
                resolution: 'Tira 1d12 + stat (FOR/NAV/AST/CAR) contro 7-13; 1 ammutinamento, 12+ bottino ricco.',
                stats: [
                    { id: 'for', label: 'Forza', short: 'FOR', base: 10 },
                    { id: 'nav', label: 'Navigazione', short: 'NAV', base: 10 },
                    { id: 'ast', label: 'Astuzia', short: 'AST', base: 10 },
                    { id: 'car', label: 'Carisma', short: 'CAR', base: 10 }
                ],
                origins: {
                    sailor: { name: 'Marinaio', icon: '‚öì', desc: 'Vive sul ponte', bonuses: { nav: 2, for: 1 } },
                    privateer: { name: 'Corsaro', icon: 'üè¥‚Äç‚ò†Ô∏è', desc: 'Lettera di corsa', bonuses: { ast: 1, car: 2 } },
                    islander: { name: 'Isolano', icon: 'üèùÔ∏è', desc: 'Figlio del mare', bonuses: { nav: 1, for: 1, car: 1 } }
                },
                archetypes: {
                    captain: { name: 'Capitano', icon: 'üß≠', desc: 'Guida la ciurma', stat: 'car', hp: 12, mp: 2, skills: ['Comando', 'Motivazione'] },
                    gunner: { name: 'Cannoniere', icon: 'üéá', desc: 'Spara preciso', stat: 'for', hp: 13, mp: 0, skills: ['Artiglieria', 'Riparazioni'] },
                    navigator: { name: 'Navigatore', icon: 'üß≠', desc: 'Legge rotte', stat: 'nav', hp: 11, mp: 0, skills: ['Navigazione', 'Meteo'] }
                },
                items: {
                    rum: { name: 'Rum della Ciurma', icon: 'ü•É', type: 'consumable', desc: 'Rum scuro in una bottiglia senza etichetta. Brucia la gola ma scalda l\'anima del marinaio.', effect: { stamina: 15, hunger: 5 } },
                    hardtack: { name: 'Galletta di Mare', icon: 'ü•ñ', type: 'consumable', desc: 'Biscotto duro come pietra che dura mesi. Meglio ammollarlo nel rum prima di morderlo.', effect: { hunger: 20 } },
                    bandage: { name: 'Bendaggio da Bordo', icon: 'ü©π', type: 'consumable', desc: 'Strisce di stoffa dalla cambusa. Non sono pulite, ma chiudono le ferite da sciabola.', effect: { health: 15 } }
                },
                starterInventory: [],
                quickActions: [
                    { icon: 'üí¨', label: 'Arremba', prefix: 'Arrembo ' },
                    { icon: '‚öì', label: 'Manovra', prefix: 'Manovro verso ' },
                    { icon: 'üéá', label: 'Spara', prefix: 'Sparo con i cannoni su ' },
                    { icon: 'üß≠', label: 'Rotta', prefix: 'Traccio una rotta per ' }
                ]
            },
            spy: {
                name: 'Spionaggio',
                currency: { name: 'Crediti', short: 'CR', symbol: '¬§' },
                resolution: 'Tira 2d6 + stat (FUR/AST/TEC/COP) contro 6-14; 6-7 allarme, 8-9 info parziali, 10-11 successo, 12+ colpo perfetto.',
                stats: [
                    { id: 'fur', label: 'Furtivit√†', short: 'FUR', base: 10 },
                    { id: 'ast', label: 'Astuzia', short: 'AST', base: 10 },
                    { id: 'tec', label: 'Tecnologia', short: 'TEC', base: 10 },
                    { id: 'cop', label: 'Copertura', short: 'COP', base: 10 }
                ],
                origins: {
                    analyst: { name: 'Analista', icon: 'üì°', desc: 'Intelligence da scrivania', bonuses: { tec: 2, ast: 1 } },
                    field: { name: 'Agente sul campo', icon: 'üï∂Ô∏è', desc: 'Operazioni coperte', bonuses: { fur: 2, cop: 1 } },
                    handler: { name: 'Referente', icon: '‚òéÔ∏è', desc: 'Gestisce contatti', bonuses: { ast: 2, cop: 1 } }
                },
                archetypes: {
                    infiltrator: { name: 'Infiltratore', icon: 'üïµÔ∏è', desc: 'Si muove invisibile', stat: 'fur', hp: 11, mp: 3, skills: ['Infiltrazione', 'Scasso'] },
                    hacker: { name: 'Hacker', icon: 'üíª', desc: 'Domina i sistemi', stat: 'tec', hp: 9, mp: 5, skills: ['Hacking', 'Sicurezza'] },
                    handler: { name: 'Handler', icon: '‚òéÔ∏è', desc: 'Coordina risorse', stat: 'cop', hp: 10, mp: 4, skills: ['Contatti', 'Copertura'] }
                },
                items: {
                    energy: { name: 'Capsula Energetica', icon: '‚ö°', type: 'consumable', desc: 'Una pillola classificata che elimina la stanchezza per ore. Gli effetti collaterali sono segreti.', effect: { stamina: 25 } },
                    gadget: { name: 'Gadget Q-Tech', icon: 'üìü', type: 'gear', desc: 'Un dispositivo multifunzione dall\'aspetto innocuo. Scanner, jammer e localizzatore in uno.' },
                    medkit: { name: 'Kit Medico Compatto', icon: 'ü©∫', type: 'consumable', desc: 'Un astuccio nero con suture rapide e antidolorifici. Progettato per auto-medicazione sul campo.', effect: { health: 20 } }
                },
                starterInventory: [],
                quickActions: [
                    { icon: 'üëÅÔ∏è', label: 'Osserva', prefix: 'Osservo ' },
                    { icon: 'üíª', label: 'Hack', prefix: 'Hackero ' },
                    { icon: 'üï∂Ô∏è', label: 'Copertura', prefix: 'Mantengo la copertura mentre ' },
                    { icon: 'üìû', label: 'Contatto', prefix: 'Chiamo il contatto per ' }
                ]
            }
        };
// ==================== UTILITIES ====================
        const $ = id => document.getElementById(id);
        const $$ = sel => document.querySelectorAll(sel);

        function resolveGenreKey(story) {
            const raw = (story?.genre || '').toString().toLowerCase();
            if (raw && GENRES[raw]) return raw;
            const setting = (story?.setting || '').toString().toLowerCase();
            if (setting.includes('sport') || setting.includes('calcio')) return 'sport';
            if (setting.includes('business') || setting.includes('economia')) return 'business';
            if (setting.includes('crime') || setting.includes('mafia') || setting.includes('gang')) return 'crime';
            if (setting.includes('storico') || setting.includes('roma') || setting.includes('rinascimento')) return 'historical';
            if (setting.includes('militare') || setting.includes('guerra') || setting.includes('war')) return 'military';
            if (setting.includes('diplomatic') || setting.includes('diplomatico')) return 'diplomatic';
            if (setting.includes('rurale') || setting.includes('agricolo') || setting.includes('contadino')) return 'rural';
            if (setting.includes('pirata') || setting.includes('piratesco') || setting.includes('pirate')) return 'pirate';
            if (setting.includes('spia') || setting.includes('spionaggio') || setting.includes('spy')) return 'spy';
            if (setting.includes('contemporaneo') || setting.includes('moderno')) return 'contemporary';
            return 'fantasy';
        }

        function getGenreConfig(story = G.currentStory) {
            return GENRES[resolveGenreKey(story)] || GENRES.fantasy;
        }

        function getItemCatalog(source = {}) {
            const genreKey = source.genre || resolveGenreKey(source.story || source.currentStory || G.currentStory);
            return (GENRES[genreKey] && GENRES[genreKey].items) || GENRES.fantasy.items;
        }

        function getSecondaryResourceConfig(source = {}) {
            const cfg = getGenreConfig(source);
            const raw = cfg.secondaryResource || {};
            const merged = {
                ...DEFAULT_SECONDARY_RESOURCE,
                ...raw
            };

            const defaultAttrPriority = Array.isArray(DEFAULT_SECONDARY_RESOURCE.attrPriority) ? DEFAULT_SECONDARY_RESOURCE.attrPriority : [];
            merged.attrPriority = Array.isArray(raw.attrPriority) && raw.attrPriority.length
                ? [...raw.attrPriority]
                : [...defaultAttrPriority];

            const aliasSeed = [
                ...(DEFAULT_SECONDARY_RESOURCE.aliases || []),
                ...(raw.aliases || []),
                DEFAULT_SECONDARY_RESOURCE.key,
                merged.key,
                'mana',
                'secondary',
                'risorsa',
                'resource'
            ].filter(Boolean);
            merged.aliases = Array.from(new Set(aliasSeed.map(a => a.toString().toLowerCase())));

            merged.modMultiplier = raw.modMultiplier ?? DEFAULT_SECONDARY_RESOURCE.modMultiplier ?? 1;
            merged.scale = raw.scale ?? DEFAULT_SECONDARY_RESOURCE.scale ?? 1;
            merged.className = raw.className || DEFAULT_SECONDARY_RESOURCE.className;
            merged.label = raw.label || DEFAULT_SECONDARY_RESOURCE.label;
            merged.icon = raw.icon || DEFAULT_SECONDARY_RESOURCE.icon;
            merged.baseField = raw.baseField || DEFAULT_SECONDARY_RESOURCE.baseField || 'mp';
            merged.levelUpBonus = raw.levelUpBonus ?? DEFAULT_SECONDARY_RESOURCE.levelUpBonus ?? 0;
            merged.defaultMax = raw.defaultMax ?? DEFAULT_SECONDARY_RESOURCE.defaultMax ?? 0;
            merged.startFull = raw.startFull ?? DEFAULT_SECONDARY_RESOURCE.startFull ?? true;
            merged.includeMod = raw.includeMod ?? DEFAULT_SECONDARY_RESOURCE.includeMod ?? false;
            merged.startPercent = raw.startPercent ?? DEFAULT_SECONDARY_RESOURCE.startPercent ?? 0.5;

            return merged;
        }

        function buildSecondaryResourceState({ config, archetype, attrs }) {
            if (!config) return null;
            const attrPriority = Array.isArray(config.attrPriority) ? config.attrPriority : [];
            const attrValue = attrPriority
                .map(id => (attrs && typeof attrs[id] === 'number') ? attrs[id] : undefined)
                .find(v => v !== undefined);

            const baseField = config.baseField || 'mp';
            const baseRaw = archetype && typeof archetype[baseField] === 'number' ? archetype[baseField] : 0;
            const base = baseRaw * (config.scale || 1);

            let bonus = 0;
            if (config.includeMod && typeof attrValue === 'number') {
                bonus = mod(attrValue) * (config.modMultiplier || 1);
            }

            let max = Math.round(base + bonus);
            if (!Number.isFinite(max) || max <= 0) {
                max = config.defaultMax || 0;
            }
            max = Math.max(0, max);

            let startValue = config.startFull ? max : Math.round(max * (config.startPercent || 0));
            if (max === 0) startValue = 0;
            const cur = Math.max(0, Math.min(max, startValue));

            return {
                key: config.key,
                label: config.label,
                icon: config.icon,
                className: config.className || 'mana',
                max,
                cur,
                aliases: [...(config.aliases || [])],
                levelUpBonus: config.levelUpBonus || 0
            };
        }

        function matchesSecondaryKey(rawKey, secondaryState) {
            if (!rawKey) return false;
            const normalized = rawKey.toString().toLowerCase();
            if (!secondaryState) return normalized === 'mana';
            if (secondaryState.key && secondaryState.key.toLowerCase() === normalized) return true;
            return (secondaryState.aliases || []).some(alias => alias.toLowerCase() === normalized);
        }

        function adjustSecondary(amount, character = G.character) {
            if (!character || !character.secondary) return;
            const sec = character.secondary;
            const delta = Number(amount) || 0;
            const newValue = Math.max(0, Math.min(sec.max, sec.cur + delta));
            sec.cur = newValue;
        }

        function formatSecondaryDelta(delta, secondaryState) {
            const icon = secondaryState?.icon || 'üíú';
            const label = secondaryState?.label || 'Risorsa';
            const value = Number(delta) || 0;
            const sign = value >= 0 ? '+' : '';
            return `${icon} ${sign}${value} ${label}`;
        }

        function formatCurrency(amount) {
            const currency = G.character?.currency || getGenreConfig().currency || { short: 'soldi' };
            const label = currency.symbol || currency.short || currency.name || 'soldi';
            const formatted = Math.abs(amount).toLocaleString('it-IT');
            if (amount < 0) {
                return `DEBITO: -${formatted} ${label}`;
            }
            return `${formatted} ${label}`;
        }

        function formatStatSummary(character = G.character) {
            const cfg = getGenreConfig({ genre: character?.genre, setting: G.currentStory?.setting });
            return (cfg.stats || []).map(st => `${st.short || st.id.toUpperCase()}: ${character?.attrs?.[st.id] ?? 0}`).join(', ');
        }

        function getResolutionText(story = G.currentStory) {
            const cfg = getGenreConfig(story);
            return cfg.resolution || 'Tira 1d20 + bonus rilevante contro una difficolta, adatta al genere.';
        }

        function notify(msg, type = 'info') {
            const n = document.createElement('div');
            n.className = `notification ${type}`;
            n.textContent = msg;
            document.body.appendChild(n);
            setTimeout(() => n.remove(), 3000);
        }

        function mod(val) { return Math.floor((val - 10) / 2); }
        function roll(sides) { return Math.floor(Math.random() * sides) + 1; }

        // Calcola il bonus di competenza basato sul livello (stile D&D 5e)
        function getProficiencyBonus() {
            if (!G.character) return 2;
            const level = G.character.level || 1;
            return Math.floor((level - 1) / 4) + 2; // +2 a lv1, +3 a lv5, +4 a lv9, +5 a lv13, +6 a lv17
        }

        // Esegue un tiro di abilit√† D&D-style e restituisce il risultato
        function performSkillCheck(attribute, difficulty = 10, skillName = '') {
            if (!G.character) return { success: false, roll: 0, total: 0, critical: null };
            
            const c = G.character;
            const attrValue = c.attrs?.[attribute] || 10;
            const attrMod = mod(attrValue);
            const profBonus = getProficiencyBonus();
            
            // Bonus abilit√† se il personaggio ha questa skill
            const hasSkill = skillName && c.skills?.[skillName.toLowerCase()];
            const skillBonus = hasSkill ? profBonus : 0;
            
            // Tiro d20
            const diceRoll = roll(20);
            const total = diceRoll + attrMod + skillBonus;
            
            // Gestione critici
            let critical = null;
            if (diceRoll === 1) critical = 'failure';
            else if (diceRoll === 20) critical = 'success';
            
            // Determina successo
            let success = false;
            if (critical === 'success') success = true;
            else if (critical === 'failure') success = false;
            else success = total >= difficulty;
            
            // Margine di successo/fallimento
            const margin = total - difficulty;
            
            return {
                success,
                roll: diceRoll,
                attrMod,
                skillBonus,
                total,
                difficulty,
                margin,
                critical,
                attribute,
                skillName
            };
        }

        // Calcola il bonus di un NPC basato su livello e attributo
        function getNPCBonus(npc, attribute) {
            if (!npc) return 0;
            const attrValue = npc.stats?.[attribute] || 10;
            const attrMod = mod(attrValue);
            const npcLevel = npc.level || 1;
            const profBonus = Math.floor((npcLevel - 1) / 4) + 2;
            return attrMod + profBonus;
        }

        // Trova un NPC per nome
        function findNPC(name) {
            return G.worldMemory.npcs.find(n => n.name.toLowerCase() === name.toLowerCase());
        }

        // Tiro contrapposto: giocatore vs NPC
        function performContestedRoll(playerAttr, npcName, npcAttr, playerSkill = '') {
            const npc = findNPC(npcName);
            const playerResult = performSkillCheck(playerAttr, 10, playerSkill); // CD base 10
            
            // Tiro NPC
            const npcRoll = roll(20);
            const npcBonus = npc ? getNPCBonus(npc, npcAttr) : 0;
            const npcTotal = npcRoll + npcBonus;
            const npcLevel = npc?.level || 1;
            const npcThreat = npc?.threat || 'low';
            
            // Determina vincitore
            let playerWins = playerResult.total >= npcTotal;
            
            // Critici sovrascrivono
            if (playerResult.critical === 'success') playerWins = true;
            else if (playerResult.critical === 'failure') playerWins = false;
            else if (npcRoll === 20) playerWins = false;
            else if (npcRoll === 1) playerWins = true;
            
            return {
                player: playerResult,
                npc: {
                    name: npcName,
                    roll: npcRoll,
                    bonus: npcBonus,
                    total: npcTotal,
                    level: npcLevel,
                    threat: npcThreat,
                    critical: npcRoll === 20 ? 'success' : (npcRoll === 1 ? 'failure' : null)
                },
                playerWins,
                margin: playerResult.total - npcTotal
            };
        }

        // Mostra risultato tiro contrapposto
        function showContestedRollResult(result, actionDesc = 'confronto') {
            let msg = `‚öîÔ∏è ${actionDesc}: `;
            msg += `Tu D20(${result.player.roll})+${result.player.attrMod + result.player.skillBonus}=${result.player.total}`;
            msg += ` vs ${result.npc.name} D20(${result.npc.roll})+${result.npc.bonus}=${result.npc.total}`;
            
            if (result.player.critical === 'success') {
                msg += ' | ‚ú® TUO CRITICO!';
            } else if (result.player.critical === 'failure') {
                msg += ' | üíÄ TUO FALLIMENTO CRITICO!';
            } else if (result.npc.critical === 'success') {
                msg += ` | ‚ö° ${result.npc.name} CRITICO!`;
            } else if (result.npc.critical === 'failure') {
                msg += ` | üòÖ ${result.npc.name} fallisce!`;
            }
            
            if (result.playerWins) {
                msg += result.margin >= 5 ? ' | ‚úÖ Vinci nettamente!' : ' | ‚úÖ Vinci!';
            } else {
                msg += result.margin <= -5 ? ' | ‚ùå Perdi nettamente' : ' | ‚ùå Perdi';
            }
            
            // Info livello NPC se significativo
            if (result.npc.level > 1) {
                msg += ` [NPC Lv${result.npc.level}]`;
            }
            
            addStoryEntry(msg, 'system');
            return result;
        }

        // Mostra il risultato del tiro come messaggio di sistema (non nel racconto)
        function showSkillCheckResult(result, actionDesc = 'azione') {
            const c = G.character;
            let msg = `üé≤ Tiro ${actionDesc}: D20(${result.roll})`;
            if (result.attrMod !== 0) msg += ` ${result.attrMod >= 0 ? '+' : ''}${result.attrMod} (${result.attribute})`;
            if (result.skillBonus > 0) msg += ` +${result.skillBonus} (abilit√†)`;
            msg += ` = ${result.total} vs CD ${result.difficulty}`;
            
            if (result.critical === 'success') {
                msg += ' | ‚ú® SUCCESSO CRITICO!';
            } else if (result.critical === 'failure') {
                msg += ' | üíÄ FALLIMENTO CRITICO!';
            } else if (result.success) {
                msg += result.margin >= 5 ? ' | ‚úÖ Successo netto!' : ' | ‚úÖ Successo';
            } else {
                msg += result.margin <= -5 ? ' | ‚ùå Fallimento grave' : ' | ‚ùå Fallimento';
            }
            
            // Usa 'system' invece di 'dice-roll' per tenerlo separato dalla narrazione
            addStoryEntry(msg, 'system');
            
            return result;
        }

        function save() {
            localStorage.setItem('dnd_v4', JSON.stringify({
                stories: G.stories, saves: G.saves, settings: G.settings
            }));
        }

        function computeDayName(year, month, day) {
            try {
                const date = new Date(year, month - 1, day);
                const idx = date.getDay(); // 0-6
                return DAYS[idx] || 'Luned√¨';
            } catch (e) {
                return 'Luned√¨';
            }
        }

        function getStartTimeForStory(story) {
            const genreKey = resolveGenreKey(story);
            const presets = {
                fantasy: { day: 1, month: 3, year: 1400, hour: 8, minute: 0 },
                contemporary: { day: 2, month: 5, year: 2024, hour: 9, minute: 0 },
                sport: { day: 15, month: 8, year: 2024, hour: 10, minute: 0 },
                business: { day: 2, month: 4, year: 2023, hour: 9, minute: 0 },
                crime: { day: 7, month: 10, year: 1986, hour: 22, minute: 0 },
                historical: { day: 12, month: 6, year: 1520, hour: 8, minute: 0 },
                military: { day: 1, month: 11, year: 1943, hour: 5, minute: 0 },
                diplomatic: { day: 10, month: 9, year: 2025, hour: 10, minute: 0 },
                rural: { day: 20, month: 4, year: 1890, hour: 6, minute: 0 },
                pirate: { day: 5, month: 7, year: 1720, hour: 14, minute: 0 },
                spy: { day: 3, month: 3, year: 1968, hour: 21, minute: 0 }
            };
            const base = (story?.startTime) ? { ...story.startTime } : (presets[genreKey] || presets.fantasy);
            base.dayName = base.dayName || computeDayName(base.year, base.month, base.day);
            return base;
        }

        // Starter properties helpers (garantiscono beni iniziali coerenti)
        function applyStarterProperties(story) {
            if (!story || !story.starterProperties) return;
            story.starterProperties.forEach(p => {
                const name = (p.name || '').trim();
                if (!name) return;
                const already = (G.worldMemory.properties || []).some(prop => prop.name.toLowerCase() === name.toLowerCase());
                if (!already) addProperty(name, p.description || '', p.notes || '');
            });
        }

        // ==================== TIME MANAGEMENT ====================
        function getCurrentSeason() {
            return MONTHS[G.time.month - 1].season;
        }

        function getDaysInMonth(month, year) {
            if (month === 2 && year % 4 === 0) return 29;
            return MONTHS[month - 1].days;
        }

        function advanceTime(minutes) {
            G.time.minute += minutes;
            
            const hoursElapsed = minutes / 60;
            if (G.character && minutes > 0) {
                // Consumo risorse BILANCIATO e realistico
                // Una persona pu√≤ stare sveglia ~16 ore e senza cibo ~24 ore prima di problemi seri
                // Stamina: 100 in 16 ore = ~6.25/ora, usiamo 4/ora (pi√π tollerante)
                // Fame: 100 in 24 ore = ~4.2/ora, usiamo 3/ora (pi√π tollerante)
                // Importante: accumulo frazionario per evitare che 5 minuti consumino sempre 1 punto.
                if (!G.character._metabolismCarry) {
                    G.character._metabolismCarry = { stamina: 0, hunger: 0 };
                }
                const carry = G.character._metabolismCarry;
                carry.stamina += hoursElapsed * 4;
                carry.hunger += hoursElapsed * 3;

                const staminaLoss = Math.floor(carry.stamina);
                const hungerLoss = Math.floor(carry.hunger);
                carry.stamina -= staminaLoss;
                carry.hunger -= hungerLoss;
                
                const oldStamina = G.character.stamina.cur;
                const oldHunger = G.character.hunger.cur;
                
                G.character.stamina.cur = Math.max(0, G.character.stamina.cur - staminaLoss);
                G.character.hunger.cur = Math.max(0, G.character.hunger.cur - hungerLoss);
                
                // Feedback dettagliato per tempo significativo (pi√π di 15 minuti)
                if (minutes >= 15) {
                    const staminaDelta = oldStamina - G.character.stamina.cur;
                    const hungerDelta = oldHunger - G.character.hunger.cur;
                    
                    // Formatta il tempo passato
                    let timeDesc = '';
                    if (minutes >= 1440) {
                        timeDesc = `${Math.floor(minutes/1440)} giorno/i`;
                    } else if (minutes >= 60) {
                        const h = Math.floor(minutes/60);
                        const m = minutes % 60;
                        timeDesc = m > 0 ? `${h}h ${m}min` : `${h} ora/e`;
                    } else {
                        timeDesc = `${minutes} minuti`;
                    }
                    
                    let consumeMsg = `‚è±Ô∏è ${timeDesc}`;
                    if (staminaDelta > 0) consumeMsg += ` | -${staminaDelta}‚ö°`;
                    if (hungerDelta > 0) consumeMsg += ` | -${hungerDelta}üçñ`;
                    addStoryEntry(consumeMsg, 'system');
                }
                
                // Penalit√† per fame/stanchezza critica - RIDOTTE per realismo
                // La morte per fame richiede giorni, non ore
                if (G.character.hunger.cur <= 0) {
                    // Perde HP solo se passa almeno 1 ora senza cibo E fame a zero
                    if (hoursElapsed >= 1) {
                        const hpLoss = Math.ceil(hoursElapsed * 0.5); // Ridotto da 3 a 0.5/ora
                        if (hpLoss > 0) {
                            G.character.health.cur = Math.max(1, G.character.health.cur - hpLoss);
                            addStoryEntry(`‚ö†Ô∏è Stai morendo di fame! -${hpLoss} HP`, 'system');
                        }
                    }
                }
                if (G.character.stamina.cur <= 0) {
                    // Esaurimento: rischio svenimento, non morte immediata
                    if (hoursElapsed >= 1) {
                        const hpLoss = Math.ceil(hoursElapsed * 0.3); // Ridotto da 2 a 0.3/ora
                        if (hpLoss > 0) {
                            G.character.health.cur = Math.max(1, G.character.health.cur - hpLoss);
                            addStoryEntry(`‚ö†Ô∏è Sei completamente esausto! -${hpLoss} HP`, 'system');
                        }
                    }
                }
            }
            
            while (G.time.minute >= 60) {
                G.time.minute -= 60;
                G.time.hour++;
            }
            
            while (G.time.hour >= 24) {
                G.time.hour -= 24;
                G.time.day++;
                const dayIndex = DAYS.indexOf(G.time.dayName);
                G.time.dayName = DAYS[(dayIndex + 1) % 7];
            }
            
            while (G.time.day > getDaysInMonth(G.time.month, G.time.year)) {
                G.time.day -= getDaysInMonth(G.time.month, G.time.year);
                G.time.month++;
                
                if (G.time.month > 12) {
                    G.time.month = 1;
                    G.time.year++;
                }
            }
            
            updateTimeDisplay();
            updateCharacterUI();
            checkStatusEffects();
        }

        function waitUntilHour(targetHour) {
            let minutesToWait = 0;
            let currentHour = G.time.hour;
            let currentMinute = G.time.minute;
            
            if (targetHour <= currentHour) {
                minutesToWait = (24 - currentHour + targetHour) * 60 - currentMinute;
            } else {
                minutesToWait = (targetHour - currentHour) * 60 - currentMinute;
            }
            
            advanceTime(minutesToWait);
            return minutesToWait;
        }

        function getTimePeriod() {
            const h = G.time.hour;
            if (h >= 5 && h < 7) return { name: 'Alba', icon: '?' };
            if (h >= 7 && h < 12) return { name: 'Mattina', icon: '?' };
            if (h >= 12 && h < 14) return { name: 'Mezzogiorno', icon: '?' };
            if (h >= 14 && h < 18) return { name: 'Pomeriggio', icon: '?' };
            if (h >= 18 && h < 21) return { name: 'Sera', icon: '?' };
            if (h >= 21 || h < 5) return { name: 'Notte', icon: '?' };
            return { name: 'Giorno', icon: '?' };
        }

        function getTimeString() {
            return `${G.time.hour.toString().padStart(2, '0')}:${G.time.minute.toString().padStart(2, '0')}`;
        }

        function getFullTimeString() {
            const period = getTimePeriod();
            const season = getCurrentSeason();
            return `${G.time.dayName} ${G.time.day} ${MONTHS[G.time.month - 1].name} ${G.time.year}, ${getTimeString()} (${period.name}, ${season})`;
        }

        function updateTimeDisplay() {
            const period = getTimePeriod();
            $('time-icon').textContent = period.icon;
            $('time-text').textContent = `${getTimeString()}`;
            if ($('time-date')) {
                $('time-date').textContent = `${G.time.dayName} ${G.time.day} ${MONTHS[G.time.month - 1].name} (${getCurrentSeason()})`;
            }
            if ($('wait-current-time')) {
                $('wait-current-time').textContent = `${getTimeString()} - ${period.name}`;
            }
        }

        function checkStatusEffects() {
            if (!G.character) return;
            const c = G.character;
            const currSymbol = c.currency?.symbol || c.currency?.short || 'soldi';
            
            // Morte
            if (c.health.cur <= 0) {
                triggerGameOver('Le tue ferite sono troppo gravi... la tua avventura finisce qui.');
                return;
            }
            
            // Gestione Debiti
            if (c.gold < 0) {
                const debtLevel = Math.abs(c.gold);
                const startingGold = 100; // Riferimento base
                
                if (debtLevel >= startingGold * 100) {
                    // Debito catastrofico - Fallimento totale
                    c.health.cur = 0;
                    triggerGameOver(`BANCAROTTA TOTALE! I debiti di ${debtLevel.toLocaleString('it-IT')} ${currSymbol} ti hanno distrutto.`);
                } else if (debtLevel >= startingGold * 50) {
                    // Debito grave - Avviso finale
                    if (!c._debtWarning3) {
                        addStoryEntry(`üö® CRISI FINANZIARIA! Debito: ${debtLevel.toLocaleString('it-IT')} ${currSymbol}. Devi vendere tutto o troverai i creditori alla porta!`, 'system');
                        c._debtWarning3 = true;
                    }
                } else if (debtLevel >= startingGold * 10) {
                    // Debito significativo
                    if (!c._debtWarning2) {
                        addStoryEntry(`‚ö†Ô∏è DEBITI CRESCENTI: ${debtLevel.toLocaleString('it-IT')} ${currSymbol}. Trova un modo per guadagnare o dovrai vendere propriet√†!`, 'system');
                        c._debtWarning2 = true;
                    }
                } else if (debtLevel >= startingGold * 2) {
                    // Primo avviso debito
                    if (!c._debtWarning1) {
                        addStoryEntry(`‚ö†Ô∏è Sei in debito di ${debtLevel.toLocaleString('it-IT')} ${currSymbol}. Attenzione alle spese!`, 'system');
                        c._debtWarning1 = true;
                    }
                }
                
                // Reset warning flags quando torni in positivo
            } else {
                c._debtWarning1 = false;
                c._debtWarning2 = false;
                c._debtWarning3 = false;
            }
            
            // Avvisi fame critica
            if (c.hunger.cur <= 10 && c.hunger.cur > 0) {
                if (!c._hungerWarning) {
                    addStoryEntry('üçñ‚ö†Ô∏è Hai fame! Mangia qualcosa o perderai salute.', 'system');
                    c._hungerWarning = true;
                }
            } else if (c.hunger.cur > 30) {
                c._hungerWarning = false;
            }
            
            // Avvisi energia critica
            if (c.stamina.cur <= 10 && c.stamina.cur > 0) {
                if (!c._staminaWarning) {
                    addStoryEntry('‚ö°‚ö†Ô∏è Sei esausto! Riposati o le tue azioni saranno compromesse.', 'system');
                    c._staminaWarning = true;
                }
            } else if (c.stamina.cur > 30) {
                c._staminaWarning = false;
            }
            
            // Avviso salute critica
            if (c.health.cur <= c.health.max * 0.2 && c.health.cur > 0) {
                if (!c._healthWarning) {
                    addStoryEntry('‚ù§Ô∏è‚ö†Ô∏è Salute critica! Curati subito!', 'system');
                    c._healthWarning = true;
                }
            } else if (c.health.cur > c.health.max * 0.3) {
                c._healthWarning = false;
            }
        }

        function doRest() {
            if (!G.character) return;
            if (G.isProcessing) { notify('Attendi...', 'error'); return; }
            const c = G.character;
            
            // Riposo completo: 8 ore
            advanceTime(480);
            const oldStam = c.stamina.cur;
            const oldHp = c.health.cur;
            c.stamina.cur = c.stamina.max;
            c.hunger.cur = Math.max(0, c.hunger.cur - 25);
            
            // Guarigione in base alla fame: se ben nutrito guarisci di pi√π
            let hpRegen = 15;
            if (c.hunger.cur > 60) hpRegen = 30;
            else if (c.hunger.cur > 30) hpRegen = 20;
            else if (c.hunger.cur <= 10) hpRegen = 5;
            c.health.cur = Math.min(c.health.max, c.health.cur + hpRegen);
            
            // Ricarica parziale risorsa secondaria
            if (c.secondary && c.secondary.max > 0) {
                const secRegen = Math.ceil(c.secondary.max * 0.3);
                c.secondary.cur = Math.min(c.secondary.max, c.secondary.cur + secRegen);
            }
            
            const stamGain = c.stamina.cur - oldStam;
            const hpGain = c.health.cur - oldHp;
            let msg = `üò¥ Hai riposato per 8 ore.`;
            if (stamGain > 0) msg += ` ‚ö°+${stamGain} Energia.`;
            if (hpGain > 0) msg += ` ‚ù§Ô∏è+${hpGain} HP.`;
            msg += ` üçñ-25 Saziet√†. Ora sono le ${getTimeString()}.`;
            addStoryEntry(msg, 'mechanic');
            updateCharacterUI();
            
            generateAI(`Il protagonista ha dormito per 8 ore. Ora √® ${getFullTimeString()}. Si sveglia con ${c.health.cur}/${c.health.max} HP e stamina piena. Descrivi brevemente come si sveglia e cosa trova. Usa [POSIZIONE:] per la posizione.`);
        }

        function doEat() {
            if (!G.character) return;
            if (G.isProcessing) { notify('Attendi...', 'error'); return; }
            const c = G.character;
            const catalog = getItemCatalog({ genre: c.genre, story: G.currentStory });
            const currencyLabel = c.currency?.short || 'soldi';
            
            // Cerca cibo nell'inventario (priorit√†: effetto fame pi√π grande)
            let bestFoodIdx = -1;
            let bestHunger = 0;
            c.inventory.forEach((item, idx) => {
                if (!item) return;
                const normalizedId = typeof item.id === 'string' ? item.id.replace(/\s+/g, '_') : item.id;
                const data = catalog[normalizedId] || catalog[item.id] || {};
                const hungerVal = data?.effect?.hunger || 0;
                const isFood = hungerVal > 0 || (item.name && /cibo|pane|frutto|mela|carne|pesce|formaggio|pasto|razione/i.test(item.name));
                if (isFood && hungerVal >= bestHunger) {
                    bestFoodIdx = idx;
                    bestHunger = hungerVal || 30;
                }
            });
            
            if (bestFoodIdx !== -1) {
                const item = c.inventory[bestFoodIdx];
                const normalizedId = typeof item.id === 'string' ? item.id.replace(/\s+/g, '_') : item.id;
                const data = catalog[normalizedId] || catalog[item.id] || {};
                const hungerGain = data?.effect?.hunger || 30;
                const staminaGain = data?.effect?.stamina || 5;
                
                c.hunger.cur = Math.min(c.hunger.max, c.hunger.cur + hungerGain);
                c.stamina.cur = Math.min(c.stamina.max, c.stamina.cur + staminaGain);
                
                item.count--;
                if (item.count <= 0) c.inventory.splice(bestFoodIdx, 1);
                
                addStoryEntry(`üçñ Mangi ${item.name || data?.name || 'cibo'}. (+${hungerGain} saziet√†, +${staminaGain} energia)`, 'mechanic');
                advanceTime(15);
                updateCharacterUI();
            } else if (c.gold >= 5) {
                // Compra un pasto
                c.gold -= 5;
                c.hunger.cur = Math.min(c.hunger.max, c.hunger.cur + 50);
                c.stamina.cur = Math.min(c.stamina.max, c.stamina.cur + 10);
                addStoryEntry(`üçñ Compri e mangi un pasto. (-5 ${currencyLabel}, +50 saziet√†, +10 energia)`, 'mechanic');
                advanceTime(30);
                updateCharacterUI();
                generateAI(`Il protagonista ha comprato e mangiato un pasto. Descrivi brevemente la scena.`);
            } else {
                // Cerca frutti/bacche (azione gratuita ma minore)
                if (Math.random() < 0.6) {
                    c.hunger.cur = Math.min(c.hunger.max, c.hunger.cur + 15);
                    addStoryEntry(`ü´ê Trovi qualcosa da mangiare nei dintorni. (+15 saziet√†)`, 'mechanic');
                    advanceTime(20);
                    updateCharacterUI();
                } else {
                    notify('Non hai cibo, soldi, e non trovi nulla da mangiare qui!', 'error');
                }
            }
        }

        function doCure() {
            if (!G.character) return;
            if (G.isProcessing) { notify('Attendi...', 'error'); return; }
            const c = G.character;
            const catalog = getItemCatalog({ genre: c.genre, story: G.currentStory });
            const currencyLabel = c.currency?.short || 'soldi';
            
            if (c.health.cur >= c.health.max) {
                notify('Sei gi√† in piena salute!', 'info');
                return;
            }
            
            // Cerca medicine/pozioni nell'inventario
            let healIdx = -1;
            let healAmount = 0;
            c.inventory.forEach((item, idx) => {
                if (!item) return;
                const normalizedId = typeof item.id === 'string' ? item.id.replace(/\s+/g, '_') : item.id;
                const data = catalog[normalizedId] || catalog[item.id] || {};
                const hpVal = data?.effect?.health || data?.effect?.hp || 0;
                const isHeal = hpVal > 0 || (item.name && /pozion|benda|cura|medic|erba|unguento|elisir|antidoto/i.test(item.name));
                if (isHeal && hpVal >= healAmount) {
                    healIdx = idx;
                    healAmount = hpVal || 25;
                }
            });
            
            if (healIdx !== -1) {
                const item = c.inventory[healIdx];
                c.health.cur = Math.min(c.health.max, c.health.cur + healAmount);
                item.count--;
                if (item.count <= 0) c.inventory.splice(healIdx, 1);
                addStoryEntry(`‚ù§Ô∏è‚Äçü©π Usi ${item.name || 'medicina'}. (+${healAmount} HP)`, 'mechanic');
                advanceTime(5);
                updateCharacterUI();
            } else if (c.gold >= 15) {
                // Paga per cure
                const heal = Math.min(c.health.max - c.health.cur, 40);
                c.gold -= 15;
                c.health.cur = Math.min(c.health.max, c.health.cur + heal);
                addStoryEntry(`‚ù§Ô∏è‚Äçü©π Paghi per delle cure. (-15 ${currencyLabel}, +${heal} HP)`, 'mechanic');
                advanceTime(30);
                updateCharacterUI();
                generateAI(`Il protagonista si √® fatto curare. Descrivi brevemente la scena della cura.`);
            } else {
                // Auto-cura base (bendaggi improvvisati)
                if (c.stamina.cur >= 20) {
                    const heal = Math.min(c.health.max - c.health.cur, 10);
                    c.stamina.cur -= 15;
                    c.health.cur = Math.min(c.health.max, c.health.cur + heal);
                    addStoryEntry(`ü©π Ti fasci le ferite con quello che hai. (-15 energia, +${heal} HP)`, 'mechanic');
                    advanceTime(15);
                    updateCharacterUI();
                } else {
                    notify('Non hai medicine, soldi, n√© energia per auto-curarti!', 'error');
                }
            }
        }

        function doTrain() {
            if (!G.character) return;
            if (G.isProcessing) { notify('Attendi...', 'error'); return; }
            const c = G.character;
            
            if (c.stamina.cur < 30) {
                notify('Troppo stanco per allenarti! Riposa prima.', 'error');
                return;
            }
            if (c.hunger.cur < 20) {
                notify('Troppo affamato per allenarti! Mangia prima.', 'error');
                return;
            }
            
            c.stamina.cur -= 25;
            c.hunger.cur = Math.max(0, c.hunger.cur - 15);
            
            // Guadagna EXP dall'allenamento
            const expGain = 5 + Math.floor(Math.random() * 8);
            c.exp.cur += expGain;
            
            addStoryEntry(`üí™ Ti alleni duramente. (-25 energia, -15 saziet√†, +${expGain} EXP)`, 'mechanic');
            advanceTime(90);
            checkLevelUp();
            updateCharacterUI();
            
            generateAI(`Il protagonista si √® allenato per circa 1.5 ore. Ha guadagnato esperienza. Descrivi brevemente la sessione di allenamento in base al genere e all'archetipo.`);
        }

        function updateActionBar() {
            if (!G.character) return;
            const c = G.character;
            const restBtn = $('btn-rest');
            const eatBtn = $('btn-eat');
            const healBtn = $('btn-heal');
            const trainBtn = $('btn-train');
            
            if (restBtn) restBtn.disabled = G.isProcessing;
            if (eatBtn) eatBtn.disabled = G.isProcessing;
            if (healBtn) healBtn.disabled = G.isProcessing || c.health.cur >= c.health.max;
            if (trainBtn) trainBtn.disabled = G.isProcessing || c.stamina.cur < 30 || c.hunger.cur < 20;
        }

        // ==================== QUICK ACTIONS ====================
        function getGenreActions(story) {
            const cfg = getGenreConfig(story);
            return cfg.quickActions || DEFAULT_ACTIONS;
        }

        function updateQuickActions() {
            const actions = G.currentStory ? getGenreActions(G.currentStory) : DEFAULT_ACTIONS;
            
            const html = actions.map(a => `
                <button class="quick-btn" data-prefix="${a.prefix}">
                    ${a.icon} ${a.label}
                </button>
            `).join('');
            
            $('quick-actions').innerHTML = html;
            
            $$('.quick-btn').forEach(btn => {
                btn.onclick = () => {
                    const prefix = btn.dataset.prefix;
                    $('action-input').value = prefix;
                    $('action-input').focus();
                };
            });
        }

        function load() {
            const d = localStorage.getItem('dnd_v4');
            if (d) {
                const p = JSON.parse(d);
                G.stories = p.stories || [];
                G.saves = p.saves || Array(6).fill(null);
                G.settings = { ...G.settings, ...p.settings };
            }
            // Migrazione: assicurati che la storia business abbia la propriet√† eredita
            let storiesChanged = false;
            G.stories = (G.stories || []).map(s => {
                if (s.title === 'Scalata al Successo' && !s.starterProperties) {
                    storiesChanged = true;
                    return {
                        ...s,
                        starterProperties: [
                            {
                                name: 'Emporio Rossi',
                                description: 'Il piccolo negozio di famiglia appena ereditato. Clientela locale fedele, margini stretti.',
                                notes: 'Puoi investire per ampliarlo o venderlo per fare cassa.'
                            }
                        ]
                    };
                }
                return s;
            });
            if (G.stories.length === 0) {
                G.stories = [
                    { 
                        id: 1, 
                        title: 'La Cripta dei Sussurri', 
                        setting: 'Fantasy Gotico', 
                        genre: 'fantasy',
                        difficulty: 'normal', 
                        desc: 'Un mondo gotico dove la nebbia avvolge antichi cimiteri. Il villaggio di Ravenhollow vive nella paura.', 
                        personality: 'Narratore misterioso e atmosferico. Crea tensione e suspense.', 
                        depth: 'Gli NPC hanno paure e segreti. Le scelte morali hanno conseguenze.',
                        prologue: 'La nebbia si alza lenta dal cimitero mentre attraversi i cancelli arrugginiti di Ravenhollow. Il villaggio sembra deserto, le finestre delle case sprangate. Solo la locanda "Il Corvo Stanco" mostra segni di vita.'
                    },
                    { 
                        id: 2, 
                        title: 'Scalata al Successo', 
                        setting: 'Contemporaneo / Business', 
                        genre: 'business',
                        difficulty: 'normal', 
                        desc: 'Una storia moderna. Hai ereditato un piccolo negozio e sogni di costruire un impero commerciale.', 
                        personality: 'Narratore realistico. Dialoghi naturali e moderni.', 
                        depth: 'Ogni decisione economica ha conseguenze. I rapporti contano.',
                        prologue: 'La serranda si alza con un cigolio familiare. "Emporio Rossi" - la vecchia insegna pende ancora sopra la porta. L\'avvocato ti ha dato le chiavi ieri, insieme a un conto quasi vuoto.',
                        starterProperties: [
                            {
                                name: 'Emporio Rossi',
                                description: 'Il piccolo negozio di famiglia appena ereditato. Clientela locale fedele, margini stretti.',
                                notes: 'Puoi investire per ampliarlo o venderlo per fare cassa.'
                            }
                        ]
                    }
                ];
                save();
            } else if (storiesChanged) {
                save();
            }
        }

        // ==================== SCREENS ====================
        function showScreen(id) {
            $$('.screen').forEach(s => s.classList.remove('active'));
            $(id).classList.add('active');
        }

        function openModal(id) { $(id).classList.add('active'); }
        function closeModal(id) { $(id).classList.remove('active'); }
        function closeAllModals() { $$('.modal-overlay').forEach(m => m.classList.remove('active')); }

        // ==================== HOME ====================
        function updateHome() {
            $('btn-continue').disabled = !G.isPlaying;
        }

        // ==================== CHARACTER ====================
        function createCharacter(name, origin, archetype) {
            const genreCfg = getGenreConfig(G.currentStory);
            const genreKey = resolveGenreKey(G.currentStory);
            const originData = genreCfg.origins[origin] || Object.values(genreCfg.origins)[0];
            const archetypeData = genreCfg.archetypes[archetype] || Object.values(genreCfg.archetypes)[0];

            const attrs = {};
            genreCfg.stats.forEach(stat => { attrs[stat.id] = stat.base || 10; });

            if (originData?.bonuses) {
                if (originData.bonuses.all) Object.keys(attrs).forEach(k => attrs[k] += originData.bonuses.all);
                else Object.entries(originData.bonuses).forEach(([k,v]) => { if(attrs[k] !== undefined) attrs[k] += v; });
            }

            const conValue = attrs.con ?? attrs.res ?? attrs.resp ?? 10;
            const conMod = mod(conValue);

            const secondaryConfig = getSecondaryResourceConfig({ genre: genreKey, setting: G.currentStory?.setting });
            const secondaryStateRaw = buildSecondaryResourceState({ config: secondaryConfig, archetype: archetypeData, attrs });
            const secondaryState = secondaryStateRaw || {
                key: secondaryConfig.key,
                label: secondaryConfig.label,
                icon: secondaryConfig.icon,
                className: secondaryConfig.className || 'mana',
                max: secondaryConfig.defaultMax || 0,
                cur: secondaryConfig.startFull ? (secondaryConfig.defaultMax || 0) : 0,
                aliases: secondaryConfig.aliases || [],
                levelUpBonus: secondaryConfig.levelUpBonus || 0
            };
            secondaryState.config = secondaryConfig;

            G.character = {
                name,
                origin: Object.keys(genreCfg.origins).find(k => genreCfg.origins[k] === originData),
                archetype: Object.keys(genreCfg.archetypes).find(k => genreCfg.archetypes[k] === archetypeData),
                genre: genreKey,
                currency: genreCfg.currency,
                level: 1,
                health: { cur: archetypeData.hp + conMod, max: archetypeData.hp + conMod },
                secondary: secondaryState,
                stamina: { cur: 100, max: 100 },
                hunger: { cur: 100, max: 100 },
                exp: { cur: 0, need: 100 },
                attrs,
                skills: {},
                inventory: (genreCfg.starterInventory || []).map(i => ({ ...i })),
                equipment: { weapon: null, armor: null, accessory: null },
                gold: 100
            };
            Object.defineProperty(G.character, 'mana', {
                get() { return this.secondary; },
                set(value) { this.secondary = value; },
                enumerable: false,
                configurable: true
            });
            
            if (archetypeData?.skills) {
                archetypeData.skills.forEach(s => G.character.skills[s] = mod(attrs[archetypeData.stat] || 10));
            }
        }

        function updateCharacterUI() {
            if (!G.character) return;
            const c = G.character;
            const genreCfg = getGenreConfig({ genre: c.genre, setting: G.currentStory?.setting });
            const o = genreCfg.origins[c.origin] || { name: c.origin || 'Origine' };
            const a = genreCfg.archetypes[c.archetype] || { name: c.archetype || 'Archetipo', icon: '?', stat: genreCfg.stats?.[0]?.id };

            const secondaryConfig = getSecondaryResourceConfig({ genre: c.genre, setting: G.currentStory?.setting });
            let secondaryState = c.secondary;
            if (!secondaryState) {
                const archetypeRef = genreCfg.archetypes?.[c.archetype];
                secondaryState = buildSecondaryResourceState({ config: secondaryConfig, archetype: archetypeRef, attrs: c.attrs }) || null;
                c.secondary = secondaryState;
            }
            if (secondaryState) {
                secondaryState.label = secondaryConfig.label;
                secondaryState.icon = secondaryConfig.icon;
                secondaryState.className = secondaryConfig.className || secondaryState.className || 'mana';
                secondaryState.aliases = secondaryConfig.aliases;
                secondaryState.key = secondaryConfig.key;
                secondaryState.levelUpBonus = secondaryConfig.levelUpBonus || secondaryState.levelUpBonus || 0;
                secondaryState.config = secondaryConfig;
            }

            const miniHealth = $('mini-health');
            const miniStamina = $('mini-stamina');
            const miniHunger = $('mini-hunger');
            if (miniHealth) {
                const percent = c.health.max > 0 ? (c.health.cur / c.health.max) * 100 : 0;
                miniHealth.style.width = `${Math.max(0, Math.min(100, percent))}%`;
                if (miniHealth.parentElement) miniHealth.parentElement.setAttribute('data-value', `${c.health.cur}/${c.health.max}`);
            }
            if (miniStamina) {
                const percent = c.stamina.max > 0 ? (c.stamina.cur / c.stamina.max) * 100 : 0;
                miniStamina.style.width = `${Math.max(0, Math.min(100, percent))}%`;
                if (miniStamina.parentElement) miniStamina.parentElement.setAttribute('data-value', `${c.stamina.cur}/${c.stamina.max}`);
            }
            if (miniHunger) {
                const percent = c.hunger.max > 0 ? (c.hunger.cur / c.hunger.max) * 100 : 0;
                miniHunger.style.width = `${Math.max(0, Math.min(100, percent))}%`;
                if (miniHunger.parentElement) miniHunger.parentElement.setAttribute('data-value', `${c.hunger.cur}/${c.hunger.max}`);
            }

            $('char-portrait').textContent = a.icon;
            $('char-name').textContent = c.name;
            $('char-class').textContent = `${o.name} / ${a.name} Lv. ${c.level}`;

            const statHealth = $('stat-health');
            const statHealthText = $('stat-health-text');
            const statSecondary = $('stat-secondary');
            const statSecondaryLabel = $('stat-secondary-label');
            const statSecondaryText = $('stat-secondary-text');
            const statStamina = $('stat-stamina');
            const statStaminaText = $('stat-stamina-text');
            const statHunger = $('stat-hunger');
            const statHungerText = $('stat-hunger-text');
            const statExp = $('stat-exp');
            const statExpText = $('stat-exp-text');

            if (statHealth) {
                const percent = c.health.max > 0 ? (c.health.cur / c.health.max) * 100 : 0;
                statHealth.style.width = `${Math.max(0, Math.min(100, percent))}%`;
            }
            if (statHealthText) statHealthText.textContent = `${c.health.cur}/${c.health.max}`;

            if (statSecondaryLabel && secondaryState) {
                statSecondaryLabel.textContent = `${secondaryState.icon || 'üíú'} ${secondaryState.label}`.trim();
            }
            if (statSecondary) {
                if (secondaryState) {
                    statSecondary.className = `stat-bar-fill ${secondaryState.className || 'mana'}`;
                    const percent = secondaryState.max > 0 ? (secondaryState.cur / secondaryState.max) * 100 : 0;
                    statSecondary.style.width = `${Math.max(0, Math.min(100, percent))}%`;
                } else {
                    statSecondary.className = 'stat-bar-fill mana';
                    statSecondary.style.width = '0%';
                }
            }
            if (statSecondaryText) {
                if (secondaryState && secondaryState.max > 0) {
                    statSecondaryText.textContent = `${secondaryState.cur}/${secondaryState.max}`;
                } else {
                    statSecondaryText.textContent = '--';
                }
            }

            if (statStamina) {
                const percent = c.stamina.max > 0 ? (c.stamina.cur / c.stamina.max) * 100 : 0;
                statStamina.style.width = `${Math.max(0, Math.min(100, percent))}%`;
            }
            if (statStaminaText) statStaminaText.textContent = `${c.stamina.cur}/${c.stamina.max}`;

            if (statHunger) {
                const percent = c.hunger.max > 0 ? (c.hunger.cur / c.hunger.max) * 100 : 0;
                statHunger.style.width = `${Math.max(0, Math.min(100, percent))}%`;
            }
            if (statHungerText) statHungerText.textContent = `${c.hunger.cur}/${c.hunger.max}`;

            if (statExp) {
                const percent = c.exp.need > 0 ? (c.exp.cur / c.exp.need) * 100 : 0;
                statExp.style.width = `${Math.max(0, Math.min(100, percent))}%`;
            }
            if (statExpText) statExpText.textContent = `${c.exp.cur}/${c.exp.need}`;

            const attrsHtml = (genreCfg.stats || []).map(stat => `
                <div class="attr-box">
                    <div class="attr-name">${stat.short || stat.id.toUpperCase()}</div>
                    <div class="attr-value">${c.attrs[stat.id] ?? 0}</div>
                    <div class="attr-mod">${mod(c.attrs[stat.id] ?? 10) >= 0 ? '+' : ''}${mod(c.attrs[stat.id] ?? 10)}</div>
                </div>
            `).join('');
            $('attrs-grid').innerHTML = attrsHtml;

            const skillsHtml = Object.entries(c.skills).map(([name, val]) => `
                <div class="skill-item">
                    <span>${name}</span>
                    <span class="${val >= 0 ? 'skill-bonus' : 'skill-malus'}">${val >= 0 ? '+' : ''}${val}</span>
                </div>
            `).join('');
            $('skills-list').innerHTML = skillsHtml || '<div class="skill-item">Nessuna abilit√†</div>';

            // Acquired Abilities
            const abilitiesHtml = G.worldMemory.acquiredAbilities.map(ab => `
                <div class="ability-item">
                    <span class="ability-name">‚ú® ${ab.name}</span>
                    <span class="ability-desc">${ab.description}</span>
                </div>
            `).join('');
            $('abilities-list').innerHTML = abilitiesHtml || '<div class="skill-item" style="font-style:italic;">Nessuna abilit√† acquisita</div>';

            // Inventory & Gold
            const catalog = getItemCatalog({ genre: c.genre, story: G.currentStory });
            const currencyLabel = c.currency?.symbol || c.currency?.short || 'soldi';
            const goldEl = $('inv-gold');
            if (c.gold < 0) {
                goldEl.innerHTML = `<span style="color: #c00; font-weight: bold;">DEBITO: ${Math.abs(c.gold).toLocaleString('it-IT')} ${currencyLabel}</span>`;
            } else {
                goldEl.textContent = `${c.gold.toLocaleString('it-IT')} ${currencyLabel}`;
            }
            
            // Calcolo slot occupati
            const itemCount = c.inventory.length;
            const totalSlots = Math.max(20, itemCount);
            if ($('inv-count')) $('inv-count').textContent = itemCount;
            if ($('inv-capacity')) $('inv-capacity').textContent = totalSlots;

            let invHtml = '';
            
            // Genera slot dinamici (minimo 20)
            for (let i = 0; i < totalSlots; i++) {
                const item = c.inventory[i];
                if (item) {
                    const normalizedId = typeof item.id === 'string' ? item.id.replace(/\s+/g, '_') : item.id;
                    const data = catalog[normalizedId] || catalog[item.id] || {};
                    const name = item.name || data.name || (item.id ? item.id.replace(/_/g, ' ') : 'Oggetto');
                    const icon = item.icon || data.icon || 'üì¶';
                    const desc = item.description || data.desc;
                    const value = item.value !== undefined ? item.value : data.value;
                    const tooltipParts = [name];
                    if (desc) tooltipParts.push(desc);
                    if (value !== undefined) tooltipParts.push(`Valore: ${formatCurrency(value)}`);
                    const tooltip = tooltipParts.join(' ‚Ä¢ ').replace(/"/g, "'");
                    // Aggiungiamo onclick per SELEZIONARE invece di usare direttamente
                    invHtml += `
                        <div class="inv-slot" onclick="selectItem(${i})" id="slot-${i}" title="${tooltip}">
                            ${icon}
                            ${item.count > 1 ? `<span class="count">${item.count}</span>` : ''}
                        </div>`;
                } else {
                    invHtml += `<div class="inv-slot empty"></div>`;
                }
            }
            $('inv-grid').innerHTML = invHtml;

            // Special Items
            const specialHtml = G.worldMemory.acquiredItems.map(item => `
                <div class="special-item">
                    <span class="special-item-icon">${item.icon || 'üîÆ'}</span>
                    <div class="special-item-info">
                        <div class="special-item-name">${item.name}</div>
                        <div class="special-item-desc">${item.description}</div>
                    </div>
                </div>
            `).join('');
            $('special-items-list').innerHTML = specialHtml || '<p style="color: var(--ink-light); font-style: italic;">Nessun oggetto speciale</p>';

            // Properties / Assets con statistiche complete
            const propertiesHtml = (G.worldMemory.properties || []).map(p => {
                const cond = getPropertyCondition(p.condition || 50);
                const valuation = calculatePropertyValue(p);
                const income = calculatePropertyIncome(p);
                const conditionPercent = p.condition || 50;
                
                // Inventario propriet√† con categorie
                const propertyInventory = Array.isArray(p.inventory) ? p.inventory : [];
                propertyInventory.forEach(ensurePropertyItemCategory);
                const totalUnits = propertyInventory.reduce((sum, item) => sum + (item?.count || 0), 0);
                
                const categorySections = Object.entries(PROPERTY_CATEGORY_INFO).map(([key, info]) => {
                    const items = propertyInventory.filter(item => ensurePropertyItemCategory(item) === key);
                    if (!items.length) return '';
                    const categoryTotal = items.reduce((sum, item) => sum + (item?.count || 0), 0);
                    const itemsHtml = items.map(item => {
                        const normalizedId = typeof item.id === 'string' ? item.id.replace(/\s+/g, '_') : item.id;
                        const data = catalog[normalizedId] || catalog[item.id] || {};
                        const fallbackName = item.id ? item.id.toString().replace(/_/g, ' ') : 'Oggetto';
                        const name = item.name || data.name || fallbackName;
                        const icon = item.icon || data.icon || 'üì¶';
                        const desc = item.description || data.desc || '';
                        const metaParts = [];
                        if (item.financial && Number.isFinite(item.balance)) {
                            metaParts.push(`Saldo ${formatCurrency(item.balance)}`);
                        } else if (Number.isFinite(item.value)) {
                            metaParts.push(`Valore ${formatCurrency(item.value)}`);
                        }
                        const detailParts = [...metaParts];
                        if (desc) detailParts.push(desc);
                        const metaHtml = detailParts.length ? `<div class="property-inv-meta">${detailParts.join(' ‚Ä¢ ')}</div>` : '';
                        const tooltipParts = [name, ...detailParts];
                        const tooltip = tooltipParts.filter(Boolean).join(' ‚Ä¢ ').replace(/"/g, "'");
                        return `
                            <div class="property-inv-item" title="${tooltip}">
                                <span class="property-inv-icon">${icon}</span>
                                <div class="property-inv-info">
                                    <div class="property-inv-name">${name}</div>
                                    ${metaHtml}
                                </div>
                                <span class="property-inv-qty">x${item.count || 1}</span>
                            </div>
                        `;
                    }).join('');
                    return `
                        <div class="property-category-block">
                            <div class="property-category-heading">${info.icon} ${info.label} <span class="property-category-count">(${categoryTotal})</span></div>
                            <div class="property-inv-grid">${itemsHtml}</div>
                        </div>
                    `;
                }).filter(Boolean).join('');

                const inventoryHtml = totalUnits > 0 ? `
                    <div class="property-inventory-section">
                        <div class="property-inventory-header">
                            <span>üì¶ Magazzino (${totalUnits} articoli)</span>
                        </div>
                        ${categorySections}
                    </div>
                ` : '';
                
                // Colore barra condizione
                let barColor = '#2e8b57'; // verde
                if (conditionPercent < 30) barColor = '#8b0000'; // rosso
                else if (conditionPercent < 50) barColor = '#ff8c00'; // arancione
                else if (conditionPercent < 70) barColor = '#daa520'; // giallo
                
                // Icona tipo
                const typeIcons = {
                    building: 'üè†',
                    land: 'üå≥',
                    business: 'üè™',
                    vehicle: 'üöó',
                    other: 'üì¶'
                };
                const typeIcon = typeIcons[p.type] || 'üè∞';
                
                return `
                <div class="property-item" style="border-left: 4px solid ${cond.color || '#666'};">
                    <div class="property-header">
                        <div class="property-icon">${typeIcon}</div>
                        <div class="property-title">
                            <div class="property-name">${p.name}</div>
                            <div class="property-type">${p.type || 'building'}</div>
                        </div>
                        <div class="property-condition-badge" style="background: ${cond.color}20; color: ${cond.color}; border: 1px solid ${cond.color}50;">
                            ${cond.icon} ${cond.label}
                        </div>
                    </div>
                    <div class="property-desc">${p.description || 'Nessuna descrizione'}</div>
                    
                    <div class="property-stats">
                        <div class="property-stat-row">
                            <span class="stat-label">Condizione:</span>
                            <div class="property-condition-bar">
                                <div class="property-condition-fill" style="width: ${conditionPercent}%; background: ${barColor};"></div>
                            </div>
                            <span class="stat-value">${conditionPercent}%</span>
                        </div>
                        <div class="property-stat-row">
                            <span class="stat-label">üí∞ Valore mercato:</span>
                            <span class="stat-value">${valuation.marketValue.toLocaleString('it-IT')}</span>
                        </div>
                        <div class="property-stat-row">
                            <span class="stat-label">üìà Investito:</span>
                            <span class="stat-value">${valuation.invested.toLocaleString('it-IT')}</span>
                        </div>
                        ${p.type === 'business' ? `
                        <div class="property-stat-row">
                            <span class="stat-label">üíµ Rendita:</span>
                            <span class="stat-value" style="color: ${income >= 0 ? '#2e8b57' : '#8b0000'};">${income >= 0 ? '+' : ''}${income}/periodo</span>
                        </div>
                        ` : ''}
                        <div class="property-stat-row">
                            <span class="stat-label">‚ö° Bonus:</span>
                            <span class="stat-value" style="color: ${cond.bonus >= 0 ? '#2e8b57' : '#8b0000'};">${cond.bonus >= 0 ? '+' : ''}${cond.bonus}%</span>
                        </div>
                    </div>
                    ${p.notes ? `<div class="property-meta">üìù ${p.notes}</div>` : ''}
                    ${inventoryHtml}
                </div>
            `}).join('');
            
            // Sommario propriet√†
            const propBonus = getPropertiesBonus();
            const propertySummary = G.worldMemory.properties?.length ? `
                <div class="properties-summary">
                    <div class="summary-item">
                        <span>üìä Patrimonio totale:</span>
                        <strong>${propBonus.totalValue.toLocaleString('it-IT')}</strong>
                    </div>
                    <div class="summary-item">
                        <span>üíµ Rendita totale:</span>
                        <strong style="color: ${propBonus.totalIncome >= 0 ? '#2e8b57' : '#8b0000'};">${propBonus.totalIncome >= 0 ? '+' : ''}${propBonus.totalIncome}/periodo</strong>
                    </div>
                    <div class="summary-item">
                        <span>‚ö° Bonus totale:</span>
                        <strong style="color: ${propBonus.total >= 0 ? '#2e8b57' : '#8b0000'};">${propBonus.total >= 0 ? '+' : ''}${propBonus.total}%</strong>
                    </div>
                </div>
            ` : '';
            
            const propFallback = '<p style="color: var(--ink-light); font-style: italic;">Nessuna propriet√† registrata</p>';
            if ($('properties-list')) $('properties-list').innerHTML = (propertySummary + propertiesHtml) || propFallback;

            // Abilities recap inside inventory
            const invAbilitiesHtml = (G.worldMemory.acquiredAbilities || []).map(ab => `
                <div class="property-item ability">
                    <div class="property-icon">‚ú®</div>
                    <div class="property-info">
                        <div class="property-name">${ab.name}</div>
                        <div class="property-desc">${ab.description}</div>
                    </div>
                </div>
            `).join('');
            const abilityFallback = '<p style="color: var(--ink-light); font-style: italic;">Nessuna abilit√† segnata</p>';
            if ($('inventory-abilities')) $('inventory-abilities').innerHTML = invAbilitiesHtml || abilityFallback;
            
            checkStatusEffects();
            updateInfoPanels();
            updateEquipmentUI();
            updateStatusEffects();
            updateLocationDisplay();
        }

        function getEmptyDetailsHtml() {
            return `
                <div class="item-details-empty">
                    <div class="empty-icon">üéí</div>
                    <p>Seleziona un oggetto per vedere i dettagli.</p>
                </div>
            `;
        }

        function selectItem(index) {
            // Rimuovi selezione precedente
            $$('.inv-slot').forEach(el => el.classList.remove('selected'));
            
            const slot = $(`slot-${index}`);
            if (slot) slot.classList.add('selected');

            const item = G.character.inventory[index];
            if (!item) {
                $('inv-item-details').innerHTML = getEmptyDetailsHtml();
                return;
            }

            renderItemDetails(item, index);
        }

        function renderItemDetails(item, index) {
            const catalog = getItemCatalog({ genre: G.character.genre, story: G.currentStory });
            const normalizedId = typeof item.id === 'string' ? item.id.replace(/\s+/g, '_') : item.id;
            const catalogData = catalog[normalizedId] || catalog[item.id] || {};
            const fallbackName = item.id ? item.id.charAt(0).toUpperCase() + item.id.slice(1).replace(/_/g, ' ') : 'Oggetto';
            const name = item.name || catalogData.name || fallbackName;
            const icon = item.icon || catalogData.icon || 'üì¶';
            const type = item.type || catalogData.type || 'general';
            const effect = catalogData.effect || item.effect;
            const value = item.value !== undefined ? item.value : catalogData.value;
            const description = item.description || catalogData.desc || (type === 'consumable' ? "Pu√≤ essere consumato per recuperare forze." : "Un oggetto utile per l'avventura.");

            // Determina etichetta tipo
            let typeLabel = 'Oggetto';
            let typeClass = 'misc';
            if (type === 'consumable') { typeLabel = 'Consumabile'; typeClass = 'consumable'; }
            if (type === 'gear') { typeLabel = 'Equipaggiamento'; typeClass = 'gear'; }
            if (type === 'weapon') { typeLabel = 'Arma'; typeClass = 'weapon'; }

            // Costruisci lista effetti
            let statsHtml = '';
            if (effect) {
                const secState = G.character?.secondary;
                let healthDelta = 0;
                let staminaDelta = 0;
                let hungerDelta = 0;
                let secondaryDelta = 0;
                let wealthDelta = 0;
                const extraLines = [];

                Object.entries(effect).forEach(([rawKey, rawVal]) => {
                    const amount = Number(rawVal) || 0;
                    const key = rawKey.toString().toLowerCase();
                    if (['health', 'hp', 'salute'].includes(key)) {
                        healthDelta += amount;
                    } else if (['stamina', 'energy', 'energia'].includes(key)) {
                        staminaDelta += amount;
                    } else if (['hunger', 'fame', 'sazieta', 'satiety'].includes(key)) {
                        hungerDelta += amount;
                    } else if (['soldi', 'gold', 'money', 'denaro', 'cash', 'contanti', 'ricchezza', 'fiorini', 'fiorino'].includes(key)) {
                        wealthDelta += amount;
                    } else if (matchesSecondaryKey(key, secState)) {
                        secondaryDelta += amount;
                    } else {
                        extraLines.push({ key: rawKey, amount });
                    }
                });

                const formatLine = (icon, label, amount) => {
                    const sign = amount >= 0 ? '+' : '';
                    return `<div class="stat-line"><span>${icon} ${label}</span> <span>${sign}${amount}</span></div>`;
                };

                const lines = [];
                if (healthDelta) lines.push(formatLine('‚ù§Ô∏è', 'Salute', healthDelta));
                if (staminaDelta) lines.push(formatLine('‚ö°', 'Energia', staminaDelta));
                if (hungerDelta) lines.push(formatLine('üçñ', 'Saziet√†', hungerDelta));
                if (wealthDelta) {
                    const currencyIcon = G.character?.currency?.symbol || 'üí∞';
                    const currencyLabel = G.character?.currency?.short?.toUpperCase?.() || 'Denaro';
                    lines.push(formatLine(currencyIcon, currencyLabel, wealthDelta));
                }
                if (secondaryDelta && secState) lines.push(formatLine(secState.icon || 'üíú', secState.label || 'Risorsa', secondaryDelta));
                extraLines.forEach(extra => {
                    const icon = 'üìà';
                    const label = extra.key.toString().toUpperCase();
                    lines.push(formatLine(icon, label, extra.amount));
                });

                if (lines.length > 0) {
                    statsHtml = `<div class="item-stats">${lines.join('')}</div>`;
                } else {
                    statsHtml = '<div class="item-stats" style="color:var(--ink-light); font-style:italic; font-size:0.9em;">Nessun effetto immediato</div>';
                }
            } else {
                statsHtml = '<div class="item-stats" style="color:var(--ink-light); font-style:italic; font-size:0.9em;">Nessun effetto immediato</div>';
            }

            const valueHtml = value !== undefined ? `<div class="item-value">Valore stimato: <strong>${formatCurrency(value)}</strong></div>` : '';

            const html = `
                <div class="item-card">
                    <div class="item-card-header">
                        <div class="item-big-icon">${icon}</div>
                        <div class="item-title-block">
                            <h3>${name}</h3>
                            <span class="item-type-badge ${typeClass}">${typeLabel}</span>
                            <div style="font-size: 0.85em; color: var(--ink-light); margin-top: 2px;">Quantit√†: ${item.count}</div>
                        </div>
                    </div>

                    <div class="item-description">
                        "${description}"
                    </div>

                    ${valueHtml}

                    ${statsHtml}

                    <div class="item-actions">
                        ${type === 'consumable' ? 
                            `<button class="btn primary btn-use" onclick="useInventoryItem(${index})">Usa Oggetto</button>` : 
                            (type === 'weapon' || type === 'gear' || type === 'armor' || type === 'accessory') ?
                            `<button class="btn primary btn-use" onclick="equipItem(${index})">${item.equipped ? '‚úÖ Equipaggiato' : 'üó°Ô∏è Equipaggia'}</button>` :
                            `<button class="btn secondary btn-use" disabled>Non usabile</button>`
                        }
                    </div>
                </div>
            `;

            $('inv-item-details').innerHTML = html;
        }

        function useInventoryItem(index) {
            const item = G.character.inventory[index];
            if (!item) return;

            const catalog = getItemCatalog({ genre: G.character.genre, story: G.currentStory });
            const normalizedId = typeof item.id === 'string' ? item.id.replace(/\s+/g, '_') : item.id;
            const data = catalog[normalizedId] || catalog[item.id] || item;

            if (data?.type === 'consumable' && data.effect) {
                const secState = G.character?.secondary;
                // Applica effetti
                Object.entries(data.effect).forEach(([rawKey, rawVal]) => {
                    const amount = Number(rawVal) || 0;
                    const key = rawKey.toString().toLowerCase();
                    if (['health', 'hp', 'salute'].includes(key) && G.character.health) {
                        G.character.health.cur = Math.min(G.character.health.max, Math.max(0, G.character.health.cur + amount));
                    } else if (['stamina', 'energy', 'energia'].includes(key) && G.character.stamina) {
                        G.character.stamina.cur = Math.min(G.character.stamina.max, Math.max(0, G.character.stamina.cur + amount));
                    } else if (['hunger', 'fame', 'sazieta', 'satiety'].includes(key) && G.character.hunger) {
                        G.character.hunger.cur = Math.min(G.character.hunger.max, Math.max(0, G.character.hunger.cur + amount));
                    } else if (['soldi', 'gold', 'money', 'denaro', 'cash', 'contanti', 'ricchezza', 'fiorini', 'fiorino'].includes(key)) {
                        const prevGold = G.character.gold;
                        G.character.gold = G.character.gold + amount;
                        const deltaGold = G.character.gold - prevGold;
                        const symbol = G.character.currency?.symbol || G.character.currency?.short || 'üí∞';
                        addStoryEntry(`${symbol} ${deltaGold >= 0 ? '+' : ''}${deltaGold.toLocaleString('it-IT')}`, 'mechanic');
                    } else if (matchesSecondaryKey(key, secState)) {
                        adjustSecondary(amount, G.character);
                    } else if (G.character[key]) {
                        G.character[key].cur = Math.min(G.character[key].max, Math.max(0, G.character[key].cur + amount));
                    }
                });

                // Consuma
                item.count--;
                if (item.count <= 0) {
                    G.character.inventory.splice(index, 1);
                    $('inv-item-details').innerHTML = getEmptyDetailsHtml();
                } else {
                    renderItemDetails(item, index);
                }

                notify(`Usato ${data.name}!`, 'success');
                addStoryEntry(`[Usato ${data.name}]`, 'mechanic');
                updateCharacterUI();
            }
        }

        // ==================== EQUIPMENT SYSTEM ====================
        const EQUIP_SLOTS = {
            weapon: { label: 'Arma', icon: '‚öîÔ∏è', types: ['weapon'] },
            armor: { label: 'Armatura', icon: 'üõ°Ô∏è', types: ['gear', 'armor'] },
            accessory: { label: 'Accessorio', icon: 'üíç', types: ['accessory', 'ring', 'amulet', 'general'] }
        };

        function getEquipmentBonuses() {
            const c = G.character;
            if (!c || !c.equipment) return {};
            const bonuses = {};
            Object.values(c.equipment).forEach(item => {
                if (!item || !item.effect) return;
                Object.entries(item.effect).forEach(([key, val]) => {
                    const k = key.toLowerCase();
                    bonuses[k] = (bonuses[k] || 0) + (Number(val) || 0);
                });
            });
            return bonuses;
        }

        function equipItem(index) {
            const c = G.character;
            if (!c) return;
            const item = c.inventory[index];
            if (!item) return;
            
            const itemType = (item.type || 'general').toLowerCase();
            let targetSlot = null;
            for (const [slot, info] of Object.entries(EQUIP_SLOTS)) {
                if (info.types.includes(itemType)) {
                    targetSlot = slot;
                    break;
                }
            }
            if (!targetSlot) targetSlot = 'accessory';
            
            // Unequip current item in that slot
            if (c.equipment[targetSlot]) {
                unequipSlot(targetSlot, true);
            }
            
            // Mark item as equipped
            c.equipment[targetSlot] = {
                id: item.id,
                name: item.name || item.id,
                icon: item.icon || 'üì¶',
                type: item.type,
                effect: item.effect || {},
                value: item.value,
                description: item.description
            };
            item.equipped = true;
            
            notify(`Equipaggiato: ${item.name || item.id}`, 'success');
            addStoryEntry(`üó°Ô∏è Equipaggiato: ${item.name || item.id}`, 'mechanic');
            updateCharacterUI();
        }

        function unequipSlot(slot, silent = false) {
            const c = G.character;
            if (!c || !c.equipment || !c.equipment[slot]) return;
            
            const equipped = c.equipment[slot];
            // Find in inventory and mark unequipped
            const item = c.inventory.find(i => i.id === equipped.id && i.equipped);
            if (item) item.equipped = false;
            
            c.equipment[slot] = null;
            if (!silent) {
                notify(`Rimosso: ${equipped.name}`, 'info');
                updateCharacterUI();
            }
        }

        function updateEquipmentUI() {
            const c = G.character;
            if (!c) return;
            
            Object.entries(EQUIP_SLOTS).forEach(([slot, info]) => {
                const el = $(`equip-${slot}`);
                if (!el) return;
                const equipped = c.equipment?.[slot];
                
                if (equipped) {
                    el.classList.add('filled');
                    el.innerHTML = `
                        <div class="equip-slot-icon">${equipped.icon || info.icon}</div>
                        <div class="equip-slot-label">${info.label}</div>
                        <div class="equip-slot-name">${equipped.name}</div>
                        ${equipped.effect ? `<div class="equip-slot-bonus">${Object.entries(equipped.effect).map(([k,v]) => `${k}:${v>=0?'+':''}${v}`).join(' ')}</div>` : ''}
                    `;
                } else {
                    el.classList.remove('filled');
                    el.innerHTML = `
                        <div class="equip-slot-icon">${info.icon}</div>
                        <div class="equip-slot-label">${info.label}</div>
                        <div class="equip-slot-name">Vuoto</div>
                    `;
                }
            });
        }

        // ==================== LEVEL-UP WITH CHOICE ====================
        function showLevelUpModal(newLevel) {
            G.levelUpPending = { level: newLevel, points: 2, choices: {} };
            
            const attrs = G.character.attrs;
            const attrNames = { for: 'Forza', des: 'Destrezza', cos: 'Costituzione', int: 'Intelligenza', sag: 'Saggezza', car: 'Carisma',
                                str: 'Forza', dex: 'Destrezza', con: 'Costituzione', wis: 'Saggezza', cha: 'Carisma',
                                res: 'Resistenza', tat: 'Tattica', lea: 'Leadership', dip: 'Diplomazia', esp: 'Spionaggio',
                                vel: 'Velocit√†', tec: 'Tecnica', fis: 'Fisico', men: 'Mentale', nav: 'Navigazione' };
            
            $('levelup-level').textContent = newLevel;
            $('levelup-points-count').textContent = '2';
            
            const grid = $('levelup-attrs');
            grid.innerHTML = Object.entries(attrs).map(([key, val]) => `
                <div class="levelup-attr" id="lu-attr-${key}" data-attr="${key}">
                    <div class="levelup-attr-info">
                        <div class="levelup-attr-name">${attrNames[key] || key.toUpperCase()}</div>
                        <div class="levelup-attr-val">${val} ‚Üí <span id="lu-val-${key}">${val}</span></div>
                    </div>
                    <button onclick="levelUpBoost('${key}')">+</button>
                </div>
            `).join('');
            
            $('btn-confirm-levelup').disabled = true;
            $('levelup-overlay').classList.add('active');
        }

        function levelUpBoost(attrKey) {
            const pending = G.levelUpPending;
            if (!pending || pending.points <= 0) return;
            
            pending.choices[attrKey] = (pending.choices[attrKey] || 0) + 1;
            pending.points--;
            
            // Update display
            const baseVal = G.character.attrs[attrKey];
            const boost = pending.choices[attrKey] || 0;
            $(`lu-val-${attrKey}`).textContent = baseVal + boost;
            $(`lu-attr-${attrKey}`).classList.add('boosted');
            $('levelup-points-count').textContent = pending.points;
            
            // Disable all + buttons if no points left
            if (pending.points <= 0) {
                $$('.levelup-attr button').forEach(b => b.disabled = true);
                $('btn-confirm-levelup').disabled = false;
            }
        }

        function confirmLevelUp() {
            const pending = G.levelUpPending;
            if (!pending || pending.points > 0) return;
            
            const c = G.character;
            const attrNames = { for: 'Forza', des: 'Destrezza', cos: 'Costituzione', int: 'Intelligenza', sag: 'Saggezza', car: 'Carisma',
                                str: 'Forza', dex: 'Destrezza', con: 'Costituzione', wis: 'Saggezza', cha: 'Carisma' };
            
            // Apply choices
            Object.entries(pending.choices).forEach(([attr, boost]) => {
                if (c.attrs[attr] !== undefined) {
                    c.attrs[attr] += boost;
                    addStoryEntry(`üìà +${boost} ${attrNames[attr] || attr.toUpperCase()}!`, 'mechanic');
                }
            });
            
            $('levelup-overlay').classList.remove('active');
            G.levelUpPending = null;
            updateCharacterUI();
        }

        // ==================== JOURNAL / DIARIO ====================
        function getJournal() {
            if (!G.worldMemory.journal) G.worldMemory.journal = [];
            return G.worldMemory.journal;
        }

        function addJournalEntry(text) {
            if (!text || !text.trim()) return;
            const journal = getJournal();
            journal.push({
                id: Date.now(),
                text: text.trim(),
                turn: G.worldMemory.turnCount,
                time: getTimeString(),
                date: `${G.time.day}/${G.time.month}/${G.time.year}`
            });
            updateJournalUI();
            notify('Appunto salvato!', 'success');
        }

        function removeJournalEntry(id) {
            const journal = getJournal();
            const idx = journal.findIndex(e => e.id === id);
            if (idx >= 0) journal.splice(idx, 1);
            updateJournalUI();
        }

        function updateJournalUI() {
            const journal = getJournal();
            const container = $('journal-entries');
            if (!container) return;
            
            if (journal.length === 0) {
                container.innerHTML = '<div class="memory-empty" id="journal-empty">üìì Il tuo diario √® vuoto. Annota i tuoi pensieri e le tue strategie!</div>';
                return;
            }
            
            container.innerHTML = journal.slice().reverse().map(e => `
                <div class="journal-entry">
                    <div class="journal-entry-meta">üìÖ ${e.date} ${e.time} ¬∑ Turno ${e.turn}</div>
                    <div class="journal-entry-text">${e.text.replace(/\n/g, '<br>')}</div>
                    <button class="journal-entry-delete" onclick="removeJournalEntry(${e.id})" title="Elimina">‚úï</button>
                </div>
            `).join('');
        }

        // ==================== LOCATION TRACKING ====================
        function setLocation(locationName) {
            if (!locationName || !locationName.trim()) return;
            G.currentLocation = locationName.trim();
            updateLocationDisplay();
        }

        function updateLocationDisplay() {
            const el = $('time-location');
            if (el) {
                el.textContent = `üìç ${G.currentLocation || 'Sconosciuto'}`;
                el.title = G.currentLocation || 'Posizione sconosciuta';
            }
        }

        // ==================== GAME OVER ====================
        function triggerGameOver(reason = '') {
            const overlay = $('gameover-overlay');
            if (!overlay) return;
            
            const textEl = $('gameover-text');
            if (textEl) {
                if (reason) {
                    textEl.textContent = reason;
                } else if (G.character) {
                    const name = G.character.name || 'L\'avventuriero';
                    textEl.textContent = `${name} ha esalato il suo ultimo respiro. La sua storia viene sussurrata dal vento...`;
                }
            }
            overlay.classList.add('active');
        }

        function closeGameOver() {
            const overlay = $('gameover-overlay');
            if (overlay) overlay.classList.remove('active');
        }

        // ==================== AUTO-SAVE ====================
        function autoSave() {
            if (!G.isPlaying || !G.character) return;
            // Save to a special auto-save slot (slot 0)
            G.saves[0] = {
                character: JSON.parse(JSON.stringify(G.character)),
                story: JSON.parse(JSON.stringify(G.currentStory)),
                storyLog: JSON.parse(JSON.stringify(G.storyLog)),
                history: JSON.parse(JSON.stringify(G.history)),
                time: JSON.parse(JSON.stringify(G.time)),
                worldMemory: JSON.parse(JSON.stringify(G.worldMemory)),
                currentLocation: G.currentLocation || 'Sconosciuto'
            };
            save();
        }

        // ==================== STATUS EFFECTS DISPLAY ====================
        function updateStatusEffects() {
            const c = G.character;
            if (!c) return;
            const el = $('status-effects');
            if (!el) return;
            
            const effects = [];
            
            if (c.hunger.cur <= 20) effects.push({ icon: 'üçñ', text: 'Affamato!', cls: 'danger' });
            else if (c.hunger.cur <= 40) effects.push({ icon: 'üçñ', text: 'Fame', cls: 'warning' });
            
            if (c.stamina.cur <= 20) effects.push({ icon: 'üí§', text: 'Esausto!', cls: 'danger' });
            else if (c.stamina.cur <= 40) effects.push({ icon: 'üò¥', text: 'Stanco', cls: 'warning' });
            
            if (c.health.cur <= c.health.max * 0.2) effects.push({ icon: 'ü©∏', text: 'Critico!', cls: 'danger' });
            else if (c.health.cur <= c.health.max * 0.5) effects.push({ icon: 'ü©π', text: 'Ferito', cls: 'warning' });
            
            if (c.gold < 0) effects.push({ icon: 'üí∏', text: 'Debito', cls: 'danger' });
            
            el.innerHTML = effects.map(e => 
                `<span class="status-effect ${e.cls}" title="${e.text}">${e.icon}</span>`
            ).join('');
        }

        // ==================== WORLD MEMORY ====================
        function updateMemoryUI() {
            const wm = G.worldMemory;
            const c = G.character;

            // Stats
            $('mem-npc-count').textContent = wm.npcs.length;
            $('mem-loc-count').textContent = wm.locations.length;
            $('mem-quest-count').textContent = wm.quests.length;
            $('mem-event-count').textContent = wm.events.length;

            // Chronicle - Narrative summary of the world
            const chronicleEl = $('memory-chronicle');
            if (chronicleEl) {
                let chronicleHtml = '';
                
                // Se non c'√® ancora una cronaca, generiamola
                if (!wm.storySummary && wm.events.length >= 3) {
                    generateStorySummary();
                }
                
                if (wm.storySummary) {
                    // Formatta il summary in HTML leggibile
                    chronicleHtml = `<div class="chronicle-content">
                        ${wm.storySummary
                            .split('\n\n')
                            .map(section => {
                                if (section.startsWith('üìú') || section.startsWith('üìñ') || 
                                    section.startsWith('üë•') || section.startsWith('üìã') ||
                                    section.startsWith('üó∫Ô∏è') || section.startsWith('üè∞') ||
                                    section.startsWith('‚ú®') || section.startsWith('üë®‚Äçüë©‚Äçüëß') ||
                                    section.startsWith('üë∑') || section.startsWith('‚è≥')) {
                                    const lines = section.split('\n');
                                    const title = lines[0];
                                    const content = lines.slice(1).join('<br>');
                                    return `<div class="chronicle-section">
                                        <div class="chronicle-section-title">${title}</div>
                                        <div class="chronicle-section-content">${content || '<em>Nessuna informazione</em>'}</div>
                                    </div>`;
                                }
                                return `<p>${section}</p>`;
                            })
                            .join('')}
                    </div>`;
                } else {
                    chronicleHtml = `<div class="chronicle-empty">
                        <p>üìú <strong>La cronaca del mondo</strong></p>
                        <p>La storia √® appena iniziata. Dopo alcuni turni, qui apparir√† un riassunto narrativo degli eventi, personaggi, luoghi e progressi.</p>
                        <p><em>Continua la tua avventura per costruire la cronaca!</em></p>
                    </div>`;
                }
                
                // Aggiungi info personaggio in cima
                if (c) {
                    const headerHtml = `<div class="chronicle-header">
                        <div class="chronicle-protagonist">
                            <strong>${c.name || 'Eroe'}</strong>
                            ${c.origin ? `<span class="chr-origin">${c.origin}</span>` : ''}
                            ${c.archetype ? `<span class="chr-archetype">${c.archetype}</span>` : ''}
                            <span class="chr-level">Lv. ${c.exp?.lvl || 1}</span>
                        </div>
                        <div class="chronicle-turn">Turno ${wm.turnCount || 0}</div>
                    </div>`;
                    chronicleHtml = headerHtml + chronicleHtml;
                }
                
                chronicleEl.innerHTML = chronicleHtml;
            }

            // NPCs - con dettagli estesi (personalit√†, obiettivi, stato, posizione)
            const npcsHtml = wm.npcs.length ? wm.npcs.map(npc => {
                const statusIcon = {
                    'idle': 'üí§',
                    'working': '‚öíÔ∏è',
                    'traveling': 'üö∂',
                    'fighting': '‚öîÔ∏è',
                    'sleeping': 'üò¥',
                    'eating': 'üçΩÔ∏è',
                    'talking': 'üí¨',
                    'hiding': 'üôà',
                    'dead': 'üíÄ',
                    'injured': 'ü©π'
                }[npc.status?.toLowerCase()] || 'üë§';
                
                const relColor = {
                    'amico': '#2e8b57',
                    'alleato': '#2e8b57',
                    'nemico': '#8b0000',
                    'ostile': '#8b0000',
                    'neutrale': '#5c4030',
                    'sconosciuto': '#666'
                }[npc.relationship?.toLowerCase()] || '#5c4030';
                
                return `
                <div class="memory-card npc">
                    <div class="memory-card-title">${statusIcon} ${npc.name}</div>
                    <div class="memory-card-desc">${npc.description}</div>
                    ${npc.relationship ? `<div class="memory-card-meta" style="color: ${relColor}">ü§ù ${npc.relationship}</div>` : ''}
                    ${npc.personality ? `<div class="memory-card-meta">üé≠ ${npc.personality}</div>` : ''}
                    ${npc.goals ? `<div class="memory-card-meta">üéØ ${npc.goals}</div>` : ''}
                    ${npc.location ? `<div class="memory-card-meta">üìç ${npc.location}</div>` : ''}
                    ${npc.status && npc.status !== 'idle' ? `<div class="memory-card-meta">‚è≥ ${npc.status}</div>` : ''}
                </div>
            `}).join('') : '<div class="memory-empty">Nessun NPC incontrato</div>';
            $('memory-npcs-list').innerHTML = npcsHtml;

            // Locations
            const locsHtml = wm.locations.length ? wm.locations.map(loc => `
                <div class="memory-card location">
                    <div class="memory-card-title">üìç ${loc.name}</div>
                    <div class="memory-card-desc">${loc.description}</div>
                    ${loc.notes ? `<div class="memory-card-meta">${loc.notes}</div>` : ''}
                </div>
            `).join('') : '<div class="memory-empty">Nessun luogo scoperto</div>';
            $('memory-locations-list').innerHTML = locsHtml;

            // Quests
            const questsHtml = wm.quests.length ? wm.quests.map(q => `
                <div class="memory-card quest ${q.status}">
                    <div class="memory-card-title">üìã ${q.name} ${q.status === 'completed' ? '‚úÖ' : 'üîÑ'}</div>
                    <div class="memory-card-desc">${q.description}</div>
                    ${q.progress ? `<div class="memory-card-meta">Progresso: ${q.progress}</div>` : ''}
                </div>
            `).join('') : '<div class="memory-empty">Nessuna quest attiva</div>';
            $('memory-quests-list').innerHTML = questsHtml;

            // Events
            const eventsHtml = wm.events.length ? wm.events.slice(-20).reverse().map(e => `
                <div class="memory-card event">
                    <div class="memory-card-title">üìú Turno ${e.turn}</div>
                    <div class="memory-card-desc">${e.summary}</div>
                </div>
            `).join('') : '<div class="memory-empty">Nessun evento registrato</div>';
            $('memory-events-list').innerHTML = eventsHtml;
        }

        function addNPC(name, description, relationship = '', meta = {}) {
            const existing = G.worldMemory.npcs.find(n => n.name.toLowerCase() === name.toLowerCase());
            if (existing) {
                // Traccia il cambio di relazione come interazione
                if (relationship && relationship !== existing.relationship) {
                    if (!existing.interactions) existing.interactions = [];
                    existing.interactions.push({
                        turn: G.worldMemory.turnCount,
                        type: 'relationship_change',
                        from: existing.relationship,
                        to: relationship
                    });
                }
                existing.description = description;
                if (relationship) existing.relationship = relationship;
                existing.lastSeen = G.worldMemory.turnCount;
                existing.interactionCount = (existing.interactionCount || 0) + 1;
                if (meta.personality) existing.personality = meta.personality;
                if (meta.goals) existing.goals = meta.goals;
                if (meta.status) existing.status = meta.status;
                if (meta.location) existing.location = meta.location;
                if (meta.schedule) existing.schedule = meta.schedule;
                if (meta.level) existing.level = meta.level;
                if (meta.stats) existing.stats = meta.stats;
                if (meta.threat) existing.threat = meta.threat;
            } else {
                G.worldMemory.npcs.push({
                    id: Date.now(),
                    name,
                    description,
                    relationship,
                    personality: meta.personality || '',
                    goals: meta.goals || '',
                    status: meta.status || 'idle',
                    location: meta.location || '',
                    schedule: meta.schedule || '',
                    // Statistiche NPC per tiri contrapposti
                    level: meta.level || 1,
                    stats: meta.stats || { for: 10, des: 10, cos: 10, int: 10, sag: 10, car: 10 },
                    threat: meta.threat || 'low', // low, medium, high, boss
                    metAt: G.worldMemory.turnCount,
                    lastSeen: G.worldMemory.turnCount,
                    interactionCount: 1,
                    interactions: []
                });
            }
        }
        
        // Registra un'interazione significativa con un NPC
        function recordNPCInteraction(npcName, interactionType, details = '') {
            const npc = G.worldMemory.npcs.find(n => n.name.toLowerCase() === npcName.toLowerCase());
            if (npc) {
                if (!npc.interactions) npc.interactions = [];
                npc.interactions.push({
                    turn: G.worldMemory.turnCount,
                    type: interactionType, // 'helped', 'attacked', 'traded', 'talked', 'betrayed', etc.
                    details: details,
                    time: getTimeString()
                });
                // Mantieni solo le ultime 10 interazioni per NPC
                if (npc.interactions.length > 10) {
                    npc.interactions = npc.interactions.slice(-10);
                }
            }
        }

        function addLocation(name, description, notes = '') {
            const existing = G.worldMemory.locations.find(l => l.name.toLowerCase() === name.toLowerCase());
            if (existing) {
                if (notes) existing.notes = notes;
            } else {
                G.worldMemory.locations.push({
                    id: Date.now(),
                    name,
                    description,
                    discovered: G.worldMemory.turnCount,
                    notes
                });
            }
        }

        // ==================== SISTEMA FAMIGLIA ====================
        function addFamilyMember(name, relation, meta = {}) {
            if (!G.worldMemory.family) G.worldMemory.family = [];
            const existing = G.worldMemory.family.find(f => f.name.toLowerCase() === name.toLowerCase());
            if (existing) {
                if (meta.age !== undefined) existing.age = meta.age;
                if (meta.status) existing.status = meta.status;
                if (meta.description) existing.description = meta.description;
                if (meta.income !== undefined) existing.income = meta.income;
                if (meta.expenses !== undefined) existing.expenses = meta.expenses;
                if (meta.occupation) existing.occupation = meta.occupation;
                if (meta.health) existing.health = meta.health;
                if (meta.mood) existing.mood = meta.mood;
            } else {
                G.worldMemory.family.push({
                    id: Date.now(),
                    name,
                    relation, // moglie, marito, figlio, figlia, padre, madre, fratello, sorella, etc.
                    age: meta.age || null,
                    status: meta.status || 'alive', // alive, dead, missing, estranged
                    description: meta.description || '',
                    occupation: meta.occupation || '',
                    income: meta.income || 0, // contributo economico
                    expenses: meta.expenses || 0, // costo mantenimento
                    health: meta.health || 'good', // good, sick, injured, critical
                    mood: meta.mood || 'content', // happy, content, worried, sad, angry
                    joinedAt: G.worldMemory.turnCount
                });
                addStoryEntry(`üë®‚Äçüë©‚Äçüëß Nuovo membro famiglia: ${name} (${relation})`, 'memory-update');
            }
            updateInfoPanels();
        }

        function removeFamilyMember(name, reason = 'left') {
            if (!G.worldMemory.family) return false;
            const idx = G.worldMemory.family.findIndex(f => f.name.toLowerCase() === name.toLowerCase());
            if (idx >= 0) {
                const member = G.worldMemory.family[idx];
                if (reason === 'dead') {
                    member.status = 'dead';
                    addStoryEntry(`üíÄ ${member.name} (${member.relation}) √® deceduto/a`, 'memory-update');
                } else {
                    G.worldMemory.family.splice(idx, 1);
                    addStoryEntry(`üë®‚Äçüë©‚Äçüëß ${member.name} ha lasciato la famiglia`, 'memory-update');
                }
                updateInfoPanels();
                return true;
            }
            return false;
        }

        function getFamilyFinances() {
            if (!G.worldMemory.family) return { totalIncome: 0, totalExpenses: 0, net: 0, members: 0 };
            const living = G.worldMemory.family.filter(f => f.status === 'alive');
            const totalIncome = living.reduce((sum, f) => sum + (f.income || 0), 0);
            const totalExpenses = living.reduce((sum, f) => sum + (f.expenses || 0), 0);
            return {
                totalIncome,
                totalExpenses,
                net: totalIncome - totalExpenses,
                members: living.length
            };
        }

        // ==================== SISTEMA DIPENDENTI ====================
        function addEmployee(name, role, property, salary, meta = {}) {
            if (!G.worldMemory.employees) G.worldMemory.employees = [];
            const existing = G.worldMemory.employees.find(e => e.name.toLowerCase() === name.toLowerCase());
            if (existing) {
                if (role) existing.role = role;
                if (property) existing.property = property;
                if (salary !== undefined) existing.salary = salary;
                if (meta.skill !== undefined) existing.skill = meta.skill;
                if (meta.morale !== undefined) existing.morale = meta.morale;
                if (meta.description) existing.description = meta.description;
                if (meta.status) existing.status = meta.status;
            } else {
                G.worldMemory.employees.push({
                    id: Date.now(),
                    name,
                    role, // cuoco, cameriere, contadino, guardia, artigiano, commesso, etc.
                    property, // nome della propriet√† dove lavora
                    salary, // stipendio periodico
                    skill: meta.skill ?? 50, // 0-100 competenza
                    morale: meta.morale ?? 70, // 0-100 morale
                    description: meta.description || '',
                    status: meta.status || 'active', // active, sick, vacation, fired
                    hiredAt: G.worldMemory.turnCount
                });
                addStoryEntry(`üë∑ Nuovo dipendente: ${name} (${role}) @ ${property}`, 'memory-update');
            }
            updateInfoPanels();
        }

        function removeEmployee(name, reason = 'fired') {
            if (!G.worldMemory.employees) return false;
            const idx = G.worldMemory.employees.findIndex(e => e.name.toLowerCase() === name.toLowerCase());
            if (idx >= 0) {
                const emp = G.worldMemory.employees[idx];
                G.worldMemory.employees.splice(idx, 1);
                const reasonText = reason === 'fired' ? 'licenziato' : reason === 'quit' ? 'si √® dimesso' : 'non lavora pi√π';
                addStoryEntry(`üë∑ ${emp.name} (${emp.role}) ${reasonText}`, 'memory-update');
                updateInfoPanels();
                return true;
            }
            return false;
        }

        function getEmployeesFinances() {
            if (!G.worldMemory.employees) return { totalSalaries: 0, count: 0, avgSkill: 0, avgMorale: 0 };
            const active = G.worldMemory.employees.filter(e => e.status === 'active');
            const totalSalaries = active.reduce((sum, e) => sum + (e.salary || 0), 0);
            const avgSkill = active.length > 0 ? Math.round(active.reduce((sum, e) => sum + (e.skill || 50), 0) / active.length) : 0;
            const avgMorale = active.length > 0 ? Math.round(active.reduce((sum, e) => sum + (e.morale || 50), 0) / active.length) : 0;
            return {
                totalSalaries,
                count: active.length,
                avgSkill,
                avgMorale,
                byProperty: getEmployeesByProperty()
            };
        }

        function getEmployeesByProperty() {
            if (!G.worldMemory.employees) return {};
            const byProp = {};
            G.worldMemory.employees.filter(e => e.status === 'active').forEach(e => {
                const prop = e.property || 'Senza propriet√†';
                if (!byProp[prop]) byProp[prop] = { employees: [], totalSalary: 0 };
                byProp[prop].employees.push(e);
                byProp[prop].totalSalary += e.salary || 0;
            });
            return byProp;
        }

        // ==================== BILANCIO FINANZIARIO COMPLETO ====================
        function getFullFinancialSummary() {
            const c = G.character;
            const propBonus = getPropertiesBonus();
            const familyFin = getFamilyFinances();
            const empFin = getEmployeesFinances();
            
            // Entrate
            const propertyIncome = propBonus.totalIncome || 0;
            const familyIncome = familyFin.totalIncome || 0;
            const totalIncome = propertyIncome + familyIncome;
            
            // Uscite
            const familyExpenses = familyFin.totalExpenses || 0;
            const employeeSalaries = empFin.totalSalaries || 0;
            const totalExpenses = familyExpenses + employeeSalaries;
            
            // Bilancio netto
            const netBalance = totalIncome - totalExpenses;
            
            return {
                cash: c?.gold || 0,
                patrimony: propBonus.totalValue || 0,
                income: {
                    properties: propertyIncome,
                    family: familyIncome,
                    total: totalIncome
                },
                expenses: {
                    family: familyExpenses,
                    employees: employeeSalaries,
                    total: totalExpenses
                },
                net: netBalance,
                family: familyFin,
                employees: empFin
            };
        }

        function updateInfoPanels() {
            const fin = getFullFinancialSummary();
            const c = G.character;
            const currSymbol = c?.currency?.short || 'üí∞';
            
            // Panel Finanze
            const finPanel = $('panel-finances');
            const finSummary = $('finances-summary');
            if (finPanel && finSummary) {
                let finText = '';
                if (fin.cash < 0) {
                    finText = `Debito: ${Math.abs(fin.cash)}`;
                    finPanel.classList.add('negative');
                    finPanel.classList.remove('positive');
                } else {
                    finText = fin.cash.toLocaleString('it-IT');
                    if (fin.net !== 0) {
                        finText += ` (${fin.net >= 0 ? '+' : ''}${fin.net}/p)`;
                    }
                    finPanel.classList.remove('negative');
                    if (fin.net > 0) finPanel.classList.add('positive');
                    else finPanel.classList.remove('positive');
                }
                finSummary.textContent = finText;
            }
            
            // Panel Famiglia
            const famPanel = $('panel-family');
            const famSummary = $('family-summary');
            if (famPanel && famSummary) {
                const famCount = fin.family.members || 0;
                if (famCount === 0) {
                    famSummary.textContent = 'Nessuna';
                } else {
                    let famText = `${famCount} membri`;
                    if (fin.family.net !== 0) {
                        famText += ` (${fin.family.net >= 0 ? '+' : ''}${fin.family.net})`;
                    }
                    famSummary.textContent = famText;
                }
            }
            
            // Panel Dipendenti
            const empPanel = $('panel-employees');
            const empSummary = $('employees-summary');
            if (empPanel && empSummary) {
                const empCount = fin.employees.count || 0;
                if (empCount === 0) {
                    empSummary.textContent = 'Nessuno';
                } else {
                    let empText = `${empCount}`;
                    if (fin.employees.totalSalaries > 0) {
                        empText += ` (-${fin.employees.totalSalaries})`;
                    }
                    empSummary.textContent = empText;
                }
            }
        }

        function showFinancesDetail() {
            const fin = getFullFinancialSummary();
            const c = G.character;
            const curr = c?.currency?.short || 'üí∞';
            
            let html = `<div class="finances-detail">
                <h4>üí∞ Bilancio Finanziario</h4>
                <div class="fin-section">
                    <div class="fin-row"><span>Contanti:</span><span class="${fin.cash < 0 ? 'negative' : ''}">${fin.cash.toLocaleString('it-IT')} ${curr}</span></div>
                    <div class="fin-row"><span>Patrimonio propriet√†:</span><span>${fin.patrimony.toLocaleString('it-IT')} ${curr}</span></div>
                </div>
                <h5>üìà Entrate mensili</h5>
                <div class="fin-section">
                    <div class="fin-row"><span>Da propriet√†:</span><span>+${fin.income.properties} ${curr}</span></div>
                    <div class="fin-row"><span>Da famiglia:</span><span>+${fin.income.family} ${curr}</span></div>
                    <div class="fin-row total"><span>Totale entrate:</span><span class="positive">+${fin.income.total} ${curr}</span></div>
                </div>
                <h5>üìâ Uscite mensili</h5>
                <div class="fin-section">
                    <div class="fin-row"><span>Spese famiglia:</span><span>-${fin.expenses.family} ${curr}</span></div>
                    <div class="fin-row"><span>Stipendi dipendenti:</span><span>-${fin.expenses.employees} ${curr}</span></div>
                    <div class="fin-row total"><span>Totale uscite:</span><span class="negative">-${fin.expenses.total} ${curr}</span></div>
                </div>
                <div class="fin-section net">
                    <div class="fin-row total ${fin.net >= 0 ? 'positive' : 'negative'}">
                        <span>Bilancio netto:</span><span>${fin.net >= 0 ? '+' : ''}${fin.net} ${curr}/mese</span>
                    </div>
                </div>
            </div>`;
            
            showQuickModal('Finanze', html);
        }

        function showFamilyDetail() {
            const wm = G.worldMemory;
            if (!wm.family || wm.family.length === 0) {
                showQuickModal('Famiglia', '<p>Non hai ancora familiari. Potrebbero essere introdotti nella storia.</p>');
                return;
            }
            
            let html = '<div class="family-detail">';
            wm.family.forEach(f => {
                const statusBadge = f.status === 'alive' ? 'üíö' : f.status === 'dead' ? 'üíÄ' : '‚ö†Ô∏è';
                html += `<div class="family-member">
                    <div class="member-header">${statusBadge} <strong>${f.name}</strong> <em>(${f.relation})</em></div>
                    ${f.age ? `<div class="member-info">Et√†: ${f.age} anni</div>` : ''}
                    ${f.description ? `<div class="member-desc">${f.description}</div>` : ''}
                    ${f.income ? `<div class="member-income">Reddito: +${f.income}/mese</div>` : ''}
                    ${f.expenses ? `<div class="member-expense">Spese: -${f.expenses}/mese</div>` : ''}
                </div>`;
            });
            html += '</div>';
            
            showQuickModal('Famiglia', html);
        }

        function showEmployeesDetail() {
            const wm = G.worldMemory;
            if (!wm.employees || wm.employees.length === 0) {
                showQuickModal('Dipendenti', '<p>Non hai dipendenti. Assumi personale per le tue propriet√†!</p>');
                return;
            }
            
            const byProp = getEmployeesByProperty();
            let html = '<div class="employees-detail">';
            Object.entries(byProp).forEach(([propName, emps]) => {
                html += `<div class="emp-property">
                    <h5>üè† ${propName}</h5>`;
                emps.forEach(e => {
                    const statusBadge = e.status === 'active' ? '‚úÖ' : e.status === 'fired' ? '‚ùå' : '‚ö†Ô∏è';
                    html += `<div class="employee">
                        <span class="emp-name">${statusBadge} ${e.name}</span>
                        <span class="emp-role">${e.role}</span>
                        <span class="emp-comp">Competenza: ${e.competence || 50}%</span>
                        <span class="emp-salary">Stipendio: ${e.salary || 0}/mese</span>
                    </div>`;
                });
                html += '</div>';
            });
            html += '</div>';
            
            showQuickModal('Dipendenti', html);
        }

        function showQuickModal(title, content) {
            // Usa un modal generico per info veloci
            const modal = document.createElement('div');
            modal.className = 'modal-overlay quick-modal active';
            modal.innerHTML = `
                <div class="modal" style="max-width: 450px;">
                    <h3>${title}</h3>
                    <div class="quick-modal-content">${content}</div>
                    <button class="btn secondary" onclick="this.closest('.modal-overlay').remove()">Chiudi</button>
                </div>
            `;
            document.body.appendChild(modal);
            modal.onclick = e => { if (e.target === modal) modal.remove(); };
        }

        function addQuest(name, description, status = 'active', progress = '') {
            const existing = G.worldMemory.quests.find(q => q.name.toLowerCase() === name.toLowerCase());
            if (existing) {
                existing.status = status;
                if (progress) existing.progress = progress;
            } else {
                G.worldMemory.quests.push({
                    id: Date.now(),
                    name,
                    description,
                    status,
                    progress
                });
            }
        }

        function addEvent(summary, importance = 'normal') {
            G.worldMemory.events.push({
                id: Date.now(),
                summary,
                turn: G.worldMemory.turnCount,
                importance
            });
            // Keep only last 50 events
            if (G.worldMemory.events.length > 50) {
                G.worldMemory.events = G.worldMemory.events.slice(-50);
            }
        }

        function addSpecialItem(name, description, icon = 'üîÆ') {
            const existing = G.worldMemory.acquiredItems.find(i => i.name.toLowerCase() === name.toLowerCase());
            if (!existing) {
                G.worldMemory.acquiredItems.push({
                    id: Date.now(),
                    name,
                    description,
                    icon,
                    acquiredAt: G.worldMemory.turnCount
                });
                addStoryEntry(`üîÆ Nuovo oggetto speciale: ${name}`, 'memory-update');
            }
        }

        function addAbility(name, description) {
            const existing = G.worldMemory.acquiredAbilities.find(a => a.name.toLowerCase() === name.toLowerCase());
            if (!existing) {
                G.worldMemory.acquiredAbilities.push({
                    id: Date.now(),
                    name,
                    description,
                    acquiredAt: G.worldMemory.turnCount
                });
                addStoryEntry(`‚ú® Nuova abilit√†: ${name}`, 'memory-update');
            }
        }

        // ==================== SISTEMA PROPRIET√Ä DINAMICHE ====================
        // Stati possibili: 100=eccellente, 80=buono, 60=discreto, 40=usurato, 20=danneggiato, 0=fatiscente
        const PROPERTY_CONDITIONS = [
            { min: 90, label: 'Eccellente', icon: '‚ú®', bonus: 15, color: '#2e8b57' },
            { min: 70, label: 'Buono', icon: 'üëç', bonus: 5, color: '#3cb371' },
            { min: 50, label: 'Discreto', icon: 'üëå', bonus: 0, color: '#daa520' },
            { min: 30, label: 'Usurato', icon: '‚ö†Ô∏è', bonus: -5, color: '#ff8c00' },
            { min: 10, label: 'Danneggiato', icon: 'üîß', bonus: -15, color: '#cd5c5c' },
            { min: 0, label: 'Fatiscente', icon: 'üíÄ', bonus: -30, color: '#8b0000' }
        ];
        
        // ==================== INVENTARIO PROPRIET√Ä ====================
        const FINANCIAL_KEYWORDS = ['conto', 'conto corrente', 'libretto', 'libretto di deposito', 'deposito', 'carta di credito', 'carta di debito', 'carta prepagata', 'bancomat', 'libro mastro', 'registro contabile', 'registro di cassa', 'registro cassa', 'fondo cassa', 'cassaforte'];
        const CURRENCY_KEYWORDS = ['moneta', 'monete', 'soldo', 'soldi', 'banconota', 'banconote', 'euro', 'dollaro', 'dollari', 'credito', 'crediti', 'fiorino', 'fiorini', 'pezzo d\'oro', 'pezzi d\'oro', 'doblone', 'dobloni', 'denaro', 'cash'];
        const INTANGIBLE_LOOT_PATTERNS = [
            /vista\b.*finestra/,
            /finestra\b.*vista/,
            /\bpanorama\b/,
            /\bscorcio\b/,
            /\borizzonte\b/
        ];
        const PROPERTY_CATEGORY_INFO = {
            strumentali: {
                label: 'Beni strumentali',
                icon: 'üõ†Ô∏è',
                synonyms: ['strumentali', 'strumentale', 'attrezzo', 'attrezzi', 'attrezzature', 'attrezzatura', 'equipment', 'strumento', 'strumenti', 'macchinario', 'macchinari', 'impianto', 'impianti', 'arredo professionale', 'arredo tecnico'],
                keywords: ['attrez', 'strument', 'macchin', 'attrezz', 'bancone', 'forno', 'pressa', 'cassa', 'scaffale', 'fermentatore', 'torchio', 'alambicco', 'impianto']
            },
            produzione: {
                label: 'Beni per la produzione',
                icon: '‚öôÔ∏è',
                synonyms: ['produzione', 'materie prime', 'materia prima', 'scorta produzione', 'scorte produzione', 'approvvigionamenti', 'semilavorati', 'semilavorato', 'ingredienti', 'ingredienti base', 'materie', 'materiale grezzo', 'materiali grezzi'],
                keywords: ['materi', 'ingred', 'scorta', 'seme', 'semi', 'grano', 'frumento', 'luppolo', 'malto', 'carbone', 'legname', 'tessuto', 'tela', 'ferro', 'acciaio', 'munizione', 'fusti', 'barili vuoti']
            },
            vendibili: {
                label: 'Beni pronti per la vendita',
                icon: 'üß∫',
                synonyms: ['vendibili', 'vendita', 'pronti vendita', 'prodotti finiti', 'merce', 'magazzino vendita', 'stock vendita', 'cassa pronta', 'lotto pronto', 'prodotti', 'scorte pronte'],
                keywords: ['vend', 'prodotto', 'merce', 'confezion', 'lotto', 'bottiglia', 'cassa', 'pagnotta', 'piatto pronto', 'piatto', 'porzione', 'vaso', 'vasetto', 'barattolo']
            }
        };

        function normalizePropertyCategory(value) {
            if (!value) return null;
            const text = value.toString().trim().toLowerCase();
            if (!text) return null;
            for (const [key, info] of Object.entries(PROPERTY_CATEGORY_INFO)) {
                if (text === key) return key;
                if (info.synonyms.some(s => text === s)) return key;
            }
            return null;
        }

        function guessPropertyCategory({ explicitCategory, itemType, fallbackType, lowerName, descriptionText, existingCategory }) {
            const normalizedExisting = normalizePropertyCategory(existingCategory);
            if (normalizedExisting) return normalizedExisting;

            const normalizedExplicit = normalizePropertyCategory(explicitCategory);
            if (normalizedExplicit) return normalizedExplicit;

            const normalizedItemType = normalizePropertyCategory(itemType);
            if (normalizedItemType) return normalizedItemType;

            const normalizedFallbackType = normalizePropertyCategory(fallbackType);
            if (normalizedFallbackType) return normalizedFallbackType;

            const haystack = `${lowerName || ''} ${descriptionText || ''}`.trim();
            if (haystack) {
                for (const [key, info] of Object.entries(PROPERTY_CATEGORY_INFO)) {
                    if (info.keywords.some(keyword => haystack.includes(keyword))) {
                        return key;
                    }
                }
            }

            return 'strumentali';
        }

        function ensurePropertyItemCategory(item) {
            if (!item) return 'strumentali';
            const lowerName = (item.name || item.id || '').toString().toLowerCase();
            const descriptionText = (item.description || '').toString().toLowerCase();
            const category = guessPropertyCategory({
                explicitCategory: item.category,
                itemType: item.type,
                fallbackType: item.type,
                lowerName,
                descriptionText,
                existingCategory: item.category
            });
            item.category = category;
            return category;
        }

        function extractPropertyCategoryToken(raw) {
            if (!raw) return null;
            const value = raw.toString().trim();
            if (!value) return null;
            if (value.toLowerCase().startsWith('categoria=')) {
                return normalizePropertyCategory(value.split('=')[1]);
            }
            return normalizePropertyCategory(value);
        }

        function normalizeKey(value) {
            return (value || '').toString().trim().toLowerCase().replace(/\s+/g, '_');
        }

        function getPropertyByName(name) {
            if (!name) return null;
            const normalized = name.toString().trim().toLowerCase();
            return (G.worldMemory.properties || []).find(p => (p.name || '').toLowerCase() === normalized) || null;
        }

        function ensurePropertyInventory(propertyName) {
            const property = getPropertyByName(propertyName);
            if (!property) return null;
            if (!Array.isArray(property.inventory)) property.inventory = [];
            property.inventory.forEach(ensurePropertyItemCategory);
            return property.inventory;
        }

        function addLootToPropertyInventory(propertyName, itemId, qty = 1, meta = {}, options = {}) {
            const property = getPropertyByName(propertyName);
            if (!property) {
                addStoryEntry(`‚ö†Ô∏è Propriet√† non trovata per LOOT_PROPRIETA: ${propertyName}`, 'system');
                return;
            }
            const inventory = ensurePropertyInventory(propertyName);
            const catalog = getItemCatalog({ genre: G.character.genre, story: G.currentStory });
            const safeName = (itemId || 'oggetto').toString().trim();
            if (!safeName) return;

            const lowerName = safeName.toLowerCase();
            if (INTANGIBLE_LOOT_PATTERNS.some(re => re.test(lowerName))) {
                addStoryEntry(`‚ö†Ô∏è Oggetto non fisico ignorato per ${property.name}: ${safeName}`, 'system');
                return;
            }
            if (CURRENCY_KEYWORDS.some(keyword => lowerName.includes(keyword))) {
                addStoryEntry(`‚ö†Ô∏è I contanti devono essere registrati con [MECCANICA: soldi=¬±X], non come oggetto di propriet√† (${safeName}).`, 'system');
                return;
            }

            const normalizedId = safeName.toLowerCase().replace(/\s+/g, '_');
            const catalogData = catalog[normalizedId];
            const cleanValue = (typeof meta.value === 'number' && !Number.isNaN(meta.value)) ? meta.value : undefined;
            const descriptionText = (meta.description || '').toLowerCase();
            const isFinancialInstrument = FINANCIAL_KEYWORDS.some(keyword => lowerName.includes(keyword) || descriptionText.includes(keyword)) || meta.type === 'financial';

            let itemData = catalogData ? { ...catalogData } : {
                name: safeName.charAt(0).toUpperCase() + safeName.slice(1),
                icon: meta.icon || 'üì¶',
                type: meta.type || 'general',
                desc: meta.description || ''
            };

            if (meta.description && !itemData.desc) itemData.desc = meta.description;
            if (meta.icon && !itemData.icon) itemData.icon = meta.icon;
            if (cleanValue !== undefined) itemData.value = cleanValue;

            const existingItem = inventory.find(i =>
                i.id === normalizedId ||
                i.id === safeName ||
                (typeof i.id === 'string' && i.id.replace(/\s+/g, '_') === normalizedId)
            );

            const categoryKey = guessPropertyCategory({
                explicitCategory: meta.category || itemData.category || existingItem?.category,
                itemType: meta.type || itemData.type,
                fallbackType: itemData.type,
                lowerName,
                descriptionText,
                existingCategory: existingItem?.category
            });

            if (existingItem) {
                existingItem.count += qty;
                if (meta.description && !existingItem.description) existingItem.description = meta.description;
                if (cleanValue !== undefined) existingItem.value = cleanValue;
                if (meta.icon && !existingItem.icon) existingItem.icon = meta.icon;
                if (!existingItem.name && itemData.name) existingItem.name = itemData.name;
                if (!existingItem.type && itemData.type) existingItem.type = itemData.type;
                existingItem.category = categoryKey || existingItem.category;
                if (isFinancialInstrument || existingItem.financial) {
                    existingItem.financial = true;
                    if (!Number.isFinite(existingItem.balance)) {
                        existingItem.balance = Number.isFinite(existingItem.value) ? existingItem.value : 0;
                    }
                    if (cleanValue !== undefined) {
                        existingItem.balance += cleanValue;
                    }
                    existingItem.value = existingItem.balance;
                }
            } else {
                const initialBalance = isFinancialInstrument ? (cleanValue !== undefined ? cleanValue : 0) : undefined;
                inventory.push({
                    id: normalizedId,
                    count: qty,
                    name: meta.name || itemData.name || safeName,
                    description: meta.description || itemData.desc,
                    value: isFinancialInstrument ? initialBalance : (cleanValue !== undefined ? cleanValue : itemData.value),
                    icon: itemData.icon,
                    type: meta.type || itemData.type,
                    balance: initialBalance,
                    financial: isFinancialInstrument,
                    category: categoryKey
                });
            }

            const displayName = meta.name || itemData.name || safeName;
            addStoryEntry(`üè† ${property.name}: aggiunto ${displayName} x${qty}`, 'mechanic');
            if (!options?.silent) {
                notify(`Inventario di ${property.name}: ${displayName} x${qty}`, 'success');
            }
            updateCharacterUI();
        }

        function findPropertyInventoryItem(propertyName, nameOrId) {
            const property = getPropertyByName(propertyName);
            if (!property) return null;
            const inventory = ensurePropertyInventory(propertyName);
            if (!inventory) return null;
            const normalized = normalizeKey(nameOrId);
            return inventory.find(item => {
                const itemId = typeof item.id === 'string' ? normalizeKey(item.id) : null;
                const itemName = normalizeKey(item.name || '');
                return itemId === normalized || itemName === normalized;
            }) || null;
        }

        function removeItemFromPropertyInventory(propertyName, target, qty = 1) {
            const property = getPropertyByName(propertyName);
            if (!property) {
                addStoryEntry(`‚ö†Ô∏è Propriet√† non trovata: ${propertyName}`, 'system');
                return null;
            }
            const inventory = ensurePropertyInventory(propertyName);
            if (!inventory) return null;

            const item = typeof target === 'object' ? target : findPropertyInventoryItem(propertyName, target);
            if (!item) return null;

            const fallbackName = item.name || (typeof item.id === 'string' ? item.id.replace(/_/g, ' ') : 'Oggetto');
            const previousCount = item.count || 0;
            const removeQty = (qty === undefined || qty === null) ? previousCount : qty;
            const actualRemoved = Math.min(removeQty, previousCount);

            item.count = Math.max(0, previousCount - actualRemoved);
            let removedAll = false;
            if (item.count <= 0) {
                removedAll = true;
                property.inventory = inventory.filter(i => i !== item);
            }
            updateCharacterUI();

            return {
                property,
                removed: actualRemoved,
                remaining: removedAll ? 0 : item.count,
                itemName: fallbackName,
                removedAll,
                originalCount: previousCount
            };
        }
        
        function getPropertyCondition(condition) {
            for (const c of PROPERTY_CONDITIONS) {
                if (condition >= c.min) return c;
            }
            return PROPERTY_CONDITIONS[PROPERTY_CONDITIONS.length - 1];
        }

        function addProperty(name, description, notes = '', meta = {}) {
            if (!name) return;
            const existing = G.worldMemory.properties.find(p => p.name.toLowerCase() === name.toLowerCase());
            if (existing) {
                if (description) existing.description = description;
                if (notes) existing.notes = notes;
                if (meta.condition !== undefined) existing.condition = meta.condition;
                if (meta.type) existing.type = meta.type;
                if (meta.income) existing.income = meta.income;
                if (meta.baseValue) existing.baseValue = meta.baseValue;
                if (!Array.isArray(existing.inventory)) existing.inventory = [];
                existing.inventory.forEach(ensurePropertyItemCategory);
                existing.lastUpdated = G.worldMemory.turnCount;
            } else {
                // Stima valore base in base al tipo
                const defaultValues = {
                    building: 2000,
                    land: 1500,
                    business: 3000,
                    vehicle: 500,
                    other: 1000
                };
                const propertyType = meta.type || 'building';
                
                G.worldMemory.properties.push({
                    id: Date.now(),
                    name,
                    description,
                    notes,
                    type: propertyType,
                    condition: meta.condition ?? 80, // Inizia in buone condizioni
                    baseValue: meta.baseValue || defaultValues[propertyType] || 1000,
                    income: meta.income || (propertyType === 'business' ? 50 : 0),
                    maintenanceCost: meta.maintenanceCost || 0,
                    totalInvested: 0,
                    lastMaintenance: G.worldMemory.turnCount,
                    lastUpdated: G.worldMemory.turnCount,
                    acquiredAt: G.worldMemory.turnCount,
                    events: [],
                    inventory: []
                });
                addStoryEntry(`üè∞ Nuova propriet√†: ${name}`, 'memory-update');
            }
        }
        
        // Simula usura e eventi sulle propriet√†
        function simulateProperties() {
            if (!G.worldMemory.properties?.length) return;
            
            const turnsElapsed = G.worldMemory.turnCount;
            
            G.worldMemory.properties.forEach(prop => {
                // Calcola turni dall'ultima manutenzione
                const turnsSinceMaintenance = turnsElapsed - (prop.lastMaintenance || 0);
                
                // Usura naturale: ogni ~20 turni perde 1-3 punti condizione
                if (turnsSinceMaintenance > 0 && turnsSinceMaintenance % 20 === 0) {
                    const decay = Math.floor(Math.random() * 3) + 1;
                    prop.condition = Math.max(0, (prop.condition || 80) - decay);
                    
                    const cond = getPropertyCondition(prop.condition);
                    if (prop.condition <= 30 && Math.random() < 0.3) {
                        addStoryEntry(`üèöÔ∏è ${prop.name} necessita di manutenzione urgente! (${cond.label})`, 'world-event');
                    }
                }
                
                // Eventi casuali sulle propriet√† (2% per turno)
                if (Math.random() < 0.02) {
                    const event = generatePropertyEvent(prop);
                    if (event) {
                        prop.events = prop.events || [];
                        prop.events.push(event);
                        if (prop.events.length > 10) prop.events = prop.events.slice(-10);
                        
                        // Applica effetto
                        prop.condition = Math.max(0, Math.min(100, prop.condition + event.conditionChange));
                        
                        addStoryEntry(`üè† ${prop.name}: ${event.text}`, 'world-event');
                        
                        // Se l'evento richiede soldi, li sottrae
                        if (event.cost && G.character) {
                            G.character.gold -= event.cost;
                            addStoryEntry(`üí∞ Spesa per ${prop.name}: -${event.cost}`, 'mechanic');
                        }
                    }
                }
            });
        }
        
        function generatePropertyEvent(prop) {
            const condition = prop.condition || 50;
            const events = [];
            
            // Eventi negativi (pi√π probabili se condizione bassa)
            if (condition < 50 || Math.random() < 0.4) {
                events.push(
                    { text: 'Piccoli danni strutturali richiedono attenzione.', conditionChange: -5, cost: 0 },
                    { text: 'Infiltrazioni d\'acqua causano problemi.', conditionChange: -8, cost: 0 },
                    { text: 'Vandali hanno causato danni.', conditionChange: -10, cost: 0 },
                    { text: 'Un incendio minore ha danneggiato parte della struttura!', conditionChange: -15, cost: 0 },
                    { text: 'Parassiti o infestazione rilevata.', conditionChange: -5, cost: 0 }
                );
            }
            
            // Eventi positivi (pi√π probabili se condizione alta)
            if (condition >= 50 || Math.random() < 0.3) {
                events.push(
                    { text: 'Un vicino ha aiutato con piccole riparazioni.', conditionChange: 5, cost: 0 },
                    { text: 'Il buon tempo ha permesso riparazioni naturali.', conditionChange: 3, cost: 0 },
                    { text: 'Un artigiano di passaggio ha sistemato alcune cose.', conditionChange: 8, cost: 0 }
                );
            }
            
            // Eventi neutri/informativi
            events.push(
                { text: 'Tutto procede normalmente.', conditionChange: 0, cost: 0 },
                { text: 'Un ispettore ha notato la propriet√†.', conditionChange: 0, cost: 0 }
            );
            
            return events[Math.floor(Math.random() * events.length)];
        }
        
        // Manutenzione propriet√†
        function maintainProperty(propertyName, amount = 'normal') {
            const prop = G.worldMemory.properties.find(p => 
                p.name.toLowerCase() === propertyName.toLowerCase()
            );
            if (!prop) return { success: false, message: 'Propriet√† non trovata' };
            
            const costs = { light: 10, normal: 30, heavy: 80, restoration: 200 };
            const improvements = { light: 5, normal: 15, heavy: 35, restoration: 60 };
            
            const cost = costs[amount] || costs.normal;
            const improvement = improvements[amount] || improvements.normal;
            
            if (G.character.gold < cost) {
                return { success: false, message: `Fondi insufficienti. Servono ${cost} monete.` };
            }
            
            G.character.gold -= cost;
            prop.condition = Math.min(100, (prop.condition || 50) + improvement);
            prop.lastMaintenance = G.worldMemory.turnCount;
            
            const cond = getPropertyCondition(prop.condition);
            addStoryEntry(`üîß Manutenzione ${prop.name}: +${improvement} condizione (${cond.label})`, 'mechanic');
            addStoryEntry(`üí∞ Costo manutenzione: -${cost}`, 'mechanic');
            
            // Registra l'investimento
            prop.totalInvested = (prop.totalInvested || 0) + cost;
            
            return { success: true, newCondition: prop.condition, cost };
        }
        
        // Calcola il valore di mercato di una propriet√†
        function calculatePropertyValue(prop) {
            const baseValue = prop.baseValue || 1000; // Valore base di default
            const condition = prop.condition || 50;
            const invested = prop.totalInvested || 0;
            
            // Il valore dipende dalla condizione e dagli investimenti
            // Condizione: moltiplica il valore base (0.2x a 1.5x)
            const conditionMultiplier = 0.2 + (condition / 100) * 1.3;
            
            // Gli investimenti aumentano il valore ma con rendimenti decrescenti
            const investmentBonus = Math.sqrt(invested) * 2;
            
            const marketValue = Math.round((baseValue * conditionMultiplier) + investmentBonus);
            
            // Calcola potenziale di guadagno (ROI)
            const potentialROI = invested > 0 ? Math.round(((marketValue - baseValue) / invested) * 100) : 0;
            
            return {
                baseValue,
                marketValue,
                invested,
                potentialROI,
                conditionMultiplier: Math.round(conditionMultiplier * 100)
            };
        }
        
        // Calcola rendita periodica delle propriet√† commerciali
        function calculatePropertyIncome(prop) {
            if (prop.type !== 'business') return 0;
            
            const condition = prop.condition || 50;
            const baseIncome = prop.income || 50;
            
            // Rendita proporzionale alla condizione
            if (condition >= 70) {
                return Math.round(baseIncome * (condition / 80)); // Bonus se in buone condizioni
            } else if (condition >= 40) {
                return Math.round(baseIncome * 0.5); // Rendita dimezzata
            } else if (condition >= 20) {
                return Math.round(baseIncome * 0.2); // Quasi nulla
            } else {
                return -Math.round(baseIncome * 0.3); // Perdita se fatiscente!
            }
        }
        
        // Calcola bonus/malus totale dalle propriet√†
        function getPropertiesBonus() {
            if (!G.worldMemory.properties?.length) return { total: 0, details: [], totalValue: 0, totalIncome: 0 };
            
            let total = 0;
            let totalValue = 0;
            let totalIncome = 0;
            const details = [];
            
            G.worldMemory.properties.forEach(prop => {
                const cond = getPropertyCondition(prop.condition || 50);
                const valuation = calculatePropertyValue(prop);
                const income = calculatePropertyIncome(prop);
                
                total += cond.bonus;
                totalValue += valuation.marketValue;
                totalIncome += income;
                
                details.push({
                    name: prop.name,
                    condition: prop.condition,
                    conditionLabel: cond.label,
                    bonus: cond.bonus,
                    icon: cond.icon,
                    marketValue: valuation.marketValue,
                    invested: valuation.invested,
                    income: income
                });
            });
            
            return { total, details, totalValue, totalIncome };
        }

        // ==================== SISTEMA TRACCIAMENTO SOLDI ====================
        function logTransaction(amount, reason, balance) {
            if (!G.worldMemory.transactions) G.worldMemory.transactions = [];
            G.worldMemory.transactions.push({
                turn: G.worldMemory.turnCount,
                amount,
                reason,
                balance,
                timestamp: Date.now()
            });
            // Mantieni solo le ultime 50 transazioni
            if (G.worldMemory.transactions.length > 50) {
                G.worldMemory.transactions = G.worldMemory.transactions.slice(-50);
            }
        }

        // ==================== RIMUOVI OGGETTI INVENTARIO ====================
        function removeFromInventory(itemId, qty = 1) {
            const inv = G.character.inventory;
            const normalizedId = itemId.toLowerCase().replace(/\s+/g, '_');
            
            const idx = inv.findIndex(i => 
                i.id === normalizedId || 
                i.id === itemId ||
                (i.name && i.name.toLowerCase().replace(/\s+/g, '_') === normalizedId) ||
                (i.name && i.name.toLowerCase() === itemId.toLowerCase())
            );
            
            if (idx === -1) {
                console.warn('Item not found in inventory:', itemId);
                return { success: false, removed: 0, remaining: 0, itemName: itemId };
            }
            
            const item = inv[idx];
            const toRemove = Math.min(qty, item.count);
            item.count -= toRemove;
            
            const itemName = item.name || itemId;
            const remaining = item.count;
            
            if (item.count <= 0) {
                inv.splice(idx, 1);
            }
            
            updateCharacterUI();
            return { success: true, removed: toRemove, remaining, itemName };
        }

        function addLootToInventory(itemId, qty = 1, meta = {}) {
            const catalog = getItemCatalog({ genre: G.character.genre, story: G.currentStory });
            const safeName = (itemId || 'oggetto').toString().trim();
            const normalizedId = safeName.toLowerCase().replace(/\s+/g, '_');
            const catalogData = catalog[normalizedId];
            const cleanValue = (typeof meta.value === 'number' && !Number.isNaN(meta.value)) ? meta.value : undefined;

            let itemData = catalogData ? { ...catalogData } : {
                name: safeName.charAt(0).toUpperCase() + safeName.slice(1),
                icon: meta.icon || 'üì¶',
                type: meta.type || 'general',
                desc: meta.description || ''
            };

            if (meta.description && !itemData.desc) itemData.desc = meta.description;
            if (meta.icon && !itemData.icon) itemData.icon = meta.icon;
            if (cleanValue !== undefined) itemData.value = cleanValue;

            // Cerca se esiste gi√† nell'inventario
            const existingItem = G.character.inventory.find(i => 
                i.id === normalizedId || 
                i.id === safeName || 
                (typeof i.id === 'string' && i.id.replace(/\s+/g, '_') === normalizedId)
            );
            if (existingItem) {
                existingItem.count += qty;
                if (meta.description && !existingItem.description) existingItem.description = meta.description;
                if (cleanValue !== undefined) existingItem.value = cleanValue;
                if (meta.icon && !existingItem.icon) existingItem.icon = meta.icon;
                if (!existingItem.name && itemData.name) existingItem.name = itemData.name;
                if (!existingItem.type && itemData.type) existingItem.type = itemData.type;
            } else {
                G.character.inventory.push({
                    id: normalizedId,
                    count: qty,
                    name: meta.name || itemData.name || safeName,
                    description: meta.description || itemData.desc,
                    value: cleanValue !== undefined ? cleanValue : itemData.value,
                    icon: itemData.icon,
                    type: itemData.type
                });
            }

            const displayName = meta.name || itemData.name || safeName;
            notify(`Trovato: ${displayName} (x${qty})`, 'success');
            addStoryEntry(`üì¶ Hai ottenuto: ${displayName} x${qty}`, 'mechanic');
            updateCharacterUI();
        }

        function buildWorldMemorySummary() {
            const wm = G.worldMemory;
            const c = G.character;
            let summary = '';

            // === IDENTIT√Ä DEL PROTAGONISTA (persistente) ===
            if (c) {
                summary += '\nüé≠ IDENTIT√Ä DEL PROTAGONISTA:\n';
                summary += `Nome: ${c.name || 'Sconosciuto'}\n`;
                if (c.origin) summary += `Origine: ${c.origin}\n`;
                if (c.archetype) summary += `Archetipo/Classe: ${c.archetype}\n`;
                summary += `Livello: ${c.exp?.lvl || 1}\n`;
                
                // Equipment
                if (c.equipment) {
                    const eqParts = [];
                    if (c.equipment.weapon) eqParts.push(`Arma: ${c.equipment.weapon.name || c.equipment.weapon.id}`);
                    if (c.equipment.armor) eqParts.push(`Armatura: ${c.equipment.armor.name || c.equipment.armor.id}`);
                    if (c.equipment.accessory) eqParts.push(`Accessorio: ${c.equipment.accessory.name || c.equipment.accessory.id}`);
                    if (eqParts.length > 0) summary += `üõ°Ô∏è Equipaggiamento: ${eqParts.join(' | ')}\n`;
                }
                
                // Posizione corrente
                if (G.currentLocation && G.currentLocation !== 'Sconosciuto') {
                    summary += `üìç Posizione: ${G.currentLocation}\n`;
                }
                
                // Stats principali
                if (c.stats) {
                    const statNames = { for: 'Forza', des: 'Destrezza', cos: 'Costituzione', int: 'Intelligenza', sag: 'Saggezza', car: 'Carisma' };
                    const statsStr = Object.entries(c.stats)
                        .map(([k, v]) => `${statNames[k] || k}: ${v}`)
                        .join(', ');
                    summary += `Stats: ${statsStr}\n`;
                }
                
                // Tratti distintivi
                if (c.traits && c.traits.length > 0) {
                    summary += `Tratti: ${c.traits.join(', ')}\n`;
                }
                
                // Background se disponibile
                if (c.background) {
                    summary += `Background: ${c.background}\n`;
                }
                
                // Esperienza e progresso
                summary += `Esperienza: ${c.exp?.cur || 0}/${c.exp?.next || 100}\n`;
                
                // Stato economico sintetico
                const currSymbol = c.currency?.symbol || c.currency?.short || 'üí∞';
                if (c.gold < 0) {
                    summary += `üí∏ SITUAZIONE FINANZIARIA: IN DEBITO di ${Math.abs(c.gold)} ${currSymbol}\n`;
                } else if (c.gold < 50) {
                    summary += `üí∞ Risorse: ${c.gold} ${currSymbol} (POVERO)\n`;
                } else if (c.gold < 500) {
                    summary += `üí∞ Risorse: ${c.gold} ${currSymbol} (modesto)\n`;
                } else {
                    summary += `üí∞ Risorse: ${c.gold} ${currSymbol}\n`;
                }
            }

            if (wm.npcs.length > 0) {
                summary += '\nüë• PERSONAGGI CONOSCIUTI:\n';
                wm.npcs.forEach(npc => {
                    let line = `- ${npc.name}: ${npc.description}`;
                    if (npc.relationship) line += ` [Relazione: ${npc.relationship}]`;
                    if (npc.personality) line += ` [Personalit√†: ${npc.personality}]`;
                    if (npc.goals) line += ` [Obiettivo: ${npc.goals}]`;
                    if (npc.status && npc.status !== 'idle') line += ` [Stato: ${npc.status}]`;
                    if (npc.location) line += ` [Posizione: ${npc.location}]`;
                    // Aggiungi memoria interazioni recenti
                    if (npc.interactions && npc.interactions.length > 0) {
                        const recentInteraction = npc.interactions[npc.interactions.length - 1];
                        line += ` [Ultima interazione: ${recentInteraction.type}]`;
                    }
                    if (npc.interactionCount && npc.interactionCount > 1) {
                        line += ` [Incontri: ${npc.interactionCount}]`;
                    }
                    summary += line + '\n';
                });
            }

            if (wm.locations.length > 0) {
                summary += '\nüìç LUOGHI VISITATI:\n';
                wm.locations.forEach(loc => {
                    summary += `- ${loc.name}: ${loc.description}\n`;
                });
            }

            if (wm.quests.length > 0) {
                const activeQuests = wm.quests.filter(q => q.status === 'active');
                if (activeQuests.length > 0) {
                    summary += '\nüìã QUEST ATTIVE:\n';
                    activeQuests.forEach(q => {
                        summary += `- ${q.name}: ${q.description}${q.progress ? ` [${q.progress}]` : ''}\n`;
                    });
                }
            }

            if (wm.acquiredItems.length > 0) {
                summary += '\nüîÆ OGGETTI SPECIALI POSSEDUTI:\n';
                wm.acquiredItems.forEach(item => {
                    summary += `- ${item.name}: ${item.description}\n`;
                });
            }

            if (wm.properties?.length > 0) {
                summary += '\nüè∞ PROPRIET√Ä E BENI:\n';
                wm.properties.forEach(p => {
                    const cond = getPropertyCondition(p.condition || 50);
                    let line = `- ${p.name}: ${p.description}`;
                    line += ` [Stato: ${cond.icon} ${cond.label} (${p.condition || 50}%)]`;
                    if (cond.bonus !== 0) line += ` [${cond.bonus > 0 ? '+' : ''}${cond.bonus}% bonus]`;
                    if (p.notes) line += ` (${p.notes})`;
                    summary += line + '\n';
                });
                
                // Mostra bonus/malus totale
                const propBonus = getPropertiesBonus();
                if (propBonus.total !== 0) {
                    summary += `  ‚û§ Bonus totale propriet√†: ${propBonus.total > 0 ? '+' : ''}${propBonus.total}%\n`;
                }
            }

            if (wm.acquiredAbilities.length > 0) {
                summary += '\n‚ú® ABILIT√Ä ACQUISITE:\n';
                wm.acquiredAbilities.forEach(ab => {
                    summary += `- ${ab.name}: ${ab.description}\n`;
                });
            }

            // Recent important events
            if (wm.events.length > 0) {
                const recentEvents = wm.events.slice(-5);
                summary += '\nüìú EVENTI RECENTI:\n';
                recentEvents.forEach(e => {
                    summary += `- ${e.summary}\n`;
                });
            }

            if (wm.storySummary) {
                // Limita la lunghezza del riassunto per non sovraccaricare il prompt
                const maxSummaryLen = 2000;
                const summaryText = wm.storySummary.length > maxSummaryLen 
                    ? wm.storySummary.substring(0, maxSummaryLen) + '...[troncato]'
                    : wm.storySummary;
                summary += '\nüìñ RIASSUNTO STORIA:\n' + summaryText + '\n';
            }

            // Limita la lunghezza totale del summary
            const maxTotalLen = 4000;
            if (summary.length > maxTotalLen) {
                summary = summary.substring(0, maxTotalLen) + '\n...[memoria troncata per brevit√†]';
            }

            return summary;
        }

        // ==================== STORIES ====================
        function updateStoriesUI() {
            const html = G.stories.map((s, i) => `
                <div class="story-card ${G.selectedStory === i ? 'selected' : ''}" data-idx="${i}">
                    <div class="story-card-title">${s.title}</div>
                    <div class="story-card-desc">${s.desc?.substring(0, 80) || ''}...</div>
                </div>
            `).join('');
            $('stories-list').innerHTML = html || '<p>Nessuna storia. Creane una!</p>';

            $('btn-edit-story').disabled = G.selectedStory === null;
            $('btn-delete-story').disabled = G.selectedStory === null;

            $('new-game-story').innerHTML = G.stories.map((s, i) => 
                `<option value="${i}">${s.title}</option>`
            ).join('');

            if (typeof renderCreationOptions === 'function') {
                renderCreationOptions();
            }
        }

        function openStoryEditor(story = null) {
            G.editingStory = story;
            $('edit-story-title').value = story?.title || '';
            $('edit-story-setting').value = story?.setting || 'Fantasy Medievale';
            $('edit-story-genre').value = story?.genre || resolveGenreKey(story) || 'fantasy';
            $('edit-story-difficulty').value = story?.difficulty || 'normal';
            $('edit-story-gold').value = story?.starterGold ?? '';
            $('edit-story-desc').value = story?.desc || '';
            $('edit-story-personality').value = story?.personality || '';
            $('edit-story-depth').value = story?.depth || '';
            $('edit-story-prologue').value = story?.prologue || '';
            const props = story?.starterProperties || [];
            $('edit-story-properties').value = props.map(p => {
                const name = p.name || '';
                const desc = p.description || '';
                const notes = p.notes || '';
                return `${name} | ${desc}${notes ? ` | ${notes}` : ''}`;
            }).join('\n');
            openModal('modal-story-editor');
        }

        function saveStoryFromEditor() {
            const story = {
                id: G.editingStory?.id || Date.now(),
                title: $('edit-story-title').value || 'Nuova Storia',
                setting: $('edit-story-setting').value,
                genre: $('edit-story-genre').value || resolveGenreKey(G.editingStory),
                difficulty: $('edit-story-difficulty').value,
                starterGold: (() => {
                    const raw = $('edit-story-gold').value.trim();
                    const val = parseInt(raw, 10);
                    return Number.isFinite(val) ? val : undefined;
                })(),
                desc: $('edit-story-desc').value,
                personality: $('edit-story-personality').value,
                depth: $('edit-story-depth').value,
                prologue: $('edit-story-prologue').value
            };

            // Parse propriet√† iniziali dal textarea
            const propsRaw = $('edit-story-properties').value.split('\n').map(l => l.trim()).filter(Boolean);
            story.starterProperties = propsRaw.map(line => {
                const parts = line.split('|').map(p => p.trim());
                return {
                    name: parts[0],
                    description: parts[1] || '',
                    notes: parts[2] || ''
                };
            }).filter(p => p.name);

            if (G.editingStory) {
                const idx = G.stories.findIndex(s => s.id === G.editingStory.id);
                if (idx !== -1) G.stories[idx] = story;
            } else {
                G.stories.push(story);
            }

            save();
            closeModal('modal-story-editor');
            updateStoriesUI();
            notify('Storia salvata!', 'success');
        }

        // ==================== SAVES ====================
        function updateSavesUI() {
            let html = '';
            for (let i = 0; i < 6; i++) {
                const s = G.saves[i];
                let info = 'Vuoto';
                if (s) {
                    const dateInfo = s.time ? `${s.time.day}/${s.time.month}/${s.time.year} ${s.time.hour.toString().padStart(2,'0')}:${s.time.minute.toString().padStart(2,'0')}` : '';
                    info = `${s.character?.name || '?'} - ${s.story?.title || '?'} ${dateInfo ? '‚Ä¢ ' + dateInfo : ''}`;
                }
                html += `
                    <div class="save-slot ${G.selectedSave === i ? 'selected' : ''}" data-idx="${i}">
                        <div class="save-slot-title">Slot ${i + 1}</div>
                        <div class="save-slot-info">${info}</div>
                    </div>
                `;
            }
            $('saves-list').innerHTML = html;
        }

        function saveToSlot() {
            if (G.selectedSave === null || !G.isPlaying) return;
            
            G.saves[G.selectedSave] = {
                character: JSON.parse(JSON.stringify(G.character)),
                story: JSON.parse(JSON.stringify(G.currentStory)),
                storyLog: JSON.parse(JSON.stringify(G.storyLog)),
                history: JSON.parse(JSON.stringify(G.history)),
                time: JSON.parse(JSON.stringify(G.time)),
                worldMemory: JSON.parse(JSON.stringify(G.worldMemory)),
                currentLocation: G.currentLocation || 'Sconosciuto'
            };
            
            save();
            updateSavesUI();
            notify('Partita salvata!', 'success');
        }

        function loadFromSlot() {
            if (G.selectedSave === null || !G.saves[G.selectedSave]) return;
            
            const s = G.saves[G.selectedSave];
            G.character = JSON.parse(JSON.stringify(s.character));
            G.currentStory = JSON.parse(JSON.stringify(s.story));
            const cfg = getGenreConfig(G.currentStory);
            if (G.currentStory && !G.currentStory.genre) G.currentStory.genre = resolveGenreKey(G.currentStory);
            if (G.character) {
                G.character.genre = G.character.genre || resolveGenreKey(G.currentStory);
                G.character.currency = G.character.currency || cfg.currency;
            }
            G.storyLog = JSON.parse(JSON.stringify(s.storyLog || []));
            G.history = JSON.parse(JSON.stringify(s.history || []));
            G.time = JSON.parse(JSON.stringify(s.time || { day: 1, month: 1, year: 1400, hour: 8, minute: 0, dayName: 'Luned√¨' }));
            G.worldMemory = JSON.parse(JSON.stringify(s.worldMemory || {
                npcs: [], locations: [], quests: [], events: [],
                acquiredItems: [], acquiredAbilities: [], properties: [],
                family: [], employees: [],
                storySummary: '', lastSummaryTurn: 0, turnCount: 0
            }));
            G.worldMemory.properties = G.worldMemory.properties || [];
            G.worldMemory.family = G.worldMemory.family || [];
            G.worldMemory.employees = G.worldMemory.employees || [];
            G.currentLocation = s.currentLocation || 'Sconosciuto';
            applyStarterProperties(G.currentStory);
            G.isPlaying = true;
            
            closeAllModals();
            startGameUI();
            notify('Partita caricata!', 'success');
        }

        // ==================== GAME ====================
        function startNewGame() {
            const storyIdx = parseInt($('new-game-story').value);
            const name = $('new-game-name').value.trim() || 'Eroe';
            
            if (!G.selectedOrigin || !G.selectedArchetype) {
                notify('Seleziona origine e archetipo!', 'error');
                return;
            }

            G.currentStory = JSON.parse(JSON.stringify(G.stories[storyIdx]));
            if (!G.currentStory.genre) G.currentStory.genre = resolveGenreKey(G.currentStory);
            createCharacter(name, G.selectedOrigin, G.selectedArchetype);
            if (Number.isFinite(Number(G.currentStory.starterGold))) {
                G.character.gold = Number(G.currentStory.starterGold);
            }
            // Reset time dinamico per genere/storia
            G.time = getStartTimeForStory(G.currentStory);
            
            // Reset world memory
            G.worldMemory = {
                npcs: [],
                locations: [],
                quests: [],
                events: [],
                acquiredItems: [],
                acquiredAbilities: [],
                properties: [],
                family: [],
                employees: [],
                storySummary: '',
                lastSummaryTurn: 0,
                turnCount: 0
            };

            // Applica propriet√† iniziali definite dalla storia
            applyStarterProperties(G.currentStory);
            
            G.storyLog = [];
            G.history = [];
            G.isPlaying = true;

            closeAllModals();
            startGameUI();
        }

        function startGameUI() {
            const cfg = getGenreConfig(G.currentStory);
            if (G.character) {
                G.character.genre = G.character.genre || resolveGenreKey(G.currentStory);
                G.character.currency = G.character.currency || cfg.currency;
            }
            showScreen('game-screen');
            updateCharacterUI();
            updateQuickActions();
            updateTimeDisplay();
            updateInfoPanels(); // Aggiorna pannelli finanze, famiglia, dipendenti

            $('story-scroll').innerHTML = '';
            G.storyLog.forEach(e => addStoryEntry(e.text, e.type, false));

            // Se il salvataggio era vecchio e non aveva beni iniziali, sincronizza ora
            applyStarterProperties(G.currentStory);

            if (G.storyLog.length === 0 && G.currentStory?.prologue) {
                addStoryEntry(G.currentStory.prologue, 'narrator');
                generateAI('L\'avventura inizia...', true);
            }

            updateHome();
        }

        function exitGame() {
            if (confirm('Uscire? I progressi non salvati saranno persi.')) {
                showScreen('home-screen');
            }
        }

        function addStoryEntry(text, type, log = true) {
            const div = document.createElement('div');
            div.className = `story-entry ${type}`;
            
            let formatted = text
                .split(/\n\n+/)
                .map(para => para.trim())
                .filter(para => para.length > 0)
                .map(para => `<p>${para.replace(/\n/g, '<br>')}</p>`)
                .join('');
            
            if (!formatted) formatted = `<p>${text.replace(/\n/g, '<br>')}</p>`;
            
            const typeLabels = {
                narrator: 'Narratore',
                player: 'Azione del Giocatore',
                system: 'Sistema',
                mechanic: 'Meccanica',
                'dice-roll': 'Tiro',
                'memory-update': 'Memoria',
                analysis: 'Check Sistema' // <--- NUOVO
            };
            const typeIcons = {
                narrator: '‚ú¶',
                player: '‚öîÔ∏è',
                system: '‚öôÔ∏è',
                mechanic: '‚ûï',
                'dice-roll': 'üé≤',
                'memory-update': 'üóùÔ∏è',
                analysis: 'üîç' // <--- NUOVO
            };
            const badge = `${typeIcons[type] || '‚ú∂'} ${typeLabels[type] || 'Narrazione'}`;
            const timeLabel = G?.isPlaying ? `${getTimeString()} ¬∑ Turno ${G.worldMemory?.turnCount ?? 0}` : '';
            
            div.innerHTML = `
                <div class="story-entry-head">
                    <span class="story-badge">${badge}</span>
                    ${timeLabel ? `<span class="story-time">${timeLabel}</span>` : ''}
                </div>
                <div class="story-entry-text">${formatted}</div>
            `;

            $('story-scroll').appendChild(div);
            if (G.storyBatchMode) {
                G.pendingStoryScroll = true;
            } else {
                // Porta il nuovo messaggio in alto per leggerlo dall'inizio senza dover scrollare manualmente
                div.scrollIntoView({ block: 'start' });
            }

            if (log) G.storyLog.push({ text, type, time: Date.now() });
        }

        function flushStoryBatchScroll() {
            if (!G.pendingStoryScroll) return;
            const last = $('story-scroll')?.lastElementChild;
            if (last) last.scrollIntoView({ block: 'start' });
            G.pendingStoryScroll = false;
        }

        function displaySuggestions(suggestions) {
            const area = $('suggestions-area');
            const list = $('suggestions-list');

            if (!suggestions || suggestions.length === 0) {
                area.style.display = 'none';
                return;
            }

            const typeIcons = {
                'dialogo': 'üí¨', 'azione': '‚ö°', 'esplorazione': 'üîç',
                'combattimento': '‚öîÔ∏è', 'default': 'üí°'
            };

            list.innerHTML = suggestions.map((s, i) => `
                <button class="suggestion-btn" data-idx="${i}">
                    <span class="suggestion-type">${typeIcons[s.type.toLowerCase()] || typeIcons.default} ${s.type}</span>
                    ${s.text}
                </button>
            `).join('');

            area.style.display = 'block';

            list.querySelectorAll('.suggestion-btn').forEach(btn => {
                btn.onclick = () => {
                    const suggestion = suggestions[parseInt(btn.dataset.idx)];
                    $('action-input').value = suggestion.text;
                    area.style.display = 'none';
                    sendAction();
                };
            });
        }

        function sendAction() {
            const input = $('action-input');
            const action = input.value.trim();
            if (!action || G.isProcessing) return;

            $('suggestions-area').style.display = 'none';
            input.value = '';
            addStoryEntry(`‚û§ ${action}`, 'player');

            // Shortcut intelligenti per bisogni base: applicano subito recuperi reali
            // (energia/saziet√†) tramite le azioni dedicate.
            if (handleBasicNeedAction(action)) return;
            
            // Tempo base minimo - il grosso lo decide l'IA con [TEMPO: +X]
            advanceTime(5);
            G.worldMemory.turnCount++;
            
            // Auto-save ogni 5 turni
            if (G.worldMemory.turnCount % 5 === 0) autoSave();
            
            // Consumo automatico risorse per turno (simulazione bisogni)
            applyTurnConsumption();
            
            // Simula usura e eventi sulle propriet√†
            simulateProperties();
            
            generateAI(action);
        }

        function handleBasicNeedAction(actionText) {
            if (!G.character) return false;
            const txt = (actionText || '').toLowerCase();

            const restIntent = /(\bripos|\bdorm|\bsonnell|\bsleep\b|\brest\b)/i.test(txt);
            const eatIntent = /(\bmangi|\bcibo\b|\bpasto\b|\bfame\b|\beat\b|\bmeal\b)/i.test(txt);

            if (restIntent) {
                doRest();
                G.worldMemory.turnCount++;
                if (G.worldMemory.turnCount % 5 === 0) autoSave();
                return true;
            }

            if (eatIntent) {
                doEat();
                G.worldMemory.turnCount++;
                if (G.worldMemory.turnCount % 5 === 0) autoSave();
                return true;
            }

            return false;
        }
        
        function applyTurnConsumption() {
            // Consumo base per turno - MOLTO RIDOTTO
            // Il consumo principale avviene tramite advanceTime() col tempo che passa
            // Qui applichiamo solo un piccolo consumo simbolico per turno attivo
            const c = G.character;
            if (!c) return;
            
            // Consumo simbolico molto raro: evita doppio consumo rispetto al tempo reale
            if (Math.random() < 0.05) { // 5% chance di consumare 1 fame per turno
                c.hunger.cur = Math.max(0, c.hunger.cur - 1);
            }
            
            // Le penalit√† HP da fame/stanchezza sono gi√† gestite in advanceTime()
            // in base alle ore realmente passate, per evitare morti troppo rapide a turni brevi.
            
            // Rigenera stamina se ben nutrito (fame > 60)
            if (c.hunger.cur > 60 && c.stamina.cur < c.stamina.max) {
                const regenAmount = 3; // Rigenerazione pi√π generosa
                c.stamina.cur = Math.min(c.stamina.max, c.stamina.cur + regenAmount);
            }
            
            // Rigenera HP lentamente se ben nutrito e riposato
            if (c.hunger.cur > 70 && c.stamina.cur > 50 && c.health.cur < c.health.max) {
                if (Math.random() < 0.3) { // 30% chance di rigenerare 1 HP
                    c.health.cur = Math.min(c.health.max, c.health.cur + 1);
                }
            }
            
            // Simula mondo vivo: aggiorna NPC in base all'ora
            simulateWorldNPCs();
            
            updateCharacterUI();
        }

        // ==================== SIMULAZIONE MONDO VIVO ====================
        function simulateWorldNPCs() {
            if (!G.worldMemory.npcs.length) return;
            
            const period = getTimePeriod();
            const hour = G.time.hour;
            
            // Aggiorna lo stato degli NPC in base all'ora del giorno
            G.worldMemory.npcs.forEach(npc => {
                const prevStatus = npc.status;
                
                // Logica base per stato NPC basata sull'ora
                if (npc.status !== 'dead') {
                    if (hour >= 23 || hour < 6) {
                        // Notte: la maggior parte dorme
                        if (Math.random() < 0.7) npc.status = 'sleeping';
                    } else if (hour >= 6 && hour < 8) {
                        // Alba: si svegliano
                        if (npc.status === 'sleeping') npc.status = 'idle';
                    } else if (hour >= 8 && hour < 12) {
                        // Mattina: lavoro
                        if (Math.random() < 0.6) npc.status = 'working';
                    } else if (hour >= 12 && hour < 14) {
                        // Pranzo
                        if (Math.random() < 0.5) npc.status = 'eating';
                    } else if (hour >= 14 && hour < 18) {
                        // Pomeriggio: lavoro o attivit√†
                        if (Math.random() < 0.5) npc.status = 'working';
                        else if (Math.random() < 0.3) npc.status = 'traveling';
                    } else if (hour >= 18 && hour < 21) {
                        // Sera: relax, socialit√†
                        if (Math.random() < 0.4) npc.status = 'talking';
                        else npc.status = 'idle';
                    } else {
                        // Tarda sera
                        if (Math.random() < 0.5) npc.status = 'idle';
                    }
                }
                
                // Se l'NPC ha obiettivi specifici, pu√≤ sovrascrivere lo stato
                if (npc.goals && npc.goals.toLowerCase().includes('vendetta') && Math.random() < 0.1) {
                    npc.status = 'hunting';
                }
                if (npc.goals && npc.goals.toLowerCase().includes('fuga') && Math.random() < 0.1) {
                    npc.status = 'hiding';
                }
            });
        }

        // Genera eventi casuali del mondo e li mostra con stile distintivo
        function generateWorldEvent() {
            const hour = G.time.hour;
            const events = [];
            
            // Eventi basati sugli NPC con obiettivi (se ce ne sono)
            if (G.worldMemory.npcs?.length) {
                G.worldMemory.npcs.forEach(npc => {
                if (npc.status === 'dead') return;
                
                // NPC nemici possono fare mosse
                if (npc.relationship?.toLowerCase().includes('nemico') || 
                    npc.relationship?.toLowerCase().includes('ostile')) {
                    if (Math.random() < 0.15) { // 15% chance
                        const actions = [
                            `Voci parlano di ${npc.name} che sta tramando qualcosa...`,
                            `${npc.name} √® stato avvistato in zona.`,
                            `Qualcuno dice che ${npc.name} ti sta cercando.`,
                            `Si mormora che ${npc.name} stia radunando alleati.`
                        ];
                        events.push({
                            type: 'npc-action',
                            npc: npc.name,
                            text: actions[Math.floor(Math.random() * actions.length)]
                        });
                    }
                }
                
                // NPC alleati possono mandare messaggi
                if (npc.relationship?.toLowerCase().includes('amico') || 
                    npc.relationship?.toLowerCase().includes('alleato')) {
                    if (Math.random() < 0.12) { // 12% chance
                        const actions = [
                            `${npc.name} ti ha mandato un messaggio.`,
                            `${npc.name} sta pensando a te.`,
                            `Hai sentito che ${npc.name} ha chiesto tue notizie.`
                        ];
                        events.push({
                            type: 'npc-action',
                            npc: npc.name,
                            text: actions[Math.floor(Math.random() * actions.length)]
                        });
                    }
                }
                
                // NPC con obiettivi attivi
                if (npc.goals && npc.status !== 'sleeping' && npc.status !== 'idle') {
                    if (Math.random() < 0.1) { // 10% chance
                        events.push({
                            type: 'world-event',
                            npc: npc.name,
                            text: `${npc.name} √® impegnato: ${npc.goals.substring(0, 50)}...`
                        });
                    }
                }
            });
            } // Chiude il blocco if degli NPC
            
            // Eventi ambientali generici basati sull'ora - PI√ô FREQUENTI
            if (hour >= 5 && hour < 7) {
                if (Math.random() < 0.25) events.push({ type: 'world-event', text: 'üåÖ L\'alba illumina il cielo. La citt√† inizia a svegliarsi.' });
            } else if (hour >= 7 && hour < 9) {
                if (Math.random() < 0.2) events.push({ type: 'world-event', text: '‚òÄÔ∏è I mercanti aprono le botteghe, le strade si animano.' });
            } else if (hour >= 12 && hour < 14) {
                if (Math.random() < 0.2) events.push({ type: 'world-event', text: 'üçΩÔ∏è √à ora di pranzo. Il profumo di cibo riempie l\'aria.' });
            } else if (hour >= 17 && hour < 19) {
                if (Math.random() < 0.2) events.push({ type: 'world-event', text: 'üåÜ Il sole inizia a calare. I lavoratori tornano a casa.' });
            } else if (hour >= 19 && hour < 21) {
                if (Math.random() < 0.2) events.push({ type: 'world-event', text: 'üåô La sera scende. Le taverne si riempiono di voci e risate.' });
            } else if (hour >= 21 && hour < 23) {
                if (Math.random() < 0.15) events.push({ type: 'world-event', text: 'üåÉ La notte avanza. Le strade si svuotano.' });
            } else if (hour >= 23 || hour < 3) {
                if (Math.random() < 0.1) events.push({ type: 'world-event', text: 'ü¶â Notte fonda. Solo le guardie e le ombre si muovono.' });
            } else if (hour >= 3 && hour < 5) {
                if (Math.random() < 0.1) events.push({ type: 'world-event', text: '‚≠ê Le ore pi√π buie prima dell\'alba. Il mondo dorme.' });
            }
            
            // Eventi casuali generici del mondo (sempre possibili)
            if (Math.random() < 0.08) {
                const genericEvents = [
                    'üê¶ Uccelli volano nel cielo, portando presagi.',
                    'üí® Un vento freddo soffia tra le strade.',
                    'üîî In lontananza, campane suonano.',
                    'üë• Un gruppo di viaggiatori passa di qui.',
                    'üêï Un cane randagio attraversa la strada.',
                    'üìØ Un banditore annuncia le ultime notizie.',
                    'üé≠ Artisti di strada intrattengono i passanti.',
                    '‚öîÔ∏è Si sentono voci di tensioni ai confini.',
                    'üìú Nuovi editti sono stati affissi in piazza.',
                    'üèá Un messaggero a cavallo passa veloce.'
                ];
                events.push({ 
                    type: 'world-event', 
                    text: genericEvents[Math.floor(Math.random() * genericEvents.length)] 
                });
            }
            
            return events.length > 0 ? events[Math.floor(Math.random() * events.length)] : null;
        }
        
        // Mostra un evento del mondo con stile distintivo
        function showWorldEvent(event) {
            if (!event) return;
            addStoryEntry(event.text, event.type || 'world-event');
        }

        // Costruisce contesto NPC per l'IA
        function buildNPCContext() {
            const wm = G.worldMemory;
            if (!wm.npcs.length) return '';
            
            let context = '\nüåç STATO ATTUALE NPC NEL MONDO:\n';
            wm.npcs.forEach(npc => {
                if (npc.status === 'dead') {
                    context += `- ${npc.name}: MORTO\n`;
                } else {
                    let line = `- ${npc.name}`;
                    if (npc.status) line += ` [${npc.status}]`;
                    if (npc.location) line += ` @ ${npc.location}`;
                    if (npc.goals) line += ` - Vuole: ${npc.goals}`;
                    context += line + '\n';
                }
            });
            return context;
        }

        // ==================== AI ====================
        async function generateAI(action, isStart = false) {
            if (G.isProcessing || !G.currentStory) return;
            G.isProcessing = true;
            $('btn-send').disabled = true;
            updateActionBar();

            addStoryEntry('<span class="loading-dots">Il narratore sta scrivendo</span>', 'system');

            try {
                const response = await callAI(action, isStart);

                const last = $('story-scroll').lastChild;
                if (last?.textContent?.includes('scrivendo')) last.remove();

                parseAIResponse(response);
                updateInfoPanels(); // Aggiorna pannelli dopo modifiche AI
                G.history.push({ role: 'user', content: action });
                G.history.push({ role: 'assistant', content: response });

                // Periodic story summary (every 5 turns for deeper narrative memory)
                if (G.worldMemory.turnCount - G.worldMemory.lastSummaryTurn >= 5) {
                    generateStorySummary();
                }

            } catch (err) {
                const last = $('story-scroll').lastChild;
                if (last?.textContent?.includes('scrivendo')) last.remove();
                addStoryEntry(`‚ö†Ô∏è Errore: ${err.message}`, 'system');
            } finally {
                G.isProcessing = false;
                $('btn-send').disabled = false;
                updateActionBar();
            }
        }

        async function callAI(action, isStart) {
            const s = G.settings;
            const story = G.currentStory;
            const c = G.character;
            const genreCfg = getGenreConfig(story);
            const period = getTimePeriod();
            const recentHistory = G.history.slice(-10);

            const lengths = { short: '100-200 parole', medium: '200-350 parole', long: '350-500 parole' };

            // 1. CREAZIONE LISTA INVENTARIO CORRENTE (Fondamentale per i controlli)
            const inventoryList = c.inventory.length > 0 
                ? c.inventory.map(i => `- ${i.name} (x${i.count})`).join('\n') 
                : "Nessun oggetto (Tasche vuote)";

            // Build world memory summary
            const worldMemorySummary = buildWorldMemorySummary();
            
            // Build critical conditions
            let criticalConditions = '';
            if (c.gold < 0) criticalConditions += `\n‚ö†Ô∏è IN DEBITO GRAVE: ${c.gold} ${c.currency?.short}! I creditori ti cercano.`;
            if (c.hunger.cur <= 20) criticalConditions += '\n‚ö†Ô∏è AFFAMATO CRITICO! Il personaggio sta morendo di fame, non pu√≤ compiere azioni fisiche impegnative.';
            else if (c.hunger.cur <= 40) criticalConditions += '\n‚ö†Ô∏è AFFAMATO! Il personaggio ha molta fame, sente i crampi allo stomaco.';
            else if (c.hunger.cur <= 60) criticalConditions += '\nüìç Fame moderata: il personaggio inizia ad avere appetito.';
            if (c.stamina.cur <= 20) criticalConditions += '\n‚ö†Ô∏è ESAUSTO CRITICO! Il personaggio barcolla, rischia di svenire.';
            else if (c.stamina.cur <= 40) criticalConditions += '\n‚ö†Ô∏è MOLTO STANCO! Movimenti lenti, difficolt√† di concentrazione.';
            else if (c.stamina.cur <= 60) criticalConditions += '\nüìç Stanchezza lieve: il personaggio inizia a sentire la fatica.';
            if (c.health.cur <= c.health.max * 0.2) criticalConditions += '\n‚ö†Ô∏è FERITO GRAVEMENTE! Il personaggio √® in pericolo di vita.';
            else if (c.health.cur <= c.health.max * 0.5) criticalConditions += '\n‚ö†Ô∏è FERITO! Il personaggio ha ferite visibili e prova dolore.';
            
            // Condizioni secondarie (risorsa secondaria)
            if (c.secondary && c.secondary.max > 0) {
                const secPercent = (c.secondary.cur / c.secondary.max) * 100;
                if (secPercent <= 20) criticalConditions += `\n‚ö†Ô∏è ${c.secondary.label} CRITICO! Solo ${c.secondary.cur}/${c.secondary.max}.`;
                else if (secPercent <= 40) criticalConditions += `\nüìç ${c.secondary.label} basso: ${c.secondary.cur}/${c.secondary.max}.`;
            }

            const systemPrompt = `Sei il NARRATORE Il tuo compito √® dare vita al mondo con descrizioni evocative, dinamiche e ricche di atmosfera, mantenendo sempre una posizione neutrale e coerente. Devi coinvolgere emotivamente il giocatore, farlo sentire dentro la scena, far percepire tensione, opportunit√†, rischi e meraviglia.

STILE:
- Tono coinvolgente, emozionale, vivido; fai percepire l'ambiente, le sensazioni, l‚Äôattesa, i piccoli dettagli significativi.
- Usa sempre il "tu" per trascinare il giocatore dentro l‚Äôazione.
- Enfatizza scelte, dilemmi, conseguenze, momenti tesi o importanti.
- Il ritmo deve sostenere l‚Äôimmersione: frasi che guidano, immagini che suggeriscono, emozioni che emergono.

REGOLE:
- Mantieni totale imparzialit√†: non favorire n√© ostacolare intenzionalmente il giocatore.
- Gli esiti delle azioni devono essere credibili e coerenti con la situazione (successi, fallimenti e conseguenze logiche).
- Quando serve, puoi evocare la ‚Äúsorte‚Äù come se stessi tirando un dado, senza numeri espliciti.
- Mantieni il mondo vivo: ambienti sensoriali, PNG con personalit√†, eventi che reagiscono alle scelte.
- Non prendere mai decisioni per il giocatore; presenta sempre opzioni e lascia a lui la scelta.
- Integra meccaniche di gioco (salute, energia, soldi, inventario) in modo fluido e naturale nella narrazione.
- Usa i TAG MECCANICA e LOOT per modificare lo stato di gioco (salute, energia, soldi, inventario).

OBIETTIVO:
- Offrire un‚Äôesperienza narrativa profondamente immersiva, emotiva e reattiva, mantenendo sempre il controllo come un master esperto di GdR.

 Ora comportati come tale in ogni risposta.
 

${story.desc || ''}

DATI GIOCO: HP ${c.health.cur}/${c.health.max} | Energia ${c.stamina.cur} | Soldi ${formatCurrency(c.gold)} | Livello ${c.level || 1} | EXP ${c.exp?.cur || 0}/${c.exp?.need || 100}
BONUS COMPETENZA: +${getProficiencyBonus()} (basato sul livello)
ATTRIBUTI: ${Object.entries(c.attrs || {}).map(([k, v]) => `${k.toUpperCase()}:${v}(${mod(v) >= 0 ? '+' : ''}${mod(v)})`).join(' | ')}
EQUIPAGGIAMENTO: ${c.equipment?.weapon ? (c.equipment.weapon.name || 'Arma') : 'Nessuna arma'} | ${c.equipment?.armor ? (c.equipment.armor.name || 'Armatura') : 'Nessuna armatura'} | ${c.equipment?.accessory ? (c.equipment.accessory.name || 'Accessorio') : 'Nessun accessorio'}
POSIZIONE ATTUALE: ${G.currentLocation || 'Sconosciuto'}
INVENTARIO: ${inventoryList}

‚õî **REGOLA FONDAMENTALE (CONTROLLI NASCOSTI)**
Quando verifichi i requisiti (soldi, oggetti, logica), DEVI scrivere il ragionamento dentro il tag [ANALISI].
NON scrivere i controlli nel testo narrativo.

Esempio Corretto:
[ANALISI]Il giocatore vuole la spada (costo 50). Ha 100 monete. OK.[/ANALISI]
Il fabbro annuisce e ti porge l'arma...
[MECCANICA: soldi=-50] [LOOT: Spada|1|...]

Esempio Errato (NON FARE COSI):
Controllo se hai i soldi... si li hai. Il fabbro ti da la spada.

üé≤ **SISTEMA DI RISOLUZIONE AZIONI (D&D Style)**
- Per azioni incerte, usa il sistema D20: tira 1d20 + modificatore attributo + bonus competenza.
- Il BONUS COMPETENZA dipende dal livello del personaggio (vedi sopra).
- Difficolt√† (CD): 5=Molto Facile, 10=Facile, 15=Medio, 20=Difficile, 25=Molto Difficile, 30=Quasi Impossibile.
- 1 naturale = FALLIMENTO CRITICO (conseguenze gravi), 20 naturale = SUCCESSO CRITICO (bonus extra).
- Scrivi il tiro nell'[ANALISI] es: "Tiro Forza CD 15: d20(12)+3(FOR)+2(competenza)=17. Successo!"
- L'esperienza del personaggio (livello) influenza TUTTO: negoziazioni, combattimenti, artigianato, furtivit√†.
- Un personaggio esperto (alto livello) riesce in azioni che un novizio fallirebbe.
- Se il tiro fallisce, descrivi le conseguenze; se riesce, descrivi il successo proporzionato al margine.

‚ö†Ô∏è **OUTPUT OBBLIGATORIO**
1. Inizia SEMPRE con [ANALISI]...ragionamento nascosto + eventuali tiri...[/ANALISI]
2. Poi scrivi la NARRAZIONE.
3. Se il giocatore trova oggetti, usa UN TAG PER OGNI OGGETTO nel formato:
   [LOOT: Nome Oggetto|Quantit√†|Descrizione opzionale|Valore opzionale|Icona opzionale]
   
   Esempio Multiplo:
   [LOOT: Registri clienti|1] [LOOT: Scatole prodotti|2] [LOOT: Chiave arrugginita|1||0|üóùÔ∏è]

   NON usare liste uniche come [LOOT] A|1|B|2 [/LOOT]. Usa tag separati.
   NON scrivere "Hai ottenuto..." nel testo narrativo, il sistema lo far√† in automatico leggendo i tag.

‚è±Ô∏è **TEMPO E FATICA REALISTICI**
- Fai avanzare il tempo con [TEMPO:...]. Formati supportati:
  - Minuti: [TEMPO:+30] o [TEMPO: 30 minuti]
  - Ore: [TEMPO: 2 ore] o [TEMPO:+120]
  - Giorni: [TEMPO: 3 giorni] o [TEMPO:+4320]
  - Combinati: [TEMPO: 1 giorno, 5 ore]
  - Settimane/Mesi: [TEMPO: 1 settimana] [TEMPO: 2 mesi]
- Calibra il tempo in base all'azione: una chiacchierata = 15 min, un viaggio = ore/giorni, una lunga attesa = settimane.
- Le azioni faticose consumano energia con [MECCANICA: stamina=-X]; usa valori alti (30-50) per lavori duri.
- Se l'attivit√† richiede pi√π tempo del previsto, suddividi la scena oppure esplicita che il personaggio si ferma per riposare.
- Ricorda di segnalare altri costi (soldi, risorse) con i relativi tag [MECCANICA: soldi=¬±X] e simili.
- Ricorda che il personaggio deve mangiare e riposare regolarmente per evitare penalit√†.


üéí **LOOT SOLO OGGETTI REALI**
- Usa i tag [LOOT: ...] solo per oggetti fisici o risorse effettivamente ottenuti e trasportabili.
- Non aggiungere nell'inventario elementi scenografici o non possedibili (es. "vista dalla finestra", mobili fissati, parti dell'ambiente, sensazioni).
- Gli oggetti che restano nel luogo vanno descritti nella narrazione senza usare [LOOT].

üîß **USO E CONSUMO OGGETTI**
- Quando il giocatore usa un oggetto dall'inventario, usa [USA: Nome Oggetto|Quantit√†] o [CONSUMA: Nome Oggetto|Quantit√†].
- L'oggetto verr√† automaticamente rimosso o decrementato dall'inventario.
- Esempio: Il giocatore beve una pozione ‚Üí [CONSUMA: Pozione di cura|1]
- Esempio: Il giocatore usa una chiave ‚Üí [USA: Chiave arrugginita|1]
- Se l'oggetto non √® presente nell'inventario, il sistema segnaler√† l'errore.
- IMPORTANTE: Non permettere azioni che richiedono oggetti che il giocatore non possiede!

üí∞ **GESTIONE DENARO (TRACCIAMENTO RIGOROSO)**
- Il sistema tiene traccia di TUTTE le transazioni. Ogni modifica viene registrata.
- Mostra SEMPRE il saldo corrente dopo ogni transazione: [MECCANICA: soldi=-50] mostrer√† "(-50, Saldo: 150)".
- PRIMA di ogni acquisto/spesa, verifica nell'[ANALISI] che il giocatore abbia abbastanza soldi.
- NON raddoppiare le somme: se il giocatore inizia con 100 e spende 30, ha 70. Non aggiungere o sottrarre nuovamente.
- Se il capitale iniziale differisce da quello indicato in DATI GIOCO, calcola la differenza e usa subito [MECCANICA: soldi=¬±X] per allineare il saldo.
- Quando il denaro √® registrato in documenti o libri mastri, cita il supporto nella narrazione e, se appropriato, fornisci l'oggetto con [LOOT: Libro mastro|1|Contiene ...].
- Ricorda che le valute possono essere espresse in euro, monete d'oro, fiorini o altre unit√†: usa sempre il tag meccanico per aggiornare il totale.

üè† **PROPRIET√Ä E BENI (Sistema Dinamico)**
- Le propriet√† hanno una CONDIZIONE (0-100%): Eccellente(90+), Buono(70+), Discreto(50+), Usurato(30+), Danneggiato(10+), Fatiscente(0+).
- Usa [PROPRIETA: nome|descrizione|note|tipo|condizione|valore|reddito] per registrare propriet√†.
  - Tipi: building, land, business, vehicle
  - Valore: valore base in valuta (es: 5000 per un edificio di pregio)
  - Reddito: entrate periodiche (per business o affitti)
- VALUTAZIONE: il valore di mercato dipende dalla condizione. Eccellente=120%, Buono=100%, Discreto=80%, Usurato=60%, Danneggiato=40%, Fatiscente=20% del valore base.
- Le propriet√† in buone condizioni danno BONUS al giocatore, quelle trascurate danno MALUS.
- Quando il giocatore visita o ispeziona una propriet√†, descrivi il suo stato attuale (segni di usura, danni, miglioramenti) e stima il valore.
- Se il giocatore fa manutenzione o riparazioni, aumenta la condizione; se la trascura, peggiorer√† nel tempo.
- Eventi casuali possono colpire le propriet√†: furti, danni atmosferici, incendi, ma anche miglioramenti fortuiti.
- Le propriet√† commerciali (business) possono generare entrate se ben tenute (condizione 50%+), o perdite se trascurate.

üì¶ **MAGAZZINO PROPRIET√Ä (Sistema Inventario Locale)**
- Le propriet√† possono avere un inventario separato da quello personale del giocatore.
- Usa [LOOT_PROPRIETA: Nome Propriet√†|Oggetto|categoria=strumentali/produzione/vendibili|Quantit√†|Descrizione|Valore|Icona] per stoccare beni.
- Categorie disponibili:
  - strumentali: attrezzi, macchinari, attrezzature (es. bancone, forno, scaffali)
  - produzione: materie prime, ingredienti, semilavorati (es. grano, malto, legname)
  - vendibili: prodotti finiti pronti alla vendita (es. pane, birra, armi forgiate)
- Se un bene viene consegnato al protagonista ma appartiene al locale, usa [LOOT_PROPRIETA] non [LOOT].
- Per consumare/usare/vendere oggetti dalla propriet√†, usa:
  - [CONSUMA_OGGETTO_PROPRIETA: Nome Propriet√†|Oggetto|Quantit√†]
  - [USA_OGGETTO_PROPRIETA: Nome Propriet√†|Oggetto|Quantit√†]
  - [VENDI_OGGETTO_PROPRIETA: Nome Propriet√†|Oggetto|Quantit√†]
  - [SCARTA_OGGETTO_PROPRIETA: Nome Propriet√†|Oggetto|Quantit√†]
- NON usare [LOOT_PROPRIETA] per contanti: usa sempre [MECCANICA: soldi=¬±X].

üë®‚Äçüë©‚Äçüëß **FAMIGLIA**
- Il protagonista pu√≤ avere una famiglia (moglie/marito, figli, genitori, fratelli, ecc.).
- Usa [FAMIGLIA: nome|relazione|et√†|stato|descrizione|occupazione|reddito|spese] per registrare membri.
  - Relazioni: moglie, marito, figlio, figlia, padre, madre, fratello, sorella, nonno, nonna, zio, zia, cugino, cugina
  - Stato: alive, dead, missing, estranged (vivo, morto, disperso, distante)
  - Reddito: contributo economico mensile (se lavorano)
  - Spese: costo di mantenimento mensile
  - Esempio: [FAMIGLIA: Maria|moglie|28|alive|Donna dolce e premurosa|casalinga|0|30]
  - Esempio: [FAMIGLIA: Giovanni|figlio|8|alive|Bambino vivace|studente|0|20]
- I membri della famiglia influenzano la storia: bisogni, eventi, richieste.
- Usa [MORTE_FAMILIARE: nome] se un membro muore.

üë∑ **DIPENDENTI E PERSONALE**
- Se il protagonista ha propriet√†, pu√≤ assumere dipendenti.
- Usa [DIPENDENTE: nome|ruolo|propriet√†|stipendio|competenza|morale|descrizione] per assumere.
  - Ruoli: cameriere, cuoco, contadino, guardia, artigiano, commesso, maggiordomo, giardiniere, stalliere, ecc.
  - Propriet√†: nome della propriet√† dove lavora
  - Stipendio: paga periodica
  - Competenza: 0-100 (quanto √® bravo)
  - Morale: 0-100 (quanto √® motivato)
  - Esempio: [DIPENDENTE: Carlo|cameriere|Taverna del Sole|25|60|75|Giovane sveglio ma inesperto]
  - Esempio: [DIPENDENTE: Rosa|cuoca|Taverna del Sole|40|85|80|Esperta chef locale]
- Dipendenti con alta competenza migliorano i guadagni della propriet√†.
- Dipendenti con basso morale lavorano male o se ne vanno.
- Usa [LICENZIA: nome] per licenziare un dipendente.
- Gli stipendi vengono scalati automaticamente dal bilancio.

‚≠ê **ESPERIENZA E PROGRESSIONE**
- Assegna esperienza (EXP) al giocatore quando compie azioni significative:
  - Completamento di quest/obiettivi: +20 a +50 EXP
  - Vittoria in combattimento/sfida: +10 a +30 EXP
  - Soluzione creativa di problemi: +15 EXP
  - Prima esplorazione di luoghi importanti: +5 a +10 EXP
  - Negoziazione riuscita o diplomazia: +5 a +15 EXP
  - Scoperta di segreti/informazioni cruciali: +10 EXP
  - Azioni eroiche o memorabili: +20 a +40 EXP
- Usa il tag [MECCANICA: exp=+X] per assegnare esperienza.
- NON assegnare EXP per azioni banali (camminare, parlare normalmente, acquisti semplici).
- Il sistema gestisce automaticamente il level-up quando l'EXP raggiunge la soglia.

üìú **CRONACA DEL MONDO (Sistema Eventi)**
- Registra SEMPRE gli avvenimenti significativi per costruire la memoria narrativa.
- Usa [EVENTO: descrizione breve ma significativa dell'accaduto] per ogni evento importante.
- QUANDO usare [EVENTO:]:
  - Combattimenti: [EVENTO: Sconfitto il brigante che minacciava la strada]
  - Scoperte: [EVENTO: Trovato l'ingresso segreto della cripta]
  - Incontri: [EVENTO: Alleanza stretta con il mercante Lorenzo]
  - Scelte morali: [EVENTO: Risparmiata la vita al ladro pentito]
  - Cambiamenti: [EVENTO: La taverna ha aperto le porte per la prima volta]
  - Tragedie: [EVENTO: La tempesta ha danneggiato il raccolto]
  - Successi: [EVENTO: Primo guadagno dalla vendita di birra]
  - Fallimenti: [EVENTO: Negoziazione fallita con il barone]
- OGNI risposta dovrebbe contenere almeno 1-3 tag [EVENTO:] per registrare cosa √® successo.
- Gli eventi formano la cronaca della storia e aiutano a ricordare il passato.
- Sii specifico: "Combattuto contro lupi" √® meglio di "Combattimento".

üìã **QUEST E OBIETTIVI**
- Usa [QUEST: nome|descrizione|stato|progresso] per gestire le missioni.
  - Stato: active, completed, failed
  - Esempio: [QUEST: La spada perduta|Trova la spada dell'antico re|active|Indizio: ultima vista nella foresta]
- Aggiorna le quest quando ci sono progressi o si completano.

üìç **LUOGHI E MAPPE**
- Usa [LUOGO: nome|descrizione] per registrare luoghi visitati.
- Usa [POSIZIONE: nome_luogo] per segnalare dove si trova attualmente il protagonista.
- Ogni volta che il protagonista si sposta, usa [POSIZIONE: nome_luogo] per aggiornare la posizione.
- Descrivi i luoghi con dettagli sensoriali e atmosfera.
- Esempio: [LUOGO: Foresta dei Sussurri|Bosco antico dove il vento sembra parlare] [POSIZIONE: Foresta dei Sussurri]

üåç **MONDO VIVO (PNG AUTONOMI CON STATISTICHE)**
- Ogni PNG ha personalit√†, obiettivi, routine, LIVELLO e STATISTICHE proprie.
- Quando introduci un NPC importante, assegnagli statistiche realistiche:
  - Usa [NPC_STATS: nome|livello|for,des,cos,int,sag,car|minaccia] per definire le stats.
  - Livello: 1-5 comune, 6-10 veterano, 11-15 esperto, 16-20 leggendario.
  - Minaccia: low (guardia), medium (capitano), high (campione), boss (antagonista principale).
  - Esempio: [NPC_STATS: Guardia|3|12,10,14,8,10,8|low] [NPC_STATS: Mercante astuto|5|8,10,10,14,12,16|medium]
- Nei TIRI CONTRAPPOSTI (negoziazione, combattimento, inganno), il livello e le stats dell'NPC influenzano la difficolt√†:
  - Il giocatore tira D20 + mod + competenza
  - L'NPC tira D20 + suo mod + sua competenza
  - Chi ottiene di pi√π vince. Critici (1 e 20) sovrascrivono.
- Quando narri, considera sempre COSA STANNO FACENDO gli NPC. Mostrali in azione.
- I PNG ricordano le interazioni passate e cambiano atteggiamento.
- Usa [NPC: nome|descrizione|relazione|personalit√†|obiettivo|stato|posizione] per aggiornare i PNG.
- Usa [INTERAZIONE: nome_npc|tipo|dettagli] per interazioni significative.
- Mostra conseguenze delle scelte passate.
- NPC potenti (alto livello) sono pi√π difficili da ingannare, combattere o convincere.

üçΩÔ∏è **BISOGNI FISICI AUTOMATICI**
- Il sistema riduce automaticamente fame e energia col passare del tempo. Tu devi REAGIRE a questi valori nella narrazione.
- Se la fame √® bassa (‚â§30), descrivi i morsi della fame, la debolezza, la difficolt√† a concentrarsi.
- Se l'energia √® bassa (‚â§30), descrivi la stanchezza, gli occhi pesanti, i movimenti lenti.
- Se la salute √® bassa (‚â§30%), descrivi ferite, dolore, difficolt√† nei movimenti.
- Suggerisci (senza forzare) che il personaggio mangi, riposi o si curi quando necessario.
- Se il personaggio compie azioni fisiche intense con poca energia, applica [MECCANICA: stamina=-X] e descrivi la fatica crescente.

üß† MEMORIA MONDO:
${worldMemorySummary}
${buildNPCContext()}

${criticalConditions}

SCRIVI ${lengths[s.length]} di narrazione.`;

            // Controlla se c'√® un evento del mondo da menzionare
            const worldEvent = generateWorldEvent();
            
            // Mostra l'evento del mondo PRIMA della risposta (se presente)
            if (worldEvent && !isStart) {
                showWorldEvent(worldEvent);
            }

            let userMsg;
            if (isStart) {
                userMsg = `Inizia la storia. √à ${G.time.dayName} ${G.time.day} ${MONTHS[G.time.month - 1].name} ${G.time.year}, ${period.name}.
${story.prologue || 'Il protagonista inizia la sua avventura.'}
Descrivi la scena e l'equipaggiamento iniziale (usa [LOOT] per dare gli oggetti iniziali).
Metti in chiaro quanti ${c.currency?.short || 'soldi'} sono subito disponibili (${formatCurrency(c.gold)} secondo il sistema) e dove sono custoditi.
Se la narrazione prevede un importo diverso (es. capitale ereditato, fondo cassa, libro mastro con 2000 fiorini) applica immediatamente [MECCANICA: soldi=¬±X] per riallineare il saldo e cita il registro o il contante come oggetto fisico con [LOOT: ...] quando opportuno.`;
            } else {
                // Costruisci contesto stato fisico per l'IA
                let physicalState = '';
                if (c.hunger.cur <= 30) physicalState += ' [FAME CRITICA]';
                else if (c.hunger.cur <= 50) physicalState += ' [fame]';
                if (c.stamina.cur <= 30) physicalState += ' [STANCHEZZA CRITICA]';
                else if (c.stamina.cur <= 50) physicalState += ' [stanco]';
                if (c.health.cur <= c.health.max * 0.3) physicalState += ' [FERITO GRAVE]';
                else if (c.health.cur <= c.health.max * 0.5) physicalState += ' [ferito]';
                
                // Aggiungi contesto evento mondo se presente
                const worldEventContext = worldEvent ? `\n[EVENTO MONDO: ${worldEvent.text}]` : '';
                
                userMsg = `[Stato: HP ${c.health.cur}/${c.health.max} | Energia ${c.stamina.cur}/100 | Fame ${c.hunger.cur}/100 | Soldi ${formatCurrency(c.gold)}${physicalState}]
[Ora: ${getTimeString()} - ${period.name}]
[Posizione: ${G.currentLocation || 'Sconosciuto'}]${worldEventContext}
Il giocatore dichiara: "${action}"

ISTRUZIONI TURNO:
1. Prima verifica INVENTARIO e SOLDI. Il giocatore pu√≤ farlo?
2. Se l'azione √® incerta, TIRA I DADI: D20 + mod attributo + bonus competenza vs CD appropriata.
   - Azioni fisiche: usa FOR, DES o COS.
   - Azioni sociali: usa CAR o SAG.
   - Azioni intellettuali: usa INT o SAG.
   - Ricorda: il livello aumenta il bonus competenza!
3. Considera lo STATO FISICO: fame/energia basse = penalit√† -2 ai tiri; critiche = penalit√† -5.
4. MONDO VIVO: Cosa fanno gli NPC? Mostra il mondo che si muove intorno al giocatore.
5. Descrivi le conseguenze PROPORZIONATE al risultato del tiro (successo critico = bonus, fallimento critico = disastro).
6. Usa i tag appropriati [MECCANICA/LOOT/NPC/TEMPO] e consuma energia per sforzi fisici.
${worldEvent ? `6. INTEGRA L'EVENTO MONDO nella narrazione: ${worldEvent.text}` : ''}`;
            }

            let endpoint, model, headers;

            if (s.model === 'openrouter' && s.openrouterKey) {
                endpoint = 'https://openrouter.ai/api/v1/chat/completions';
                model = 'google/gemma-3-27b-it:free'; // Tier gratuito consigliato
                headers = { 'Content-Type': 'application/json; charset=utf-8', 'Authorization': `Bearer ${s.openrouterKey}` };
            } else if (s.model === 'deepseek') {
                const chimeraKey = s.kimeraKey || s.openrouterKey;
                if (!chimeraKey) {
                    throw new Error('Configura la Kimera (o OpenRouter) API key per usare DeepSeek.');
                }
                endpoint = 'https://openrouter.ai/api/v1/chat/completions';
                model = 'tngtech/deepseek-r1t2-chimera:free';
                headers = { 'Content-Type': 'application/json; charset=utf-8', 'Authorization': `Bearer ${chimeraKey}` };
            } else if (s.model === 'openrouter-free' && s.openrouterKey) {
                // Usa la SDK OpenRouter per il modello openrouter/free
                if (typeof OpenRouter !== 'undefined') {
                    const { OpenRouter: OR } = window;
                    const openrouter = new OR.default({ apiKey: s.openrouterKey });
                    
                    const stream = await openrouter.chat.completions.create({
                        model: 'openrouter/free',
                        messages: [
                            { role: 'system', content: systemPrompt },
                            ...recentHistory,
                            { role: 'user', content: userMsg }
                        ],
                        stream: true,
                        temperature: 0.7,
                        max_tokens: 1500
                    });
                    
                    let fullContent = '';
                    for await (const chunk of stream) {
                        const content = chunk.choices[0]?.delta?.content;
                        if (content) {
                            fullContent += content;
                        }
                        if (chunk.usage) {
                            console.log('OpenRouter - Reasoning tokens:', chunk.usage.reasoning_tokens || 0);
                        }
                    }
                    
                    console.log('OpenRouter response received via SDK');
                    return fullContent || '‚ö†Ô∏è Nessuna risposta ricevuta.';
                } else {
                    // Fallback: usa fetch diretto se SDK non disponibile
                    endpoint = 'https://openrouter.ai/api/v1/chat/completions';
                    model = 'openrouter/free';
                    headers = { 'Content-Type': 'application/json; charset=utf-8', 'Authorization': `Bearer ${s.openrouterKey}` };
                }
            } else if (s.groqKey) {
                endpoint = 'https://api.groq.com/openai/v1/chat/completions';
                model = 'llama-3.1-8b-instant'; // Consiglio il 70b per logica migliore, o 8b per velocit√†
                headers = { 'Content-Type': 'application/json; charset=utf-8', 'Authorization': `Bearer ${s.groqKey}` };
            } else {
                throw new Error('Configura le API keys nelle Impostazioni!');
            }

            const body = {
                model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    ...recentHistory,
                    { role: 'user', content: userMsg }
                ],
                temperature: 0.7, // Leggermente pi√π basso per essere pi√π rigoroso
                max_tokens: 1500
            };

            const res = await fetch(endpoint, { method: 'POST', headers, body: JSON.stringify(body) });
            
            // Debug: log della risposta completa
            console.log('API Response status:', res.status, res.statusText);
            
            if (!res.ok) {
                const errData = await res.json().catch(() => ({}));
                console.error('API Error data:', errData);
                throw new Error(errData.error?.message || `Errore API: ${res.status}`);
            }
            const data = await res.json();
            
            // Debug: log della struttura della risposta
            console.log('API Response data:', JSON.stringify(data).substring(0, 500));
            
            // Verifica che ci sia una risposta valida
            if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                console.error('Invalid API response structure:', data);
                throw new Error('Risposta API non valida. Riprova.');
            }
            
            const message = data.choices[0].message;
            // Alcuni modelli (come DeepSeek R1) mettono il contenuto in "reasoning" invece di "content"
            let content = message.content || '';
            
            // Se content √® vuoto ma c'√® reasoning, usa quello
            if (!content && message.reasoning) {
                console.log('Using reasoning field instead of content');
                content = message.reasoning;
            }
            
            // Fallback: cerca in altri campi possibili
            if (!content && message.text) {
                content = message.text;
            }
            
            console.log('AI Response received, length:', content.length);
            if (content.length < 20) {
                console.warn('AI Response very short:', content);
            }
            return content;
        }

        function parseAIResponse(response) {
            if (typeof response !== 'string') {
                response = response == null ? '' : String(response);
            }

            let memoryChanged = false;
            let uiStateChanged = false;
            G.storyBatchMode = true;

            try {

            // 1. ESTRAZIONE ANALISI (Nuova parte)
            const analysisRe = /\[ANALISI\]([\s\S]*?)\[\/ANALISI\]/gi;
            let m;
            let analysisContent = '';
            
            // Cattura tutto il contenuto di analisi
            while ((m = analysisRe.exec(response)) !== null) {
                analysisContent += m[1].trim() + '\n';
            }

            // Se c'√® un'analisi, la aggiungiamo come messaggio separato PRIMA della narrazione
            if (analysisContent) {
                // Pulisce un po' il testo dell'analisi per renderlo leggibile
                analysisContent = analysisContent.replace(/\[.*?\]:/g, '').trim(); 
                addStoryEntry(analysisContent, 'analysis');
            }

            // Extract time changes (supporta minuti, ore, giorni, settimane, mesi)
            // Formati: [TEMPO:+60] [TEMPO: 2 ore] [TEMPO: 3 giorni] [TEMPO: 1 giorno, 5 ore] [TEMPO: 1 settimana]
            const timeRe = /\[TEMPO:\s*([^\]]+)\]/gi;
            while ((m = timeRe.exec(response)) !== null) {
                const rawTime = m[1].trim();
                let totalMinutes = 0;
                
                // Prova prima il formato numerico semplice (minuti)
                const simpleNum = parseInt(rawTime.replace(/[+\s]/g, ''));
                if (!isNaN(simpleNum) && /^\+?\d+$/.test(rawTime.replace(/\s/g, ''))) {
                    totalMinutes = simpleNum;
                } else {
                    // Parse formato testuale: "X giorni", "Y ore", "Z minuti", "W settimane", "N mesi"
                    const patterns = [
                        { regex: /(\d+)\s*(?:mes[ei]|month)/gi, multiplier: 43200 },  // 1 mese = 30 giorni
                        { regex: /(\d+)\s*(?:settiman[ae]|week)/gi, multiplier: 10080 }, // 1 settimana = 7 giorni
                        { regex: /(\d+)\s*(?:giorn[oi]|day)/gi, multiplier: 1440 },   // 1 giorno = 24 ore
                        { regex: /(\d+)\s*(?:or[ae]|hour)/gi, multiplier: 60 },       // 1 ora = 60 minuti
                        { regex: /(\d+)\s*(?:minut[oi]|min)/gi, multiplier: 1 }       // minuti
                    ];
                    
                    patterns.forEach(({ regex, multiplier }) => {
                        let match;
                        while ((match = regex.exec(rawTime)) !== null) {
                            totalMinutes += parseInt(match[1]) * multiplier;
                        }
                    });
                    
                    // Se non ha trovato nulla, prova a interpretare come numero puro
                    if (totalMinutes === 0) {
                        const fallbackNum = parseInt(rawTime.replace(/\D/g, ''));
                        if (!isNaN(fallbackNum)) totalMinutes = fallbackNum;
                    }
                }
                
                if (totalMinutes > 0) {
                    advanceTime(totalMinutes);
                    uiStateChanged = true;
                    
                    // Formatta il messaggio in modo leggibile
                    let timeStr = '';
                    const days = Math.floor(totalMinutes / 1440);
                    const hours = Math.floor((totalMinutes % 1440) / 60);
                    const mins = totalMinutes % 60;
                    
                    if (days > 0) timeStr += `${days} giorno/i `;
                    if (hours > 0) timeStr += `${hours} ora/e `;
                    if (mins > 0 && days === 0) timeStr += `${mins} minuti`;
                    
                    addStoryEntry(`‚è∞ Passa ${timeStr.trim()}...`, 'system');
                }
            }

            // Extract mechanics
            const mechRe = /\[MECCANICA:\s*([^\]]+)\]/gi;
            let mechanicsApplied = 0;
            while ((m = mechRe.exec(response)) !== null) {
                applyMechanic(m[1], true);
                mechanicsApplied++;
            }
            if (mechanicsApplied > 0) {
                updateCharacterUI();
                checkStatusEffects();
                uiStateChanged = true;
            }

            // Extract LOOT (inventory items)
            const lootRe = /\[LOOT:\s*([^\]]+)\]/gi;
            while ((m = lootRe.exec(response)) !== null) {
                const raw = m[1];
                const parts = raw.split('|').map(p => p.trim());
                const itemName = parts[0] || '';
                const qty = parseInt(parts[1]) || 1;
                const description = parts[2] || '';
                const rawValue = parts.length >= 4 ? parseInt(parts[3]) : undefined;
                const value = Number.isFinite(rawValue) ? rawValue : undefined;
                const icon = parts[4] || '';
                // Skip non-physical items accidentally tagged as loot (e.g. "vista dalla finestra")
                const lowerName = itemName.toLowerCase();
                const intangiblePatterns = [
                    /vista\b.*finestra/,
                    /finestra\b.*vista/,
                    /\bpanorama\b/,
                    /\bscorcio\b/,
                    /\borizzonte\b/
                ];
                if (intangiblePatterns.some(re => re.test(lowerName))) {
                    addStoryEntry(`‚ö†Ô∏è Oggetto ignorato (non trasportabile): ${itemName}`, 'system');
                    continue;
                }
                addLootToInventory(itemName, qty, { description, value, icon });
                uiStateChanged = true;
            }

            // Extract USE/CONSUME from personal inventory
            const useItemRe = /\[(?:USA|CONSUMA|UTILIZZA|DROP|SCARTA):\s*([^|\]]+)(?:\|(\d+))?\]/gi;
            while ((m = useItemRe.exec(response)) !== null) {
                const itemName = (m[1] || '').trim();
                const qty = parseInt(m[2]) || 1;
                const removal = removeFromInventory(itemName, qty);
                if (removal.success) {
                    const suffix = removal.remaining > 0 ? ` (restano ${removal.remaining})` : ' (esaurito)';
                    addStoryEntry(`üîß Usato: ${removal.itemName} x${removal.removed}${suffix}`, 'mechanic');
                    uiStateChanged = true;
                } else {
                    addStoryEntry(`‚ö†Ô∏è Oggetto non trovato nell'inventario: ${itemName}`, 'system');
                }
            }

            // Extract NPC Stats (nuovo formato: nome|livello|for,des,cos,int,sag,car|minaccia)
            const npcStatsRe = /\[NPC_STATS:\s*([^|\]]+)\|([^|\]]+)\|([^|\]]+)\|([^|\]]+)\]/gi;
            while ((m = npcStatsRe.exec(response)) !== null) {
                const name = (m[1] || '').trim();
                const level = parseInt(m[2]) || 1;
                const statsStr = (m[3] || '').trim();
                const threat = (m[4] || 'low').trim().toLowerCase();
                
                // Parse stats: for,des,cos,int,sag,car
                const statValues = statsStr.split(',').map(s => parseInt(s.trim()) || 10);
                const stats = {
                    for: statValues[0] || 10,
                    des: statValues[1] || 10,
                    cos: statValues[2] || 10,
                    int: statValues[3] || 10,
                    sag: statValues[4] || 10,
                    car: statValues[5] || 10
                };
                
                addNPC(name, '', '', { level, stats, threat });
                addStoryEntry(`üë§ ${name} [Lv${level} ${threat}] stats registrate`, 'system');
                memoryChanged = true;
            }

            // Extract NPCs (formato esteso: nome|desc|rel|personalit√†|obiettivo|stato|posizione)
            const npcRe = /\[NPC:\s*([^|\]]+)(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^|\]]+))?\]/gi;
            while ((m = npcRe.exec(response)) !== null) {
                const name = (m[1] || '').trim();
                const desc = (m[2] || '').trim();
                const rel = (m[3] || '').trim();
                const personality = (m[4] || '').trim();
                const goals = (m[5] || '').trim();
                const status = (m[6] || '').trim();
                const location = (m[7] || '').trim();
                addNPC(name, desc, rel, { personality, goals, status, location });
                addStoryEntry(`üë• NPC registrato: ${name}`, 'memory-update');
                memoryChanged = true;
            }
            
            // Extract NPC Interactions (nuovo tag per interazioni significative)
            // Formato: [INTERAZIONE: nome_npc|tipo|dettagli]
            const interactionRe = /\[INTERAZIONE:\s*([^|]+)\|([^|]+)(?:\|([^\]]+))?\]/gi;
            while ((m = interactionRe.exec(response)) !== null) {
                const npcName = (m[1] || '').trim();
                const interactionType = (m[2] || '').trim();
                const details = (m[3] || '').trim();
                recordNPCInteraction(npcName, interactionType, details);
                memoryChanged = true;
            }

            // Extract Locations
            const locRe = /\[LUOGO:\s*([^|]+)\|([^\]]+)\]/gi;
            while ((m = locRe.exec(response)) !== null) {
                const name = m[1].trim();
                const desc = m[2].trim();
                addLocation(name, desc);
                setLocation(name);
                addStoryEntry(`üìç Luogo scoperto: ${name}`, 'memory-update');
                memoryChanged = true;
            }

            // Extract Position/Location changes
            const posRe = /\[POSIZIONE:\s*([^\]]+)\]/gi;
            while ((m = posRe.exec(response)) !== null) {
                setLocation(m[1].trim());
                memoryChanged = true;
            }

            // Extract Quests
            const questRe = /\[QUEST:\s*([^|]+)\|([^|]+)\|([^\]]+)\]/gi;
            while ((m = questRe.exec(response)) !== null) {
                const name = m[1].trim();
                const desc = m[2].trim();
                const status = m[3].trim().toLowerCase();
                addQuest(name, desc, status);
                if (status === 'completed') {
                    addStoryEntry(`üìã Quest completata: ${name}`, 'memory-update');
                } else {
                    addStoryEntry(`üìã Nuova quest: ${name}`, 'memory-update');
                }
                memoryChanged = true;
            }

            // Extract Special Items
            const itemRe = /\[OGGETTO:\s*([^|]+)\|([^|]+)\|([^\]]+)\]/gi;
            while ((m = itemRe.exec(response)) !== null) {
                const name = m[1].trim();
                const desc = m[2].trim();
                const icon = m[3].trim();
                addSpecialItem(name, desc, icon);
                memoryChanged = true;
            }

            // Extract Properties / Assets (formato esteso: nome|desc|note|tipo|condizione|valore|reddito)
            const propertyRe = /\[PROPRIETA:\s*([^|]+)\|([^|]+)(?:\|([^|]*))?(?:\|([^|]*))?(?:\|([^|]*))?(?:\|([^|]*))?(?:\|([^\]]*))?\]/gi;
            while ((m = propertyRe.exec(response)) !== null) {
                const name = m[1].trim();
                const desc = m[2].trim();
                const notes = (m[3] || '').trim();
                const type = (m[4] || 'building').trim();
                const condition = parseInt(m[5]) || 80;
                const baseValue = parseInt(m[6]) || undefined;
                const income = parseInt(m[7]) || undefined;
                addProperty(name, desc, notes, { type, condition, baseValue, income });
                memoryChanged = true;
            }

            // Extract Family Members
            // Formato: [FAMIGLIA: nome|relazione|et√†|stato|descrizione|occupazione|reddito|spese]
            const familyRe = /\[FAMIGLIA:\s*([^|\]]+)(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^\]]+))?\]/gi;
            while ((m = familyRe.exec(response)) !== null) {
                const name = (m[1] || '').trim();
                const relation = (m[2] || '').trim();
                const age = parseInt(m[3]) || null;
                const status = (m[4] || 'alive').trim();
                const description = (m[5] || '').trim();
                const occupation = (m[6] || '').trim();
                const income = parseInt(m[7]) || 0;
                const expenses = parseInt(m[8]) || 0;
                if (name && relation) {
                    addFamilyMember(name, relation, { age, status, description, occupation, income, expenses });
                    memoryChanged = true;
                }
            }

            // Extract Employees
            // Formato: [DIPENDENTE: nome|ruolo|propriet√†|stipendio|competenza|morale|descrizione]
            const employeeRe = /\[DIPENDENTE:\s*([^|\]]+)(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^|\]]+))?(?:\|([^\]]+))?\]/gi;
            while ((m = employeeRe.exec(response)) !== null) {
                const name = (m[1] || '').trim();
                const role = (m[2] || '').trim();
                const property = (m[3] || '').trim();
                const salary = parseInt(m[4]) || 0;
                const skill = parseInt(m[5]) || 50;
                const morale = parseInt(m[6]) || 70;
                const description = (m[7] || '').trim();
                if (name && role) {
                    addEmployee(name, role, property, salary, { skill, morale, description });
                    memoryChanged = true;
                }
            }

            // Extract Employee removal
            const fireEmployeeRe = /\[LICENZIA:\s*([^\]]+)\]/gi;
            while ((m = fireEmployeeRe.exec(response)) !== null) {
                const name = m[1].trim();
                removeEmployee(name, 'fired');
                memoryChanged = true;
            }

            // Extract Family member death/departure
            const familyDeathRe = /\[MORTE_FAMILIARE:\s*([^\]]+)\]/gi;
            while ((m = familyDeathRe.exec(response)) !== null) {
                const name = m[1].trim();
                removeFamilyMember(name, 'dead');
                memoryChanged = true;
            }

            // Extract Abilities
            const abilityRe = /\[ABILIT√Ä:\s*([^|]+)\|([^\]]+)\]/gi;
            while ((m = abilityRe.exec(response)) !== null) {
                const name = m[1].trim();
                const desc = m[2].trim();
                addAbility(name, desc);
                memoryChanged = true;
            }

            // Extract LOOT_PROPRIETA (beni stoccati nelle propriet√†)
            // Formato: [LOOT_PROPRIETA: Nome Propriet√†|Oggetto|categoria=strumentali/produzione/vendibili|Quantit√†|Descrizione|Valore|Icona]
            const propertyLootRe = /\[LOOT_PROPRIETA:\s*([^\]]+)\]/gi;
            while ((m = propertyLootRe.exec(response)) !== null) {
                const raw = m[1];
                const parts = raw.split('|').map(p => p.trim());
                const propertyName = parts[0] || '';
                const itemName = parts[1] || '';
                if (!propertyName || !itemName) {
                    addStoryEntry('‚ö†Ô∏è Tag [LOOT_PROPRIETA] incompleto. Usa [LOOT_PROPRIETA: Nome Propriet√†|Oggetto|categoria=...|Quantit√†|Descrizione|Valore|Icona]', 'system');
                    continue;
                }

                let idx = 2;
                let qty = 1;
                let categoryKey = null;
                if (parts[idx]) {
                    const maybeCategory = extractPropertyCategoryToken(parts[idx]);
                    if (maybeCategory) {
                        categoryKey = maybeCategory;
                        idx++;
                    }
                }
                if (parts[idx]) {
                    const parsedQty = parseInt(parts[idx], 10);
                    if (!Number.isNaN(parsedQty) && parsedQty > 0) {
                        qty = parsedQty;
                        idx++;
                    }
                }
                if (parts[idx] && !categoryKey) {
                    const maybeCategory = extractPropertyCategoryToken(parts[idx]);
                    if (maybeCategory) {
                        categoryKey = maybeCategory;
                        idx++;
                    }
                }
                const description = parts[idx] || '';
                if (description) idx++;
                let value;
                let icon = '';
                if (parts[idx]) {
                    const parsedVal = parseInt(parts[idx], 10);
                    if (!Number.isNaN(parsedVal)) {
                        value = parsedVal;
                        idx++;
                    } else {
                        icon = parts[idx];
                        idx++;
                    }
                }
                if (value === undefined && parts[idx]) {
                    const parsedVal = parseInt(parts[idx], 10);
                    if (!Number.isNaN(parsedVal)) {
                        value = parsedVal;
                        idx++;
                    }
                }
                if (!icon && parts[idx]) {
                    icon = parts[idx];
                }

                addLootToPropertyInventory(propertyName, itemName, qty, { description, value, icon, category: categoryKey });
                memoryChanged = true;
            }

            // Extract Property Inventory Commands (CONSUMA/USA/SCARTA/VENDI_OGGETTO_PROPRIETA)
            const propertyInventoryCmdRe = /\[((?:CONSUMA|USA|UTILIZZA|SCARTA|DROP|VENDI)(?:_OGGETTO)?_PROPRIETA):\s*([^|\]]+)\|([^|\]]+)(?:\|([^\]]+))?\]/gi;
            while ((m = propertyInventoryCmdRe.exec(response)) !== null) {
                const command = (m[1] || '').trim().toUpperCase();
                const propertyName = (m[2] || '').trim();
                const itemId = (m[3] || '').trim();
                const qtyRaw = (m[4] || '').trim();
                const qtyParsed = qtyRaw ? parseInt(qtyRaw.replace(/[^0-9-]/g, ''), 10) : undefined;
                const qty = Number.isFinite(qtyParsed) ? Math.abs(qtyParsed) : undefined;
                if (!propertyName || !itemId) {
                    addStoryEntry('‚ö†Ô∏è Tag propriet√† incompleto. Usa ad esempio [CONSUMA_OGGETTO_PROPRIETA: Villa Aurora|Bottiglia di vino|1]', 'system');
                    continue;
                }

                const removal = removeItemFromPropertyInventory(propertyName, itemId, Number.isFinite(qty) && qty > 0 ? qty : undefined);
                if (!removal) {
                    addStoryEntry(`‚ö†Ô∏è Oggetto non trovato nell'inventario di propriet√† (${command}): ${itemId} @ ${propertyName}`, 'system');
                    continue;
                }
                if (removal.removed <= 0) {
                    addStoryEntry(`‚ö†Ô∏è Nessuna quantit√† rimossa da ${propertyName}: ${itemId}`, 'system');
                    continue;
                }

                const commandKey = command.replace('_OGGETTO', '');
                const commandMap = {
                    'CONSUMA_PROPRIETA': { icon: 'ü•Ñ', verb: 'Consumati' },
                    'USA_PROPRIETA': { icon: '‚öôÔ∏è', verb: 'Usati' },
                    'UTILIZZA_PROPRIETA': { icon: '‚öôÔ∏è', verb: 'Usati' },
                    'SCARTA_PROPRIETA': { icon: 'üóëÔ∏è', verb: 'Scartati' },
                    'DROP_PROPRIETA': { icon: 'üóëÔ∏è', verb: 'Scartati' },
                    'VENDI_PROPRIETA': { icon: 'üíº', verb: 'Venduti' }
                };
                const meta = commandMap[commandKey] || { icon: 'üóëÔ∏è', verb: 'Rimossi' };
                const countLabel = removal.removed > 1 ? `${removal.removed}x ` : '';
                const suffix = removal.remaining > 0 ? ` (restano ${removal.remaining})` : ' (esaurito)';
                const propertyLabel = removal.property?.name || propertyName;
                addStoryEntry(`${meta.icon} ${propertyLabel}: ${meta.verb} ${countLabel}${removal.itemName}${suffix}`, 'system');
                memoryChanged = true;
            }

            // Extract Events
            const eventRe = /\[EVENTO:\s*([^\]]+)\]/gi;
            while ((m = eventRe.exec(response)) !== null) {
                const summary = m[1].trim();
                addEvent(summary);
                memoryChanged = true;
            }

            // Extract suggestions
            const suggRe = /\[SUGGERIMENTO:\s*([^|]+)\|([^\]]+)\]/gi;
            const suggestions = [];
            while ((m = suggRe.exec(response)) !== null) {
                suggestions.push({ type: m[1].trim(), text: m[2].trim() });
            }

            // Clean response (AGGIUNGI LA RIGA PER RIMUOVERE [ANALISI])
            let clean = response
                .replace(/\[ANALISI\][\s\S]*?\[\/ANALISI\]/gi, '') // <--- AGGIUNTA IMPORTANTE
                .replace(/\[TEMPO:[^\]]*\]/gi, '')
                .replace(/\[MECCANICA:[^\]]*\]/gi, '')
                .replace(/\[LOOT:[^\]]*\]/gi, '')
                .replace(/\[LOOT_PROPRIETA:[^\]]*\]/gi, '')
                .replace(/\[(?:CONSUMA|USA|UTILIZZA|SCARTA|DROP|VENDI)(?:_OGGETTO)?_PROPRIETA:[^\]]*\]/gi, '')
                .replace(/\[SUGGERIMENTO:[^\]]*\]/gi, '')
                .replace(/\[NPC:[^\]]*\]/gi, '')
                .replace(/\[NPC_STATS:[^\]]*\]/gi, '')
                .replace(/\[INTERAZIONE:[^\]]*\]/gi, '')
                .replace(/\[LUOGO:[^\]]*\]/gi, '')
                .replace(/\[QUEST:[^\]]*\]/gi, '')
                .replace(/\[OGGETTO:[^\]]*\]/gi, '')
                .replace(/\[PROPRIETA:[^\]]*\]/gi, '')
                .replace(/\[ABILIT√Ä:[^\]]*\]/gi, '')
                .replace(/\[FAMIGLIA:[^\]]*\]/gi, '')
                .replace(/\[DIPENDENTE:[^\]]*\]/gi, '')
                .replace(/\[LICENZIA:[^\]]*\]/gi, '')
                .replace(/\[MORTE_FAMILIARE:[^\]]*\]/gi, '')
                .replace(/\[EVENTO:[^\]]*\]/gi, '')
                .replace(/\[POSIZIONE:[^\]]*\]/gi, '')
                .replace(/\[SCELTA:[^\]]*\]/gi, '')
                .replace(/\[(?:USA|CONSUMA|UTILIZZA|DROP|SCARTA):[^\]]*\]/gi, '')
                .replace(/#{1,6}\s*/g, '')
                .replace(/\*\*([^*]+)\*\*/g, '$1')
                .replace(/\_\_([^_]+)\_\_/g, '$1')
                .replace(/```[^`]*```/g, '')
                .replace(/`([^`]+)`/g, '$1')
                .replace(/\*([^*\n]+)\*/g, '<em>$1</em>')
                .replace(/\n{3,}/g, '\n\n')
                .trim();

            if (!clean || clean.length < 10) {
                console.warn('AI response too short or empty. Original:', response);
                console.warn('Cleaned result:', clean);
                // Se la risposta originale ha contenuto, ma √® stata tutta pulita,
                // potrebbe esserci un problema con i tag
                if (response && response.length > 50) {
                    // Prova a estrarre qualcosa di leggibile
                    clean = response
                        .replace(/\[[^\]]*\]/g, '') // Rimuovi tutti i tag
                        .replace(/#{1,6}\s*/g, '')
                        .replace(/\*\*([^*]+)\*\*/g, '$1')
                        .replace(/\n{3,}/g, '\n\n')
                        .trim();
                    if (clean.length < 10) {
                        clean = "Il narratore sta elaborando... Prova a ripetere l'azione.";
                    }
                } else {
                    clean = "Il narratore sembra confuso... Riprova con un'altra azione.";
                }
            }

            addStoryEntry(clean, 'narrator');
            displaySuggestions(suggestions);
            if (!uiStateChanged) updateCharacterUI();
            updateTimeDisplay();
            if (memoryChanged) updateMemoryUI();
            } finally {
                G.storyBatchMode = false;
                flushStoryBatchScroll();
            }
        }

        function applyMechanic(mech, suppressUiUpdate = false) {
            const [type, valRaw] = mech.split('=').map(s => s.trim());
            // Rimuovi punti e virgole usati come separatori migliaia (es. 10.000.000 o 10,000,000)
            const valClean = (valRaw || '').replace(/[.,\s]/g, '').toLowerCase();
            const v = parseInt(valClean) || 0;
            const c = G.character;
            const normalizedType = type.toLowerCase();

            if (matchesSecondaryKey(normalizedType, c.secondary)) {
                adjustSecondary(v, c);
                addStoryEntry(formatSecondaryDelta(v, c.secondary), 'mechanic');
                if (!suppressUiUpdate) {
                    updateCharacterUI();
                    checkStatusEffects();
                }
                return;
            }

            switch (normalizedType) {
                case 'danno': case 'damage':
                    c.health.cur = Math.max(0, c.health.cur - Math.abs(v));
                    addStoryEntry(`üíî -${Math.abs(v)} HP`, 'mechanic');
                    break;
                case 'cura': case 'heal':
                    c.health.cur = Math.min(c.health.max, c.health.cur + Math.abs(v));
                    addStoryEntry(`üíö +${Math.abs(v)} HP`, 'mechanic');
                    break;
                case 'soldi': case 'gold': case 'money': case 'denaro': case 'cash': case 'contanti': case 'ricchezza': case 'fiorini': case 'fiorino':
                    const prevGold = c.gold;
                    c.gold = c.gold + v; // PERMETTE DEBITI (niente Math.max)
                    const deltaGold = c.gold - prevGold;
                    const currSymbol = c.currency?.symbol || c.currency?.short || 'üí∞';
                    
                    // Log della transazione per tracciamento
                    logTransaction(deltaGold, 'meccanica', c.gold);
                    
                    if (c.gold < 0) {
                        addStoryEntry(`üî¥ DEBITO: ${currSymbol} ${deltaGold.toLocaleString('it-IT')} (Saldo: ${c.gold.toLocaleString('it-IT')})`, 'mechanic');
                    } else {
                        addStoryEntry(`${currSymbol} ${deltaGold >= 0 ? '+' : ''}${deltaGold.toLocaleString('it-IT')} (Saldo: ${c.gold.toLocaleString('it-IT')})`, 'mechanic');
                    }
                    break;
                case 'exp': case 'experience':
                    c.exp.cur += Math.abs(v);
                    addStoryEntry(`‚≠ê +${Math.abs(v)} EXP`, 'mechanic');
                    checkLevelUp();
                    break;
                case 'stamina': case 'energia':
                    c.stamina.cur = Math.max(0, Math.min(c.stamina.max, c.stamina.cur + v));
                    addStoryEntry(`‚ö° ${v >= 0 ? '+' : ''}${v} Energia`, 'mechanic');
                    break;
                case 'fame': case 'hunger':
                    c.hunger.cur = Math.max(0, Math.min(c.hunger.max, c.hunger.cur + v));
                    addStoryEntry(`üçñ ${v >= 0 ? '+' : ''}${v} Saziet√†`, 'mechanic');
                    break;
            }
            if (!suppressUiUpdate) {
                updateCharacterUI();
                checkStatusEffects(); // Controlla subito lo stato
            }
        }

        function checkLevelUp() {
            const c = G.character;
            while (c.exp.cur >= c.exp.need) {
                c.exp.cur -= c.exp.need;
                c.level = (c.level || 1) + 1;
                c.exp.lvl = c.level; // Sincronizza exp.lvl con level
                c.exp.need = Math.floor(c.exp.need * 1.5);
                
                // Aumenta stats principali
                c.health.max += 5;
                c.health.cur = c.health.max;
                c.stamina.max += 10;
                c.stamina.cur = c.stamina.max;
                c.hunger.cur = c.hunger.max; // Saziet√† piena al level up
                
                if (c.secondary) {
                    const bonus = c.secondary.levelUpBonus || 0;
                    if (bonus) c.secondary.max += bonus;
                    c.secondary.cur = c.secondary.max;
                }
                
                notify(`üéâ Livello ${c.level}!`, 'success');
                addStoryEntry(`üéâ LIVELLO ${c.level}! HP max +5, Stamina max +10. Bonus competenza: +${getProficiencyBonus()}`, 'mechanic');
                addEvent(`Il protagonista √® salito al livello ${c.level}!`);
                
                // Show level-up choice modal for attribute increase
                showLevelUpModal(c.level);
            }
        }

        async function generateStorySummary() {
            // Auto-generate a comprehensive narrative summary every N turns
            const wm = G.worldMemory;
            const c = G.character;
            const recentEvents = wm.events.slice(-20);
            if (recentEvents.length < 3) return;
            
            let summary = '';
            
            // 1. IDENTIT√Ä E SITUAZIONE ATTUALE DEL PROTAGONISTA
            summary += `üìú CRONACA DI ${(c?.name || 'L\'AVVENTURIERO').toUpperCase()}\n\n`;
            
            if (c) {
                const originDesc = c.origin ? `di origini ${c.origin.toLowerCase()}` : '';
                const archetypeDesc = c.archetype ? `, ${c.archetype.toLowerCase()} di professione` : '';
                summary += `Il protagonista${originDesc}${archetypeDesc} √® attualmente al livello ${c.exp?.lvl || 1}. `;
                
                // Stato economico narrativo
                if (c.gold < 0) {
                    summary += `Si trova in grave difficolt√† economica, con un debito di ${Math.abs(c.gold)} che pesa sulla sua coscienza. `;
                } else if (c.gold < 50) {
                    summary += `Le sue risorse sono scarse, con appena ${c.gold} in tasca. `;
                } else if (c.gold > 1000) {
                    summary += `Ha accumulato una discreta ricchezza di ${c.gold}. `;
                }
                
                // Condizione fisica narrativa
                const healthPercent = (c.health.cur / c.health.max) * 100;
                if (healthPercent < 30) {
                    summary += `Il suo corpo porta i segni di ferite gravi che richiedono cure. `;
                } else if (healthPercent < 60) {
                    summary += `Alcune ferite ancora lo tormentano. `;
                }
                
                summary += '\n\n';
            }
            
            // 2. ARCO NARRATIVO - Cosa √® successo finora
            summary += 'üìñ SVILUPPO DELLA STORIA:\n';
            
            // Raggruppa eventi per tipologia
            const combatEvents = recentEvents.filter(e => 
                /combatt|battaglia|sconfitt|vittoria|mort[eo]|attacc|ferit/i.test(e.summary)
            );
            const discoveryEvents = recentEvents.filter(e => 
                /scopert|trovato|esplorat|raggiungt|entrat|arrivat/i.test(e.summary)
            );
            const socialEvents = recentEvents.filter(e => 
                /parlat|incontrat|alleat|negozia|accordo|promess/i.test(e.summary)
            );
            const questEvents = recentEvents.filter(e => 
                /quest|missione|obiettivo|complet|incaric/i.test(e.summary)
            );
            
            // Costruisci narrazione fluida degli eventi
            if (questEvents.length > 0) {
                const questNarrative = questEvents.slice(-3).map(e => e.summary).join('. ');
                summary += `‚Ä¢ Progressione obiettivi: ${questNarrative}. `;
            }
            
            if (combatEvents.length > 0) {
                const combatNarrative = combatEvents.slice(-3).map(e => e.summary).join('. ');
                summary += `‚Ä¢ Conflitti affrontati: ${combatNarrative}. `;
            }
            
            if (discoveryEvents.length > 0) {
                const discoveryNarrative = discoveryEvents.slice(-3).map(e => e.summary).join('. ');
                summary += `‚Ä¢ Esplorazioni e scoperte: ${discoveryNarrative}. `;
            }
            
            if (socialEvents.length > 0) {
                const socialNarrative = socialEvents.slice(-3).map(e => e.summary).join('. ');
                summary += `‚Ä¢ Interazioni significative: ${socialNarrative}. `;
            }
            
            // Eventi recenti generici se non categorizzati
            const uncategorized = recentEvents.filter(e => 
                !combatEvents.includes(e) && !discoveryEvents.includes(e) && 
                !socialEvents.includes(e) && !questEvents.includes(e)
            );
            if (uncategorized.length > 0 && summary.length < 500) {
                const otherNarrative = uncategorized.slice(-5).map(e => e.summary).join('. ');
                summary += `‚Ä¢ Altri avvenimenti: ${otherNarrative}. `;
            }
            
            summary += '\n\n';
            
            // 3. RELAZIONI E ALLEANZE
            const meaningfulNPCs = wm.npcs.filter(n => n.description || n.relationship || n.interactionCount > 1);
            if (meaningfulNPCs.length > 0) {
                summary += 'üë• PERSONAGGI RILEVANTI:\n';
                
                const allies = meaningfulNPCs.filter(n => 
                    /amic|alleat|fidato|compagn|mentor/i.test(n.relationship || '')
                );
                const enemies = meaningfulNPCs.filter(n => 
                    /nemic|ostile|avversar|rivale|antagonist/i.test(n.relationship || '')
                );
                const neutral = meaningfulNPCs.filter(n => 
                    !allies.includes(n) && !enemies.includes(n)
                );
                
                if (allies.length > 0) {
                    summary += `‚Ä¢ Alleati e amici: ${allies.map(n => {
                        let desc = n.name;
                        if (n.description) desc += ` (${n.description.substring(0, 50)})`;
                        return desc;
                    }).join('; ')}. `;
                }
                
                if (enemies.length > 0) {
                    summary += `‚Ä¢ Nemici e rivali: ${enemies.map(n => {
                        let desc = n.name;
                        if (n.description) desc += ` (${n.description.substring(0, 50)})`;
                        return desc;
                    }).join('; ')}. `;
                }
                
                if (neutral.length > 0 && neutral.length <= 5) {
                    summary += `‚Ä¢ Altri conosciuti: ${neutral.map(n => n.name).join(', ')}. `;
                } else if (neutral.length > 5) {
                    summary += `‚Ä¢ Altri ${neutral.length} personaggi conosciuti. `;
                }
                
                summary += '\n\n';
            }
            
            // 4. QUEST E OBIETTIVI
            const activeQuests = wm.quests.filter(q => q.status === 'active');
            const completedQuests = wm.quests.filter(q => q.status === 'completed');
            
            if (activeQuests.length > 0 || completedQuests.length > 0) {
                summary += 'üìã OBIETTIVI:\n';
                
                if (activeQuests.length > 0) {
                    summary += `‚Ä¢ In corso: ${activeQuests.map(q => {
                        let desc = q.name;
                        if (q.description) desc += ` - ${q.description.substring(0, 60)}`;
                        if (q.progress) desc += ` [${q.progress}]`;
                        return desc;
                    }).join('; ')}. `;
                }
                
                if (completedQuests.length > 0) {
                    summary += `‚Ä¢ Completate: ${completedQuests.map(q => q.name).join(', ')}. `;
                }
                
                summary += '\n\n';
            }
            
            // 5. LUOGHI SIGNIFICATIVI
            if (wm.locations.length > 0) {
                summary += 'üó∫Ô∏è LUOGHI VISITATI:\n';
                const recentLocations = wm.locations.slice(-8);
                summary += recentLocations.map(l => {
                    let desc = `‚Ä¢ ${l.name}`;
                    if (l.description) desc += `: ${l.description.substring(0, 80)}`;
                    return desc;
                }).join('\n');
                summary += '\n\n';
            }
            
            // 6. PROPRIET√Ä E BENI
            if (wm.properties?.length > 0) {
                summary += 'üè∞ PATRIMONIO:\n';
                wm.properties.forEach(p => {
                    const cond = getPropertyCondition(p.condition || 50);
                    summary += `‚Ä¢ ${p.name} (${cond.label}): ${p.description || 'Nessuna descrizione'}`;
                    if (p.inventory?.length > 0) {
                        const totalItems = p.inventory.reduce((sum, i) => sum + (i.count || 1), 0);
                        summary += ` [Magazzino: ${totalItems} articoli]`;
                    }
                    summary += '. ';
                });
                summary += '\n\n';
            }
            
            // 7. ABILIT√Ä E OGGETTI SPECIALI
            if (wm.acquiredAbilities.length > 0 || wm.acquiredItems.length > 0) {
                summary += '‚ú® ACQUISIZIONI SPECIALI:\n';
                if (wm.acquiredAbilities.length > 0) {
                    summary += `‚Ä¢ Abilit√†: ${wm.acquiredAbilities.map(a => a.name).join(', ')}. `;
                }
                if (wm.acquiredItems.length > 0) {
                    summary += `‚Ä¢ Oggetti unici: ${wm.acquiredItems.map(i => i.name).join(', ')}. `;
                }
                summary += '\n\n';
            }
            
            // 8. FAMIGLIA
            if (wm.family && wm.family.length > 0) {
                summary += 'üë®‚Äçüë©‚Äçüëß FAMIGLIA:\n';
                wm.family.forEach(f => {
                    let desc = `‚Ä¢ ${f.name} (${f.role})`;
                    if (f.age) desc += `, ${f.age} anni`;
                    if (f.status && f.status !== 'active') desc += ` [${f.status}]`;
                    if (f.description) desc += `: ${f.description}`;
                    summary += desc + '\n';
                });
                summary += '\n';
            }
            
            // 9. DIPENDENTI
            if (wm.employees && wm.employees.length > 0) {
                summary += 'üë∑ DIPENDENTI:\n';
                const byProperty = {};
                wm.employees.forEach(e => {
                    const prop = e.property || 'Generici';
                    if (!byProperty[prop]) byProperty[prop] = [];
                    byProperty[prop].push(e);
                });
                Object.entries(byProperty).forEach(([prop, emps]) => {
                    summary += `‚Ä¢ ${prop}:\n`;
                    emps.forEach(e => {
                        let desc = `  - ${e.name} (${e.role})`;
                        if (e.competence) desc += `, competenza ${e.competence}%`;
                        if (e.salary) desc += `, stipendio ${e.salary}üí∞`;
                        if (e.status && e.status !== 'active') desc += ` [${e.status}]`;
                        summary += desc + '\n';
                    });
                });
                summary += '\n';
            }
            
            // 10. ULTIMI AVVENIMENTI (cronologia recente)
            summary += '‚è≥ ULTIMI AVVENIMENTI:\n';
            const last5Events = recentEvents.slice(-5);
            last5Events.forEach((e, i) => {
                summary += `${i + 1}. ${e.summary}\n`;
            });
            
            wm.storySummary = summary.trim();
            wm.lastSummaryTurn = wm.turnCount;
        }

        function ensureStoryGenres() {
            G.stories = (G.stories || []).map(s => {
                if (!s.genre) s.genre = resolveGenreKey(s);
                return s;
            });
        }

        function renderCreationOptions() {
            const storyIdx = parseInt($('new-game-story').value) || 0;
            const story = G.stories[storyIdx] || G.stories[0] || {};
            const genreCfg = getGenreConfig(story);
            const originEntries = Object.entries(genreCfg.origins || {});
            const archeEntries = Object.entries(genreCfg.archetypes || {});
            if (!G.selectedOrigin || !genreCfg.origins[G.selectedOrigin]) G.selectedOrigin = originEntries[0]?.[0] || null;
            if (!G.selectedArchetype || !genreCfg.archetypes[G.selectedArchetype]) G.selectedArchetype = archeEntries[0]?.[0] || null;
            $('origin-grid').innerHTML = originEntries.map(([k, v]) => `
                <div class="creation-option ${G.selectedOrigin === k ? 'selected' : ''}" data-origin="${k}" title="${v.desc}">
                    <div class="creation-icon">${v.icon}</div>
                    <div class="creation-name">${v.name}</div>
                </div>
            `).join('');
            $('archetype-grid').innerHTML = archeEntries.map(([k, v]) => `
                <div class="creation-option ${G.selectedArchetype === k ? 'selected' : ''}" data-archetype="${k}" title="${v.desc}">
                    <div class="creation-icon">${v.icon}</div>
                    <div class="creation-name">${v.name}</div>
                </div>
            `).join('');
        }

        // ==================== DICE ====================
        function rollDice(sides) {
            const result = roll(sides);
            const c = G.character;
            let msg = `üé≤ D${sides}: ${result}`;
            
            // Se √® un D20 e c'√® un personaggio, mostra anche bonus potenziale
            if (sides === 20 && c) {
                const profBonus = getProficiencyBonus();
                msg += ` (Bonus competenza lv${c.level || 1}: +${profBonus})`;
            }
            
            $('dice-result').textContent = msg;
            // Usa 'system' per non sporcare il racconto
            addStoryEntry(msg, 'system');
        }

        // Tiro rapido con attributo specifico
        function rollSkillCheck(attribute, difficulty, skillName) {
            const result = performSkillCheck(attribute, difficulty, skillName);
            showSkillCheckResult(result, skillName || attribute);
            return result;
        }

        // ==================== INIT ====================
        function init() {
            load();
            ensureStoryGenres();
            updateHome();
            updateStoriesUI();
            updateSavesUI();
            if (!G.isPlaying && G.stories.length > 0) {
                G.time = getStartTimeForStory(G.stories[0]);
            }

            $('set-groq-key').value = G.settings.groqKey || '';
            $('set-openrouter-key').value = G.settings.openrouterKey || '';
            $('set-kimera-key').value = G.settings.kimeraKey || '';
            $('set-model').value = G.settings.model || 'groq';
            $('set-length').value = G.settings.length || 'medium';
            $('set-autoroll').checked = G.settings.autoRoll !== false;

            renderCreationOptions();

            // HOME BUTTONS
            $('btn-continue').onclick = () => showScreen('game-screen');
            $('btn-new-game').onclick = () => { renderCreationOptions(); openModal('modal-new-game'); };
            $('btn-load-game').onclick = () => { updateSavesUI(); openModal('modal-saves'); };
            $('btn-stories').onclick = () => { updateStoriesUI(); openModal('modal-stories'); };
            $('btn-settings').onclick = () => openModal('modal-settings');

            // GAME TOPBAR
            $('btn-exit').onclick = exitGame;
            $('btn-save-quick').onclick = () => { updateSavesUI(); openModal('modal-saves'); };
            $('btn-dice').onclick = () => openModal('modal-dice');
            $('btn-inventory').onclick = () => { updateCharacterUI(); openModal('modal-inventory'); };
            $('btn-character').onclick = () => { updateCharacterUI(); openModal('modal-character'); };
            $('btn-memory').onclick = () => { updateMemoryUI(); openModal('modal-memory'); };

            // ACTION BAR
            if ($('btn-rest')) $('btn-rest').onclick = doRest;
            if ($('btn-eat')) $('btn-eat').onclick = doEat;
            if ($('btn-heal')) $('btn-heal').onclick = doCure;
            if ($('btn-wait')) $('btn-wait').onclick = () => openModal('modal-wait');
            if ($('btn-train')) $('btn-train').onclick = doTrain;
            
            // Info panels click handlers
            if ($('panel-finances')) $('panel-finances').onclick = showFinancesDetail;
            if ($('panel-family')) $('panel-family').onclick = showFamilyDetail;
            if ($('panel-employees')) $('panel-employees').onclick = showEmployeesDetail;

            // WAIT MODAL HANDLERS
            $$('.wait-btn').forEach(btn => {
                btn.onclick = () => {
                    const mins = parseInt(btn.dataset.minutes);
                    advanceTime(mins);
                    closeAllModals();
                    const timeStr = mins >= 1440 ? `${Math.floor(mins/1440)} giorno/i` : 
                                   mins >= 60 ? `${Math.floor(mins/60)} ora/e` : `${mins} minuti`;
                    addStoryEntry(`‚è∞ Passano ${timeStr}... Ora sono le ${getTimeString()}, ${getTimePeriod().name}.`, 'system');
                    generateAI(`√à passato del tempo. Ora √® ${getFullTimeString()}. Descrivi brevemente cosa √® cambiato nella scena o cosa succede.`);
                };
            });
            $('btn-wait-until').onclick = () => {
                const targetHour = parseInt($('wait-until-hour').value);
                const waited = waitUntilHour(targetHour);
                closeAllModals();
                if (waited > 0) {
                    addStoryEntry(`‚è∞ Aspetti fino alle ${targetHour.toString().padStart(2,'0')}:00...`, 'system');
                    generateAI(`√à passato del tempo. Ora √® ${getFullTimeString()}. Descrivi brevemente cosa √® cambiato.`);
                }
            };

            // INPUT
            $('btn-send').onclick = sendAction;
            $('action-input').onkeypress = e => { if (e.key === 'Enter') sendAction(); };

            // DICE
            $$('.dice-btn').forEach(btn => {
                btn.onclick = () => rollDice(parseInt(btn.dataset.sides));
            });

            // STORIES
            $('stories-list').onclick = e => {
                const card = e.target.closest('.story-card');
                if (card) {
                    G.selectedStory = parseInt(card.dataset.idx);
                    updateStoriesUI();
                }
            };
            $('btn-create-story').onclick = () => openStoryEditor();
            $('btn-edit-story').onclick = () => { if (G.selectedStory !== null) openStoryEditor(G.stories[G.selectedStory]); };
            $('btn-delete-story').onclick = () => {
                if (G.selectedStory !== null && confirm('Eliminare questa storia?')) {
                    G.stories.splice(G.selectedStory, 1);
                    G.selectedStory = null;
                    save();
                    updateStoriesUI();
                }
            };
            $('btn-save-story').onclick = saveStoryFromEditor;

            // NEW GAME
            $('new-game-story').onchange = () => { G.selectedOrigin = null; G.selectedArchetype = null; renderCreationOptions(); };
            $('origin-grid').onclick = e => {
                const opt = e.target.closest('.creation-option');
                if (opt) {
                    $$('#origin-grid .creation-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    G.selectedOrigin = opt.dataset.origin;
                }
            };
            $('archetype-grid').onclick = e => {
                const opt = e.target.closest('.creation-option');
                if (opt) {
                    $$('#archetype-grid .creation-option').forEach(o => o.classList.remove('selected'));
                    opt.classList.add('selected');
                    G.selectedArchetype = opt.dataset.archetype;
                }
            };
            $('btn-start-game').onclick = startNewGame;

            // SAVES
            $('saves-list').onclick = e => {
                const slot = e.target.closest('.save-slot');
                if (slot) {
                    G.selectedSave = parseInt(slot.dataset.idx);
                    updateSavesUI();
                }
            };
            $('btn-save-to-slot').onclick = saveToSlot;
            $('btn-load-from-slot').onclick = loadFromSlot;
            $('btn-delete-slot').onclick = () => {
                if (G.selectedSave !== null && G.saves[G.selectedSave] && confirm('Eliminare questo salvataggio?')) {
                    G.saves[G.selectedSave] = null;
                    save();
                    updateSavesUI();
                }
            };

            // SETTINGS
            $('btn-save-settings').onclick = () => {
                G.settings.groqKey = $('set-groq-key').value;
                G.settings.openrouterKey = $('set-openrouter-key').value;
                G.settings.kimeraKey = $('set-kimera-key').value;
                G.settings.model = $('set-model').value;
                G.settings.length = $('set-length').value;
                G.settings.autoRoll = $('set-autoroll').checked;
                save();
                notify('Impostazioni salvate!', 'success');
            };
            $('btn-reset-all').onclick = () => {
                if (confirm('‚ö†Ô∏è Cancellare TUTTI i dati?')) {
                    localStorage.removeItem('dnd_v4');
                    location.reload();
                }
            };

            // MODAL CLOSES
            $$('.modal-close, [data-close]').forEach(btn => {
                btn.onclick = () => {
                    const id = btn.dataset.close || btn.closest('.modal-overlay')?.id;
                    if (id) closeModal(id);
                };
            });

            $$('.modal-overlay').forEach(overlay => {
                overlay.onclick = e => {
                    if (e.target === overlay) closeModal(overlay.id);
                };
            });

            // Memory Tabs
            $$('.tab').forEach(tab => {
                tab.onclick = () => {
                    $$('.tab').forEach(t => t.classList.remove('active'));
                    $$('.tab-content').forEach(c => c.classList.remove('active'));
                    tab.classList.add('active');
                    $(`tab-${tab.dataset.tab}`).classList.add('active');
                    if (tab.dataset.tab === 'journal') updateJournalUI();
                };
            });

            // Level-Up Confirm
            if ($('btn-confirm-levelup')) {
                $('btn-confirm-levelup').onclick = confirmLevelUp;
            }

            // Journal
            if ($('btn-add-journal')) {
                $('btn-add-journal').onclick = () => {
                    const input = $('journal-text');
                    if (input && input.value.trim()) {
                        addJournalEntry(input.value.trim());
                        input.value = '';
                    }
                };
            }

            // Game Over buttons
            if ($('btn-gameover-load')) {
                $('btn-gameover-load').onclick = () => {
                    closeGameOver();
                    updateSavesUI();
                    openModal('modal-saves');
                };
            }
            if ($('btn-gameover-home')) {
                $('btn-gameover-home').onclick = () => {
                    closeGameOver();
                    showScreen('home-screen');
                };
            }
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
